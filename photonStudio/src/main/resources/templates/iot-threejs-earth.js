!function (e) { var t; "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : ("undefined" != typeof window ? t = window : "undefined" != typeof global ? t = global : "undefined" != typeof self && (t = self), t.CANNON = e()) }(function () { return function r(n, a, o) { function s(t, e) { if (!a[t]) { if (!n[t]) { var i = "function" == typeof require && require; if (!e && i) return i(t, !0); if (l) return l(t, !0); throw new Error("Cannot find module '" + t + "'") } e = a[t] = { exports: {} }, n[t][0].call(e.exports, function (e) { return s(n[t][1][e] || e) }, e, e.exports, r, n, a, o) } return a[t].exports } for (var l = "function" == typeof require && require, e = 0; e < o.length; e++)s(o[e]); return s }({ 1: [function (e, t, i) { t.exports = { name: "cannon", version: "0.6.2", description: "A lightweight 3D physics engine written in JavaScript.", homepage: "https://github.com/schteppe/cannon.js", author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)", keywords: ["cannon.js", "cannon", "physics", "engine", "3d"], main: "./build/cannon.js", engines: { node: "*" }, repository: { type: "git", url: "https://github.com/schteppe/cannon.js.git" }, bugs: { url: "https://github.com/schteppe/cannon.js/issues" }, licenses: [{ type: "MIT" }], devDependencies: { jshint: "latest", "uglify-js": "latest", nodeunit: "^0.9.0", grunt: "~0.4.0", "grunt-contrib-jshint": "~0.1.1", "grunt-contrib-nodeunit": "^0.4.1", "grunt-contrib-concat": "~0.1.3", "grunt-contrib-uglify": "^0.5.1", "grunt-browserify": "^2.1.4", "grunt-contrib-yuidoc": "^0.5.2", browserify: "*" }, dependencies: {} } }, {}], 2: [function (e, t, i) { t.exports = { version: e("../package.json").version, AABB: e("./collision/AABB"), ArrayCollisionMatrix: e("./collision/ArrayCollisionMatrix"), Body: e("./objects/Body"), Box: e("./shapes/Box"), Broadphase: e("./collision/Broadphase"), Constraint: e("./constraints/Constraint"), ContactEquation: e("./equations/ContactEquation"), Narrowphase: e("./world/Narrowphase"), ConeTwistConstraint: e("./constraints/ConeTwistConstraint"), ContactMaterial: e("./material/ContactMaterial"), ConvexPolyhedron: e("./shapes/ConvexPolyhedron"), Cylinder: e("./shapes/Cylinder"), DistanceConstraint: e("./constraints/DistanceConstraint"), Equation: e("./equations/Equation"), EventTarget: e("./utils/EventTarget"), FrictionEquation: e("./equations/FrictionEquation"), GSSolver: e("./solver/GSSolver"), GridBroadphase: e("./collision/GridBroadphase"), Heightfield: e("./shapes/Heightfield"), HingeConstraint: e("./constraints/HingeConstraint"), LockConstraint: e("./constraints/LockConstraint"), Mat3: e("./math/Mat3"), Material: e("./material/Material"), NaiveBroadphase: e("./collision/NaiveBroadphase"), ObjectCollisionMatrix: e("./collision/ObjectCollisionMatrix"), Pool: e("./utils/Pool"), Particle: e("./shapes/Particle"), Plane: e("./shapes/Plane"), PointToPointConstraint: e("./constraints/PointToPointConstraint"), Quaternion: e("./math/Quaternion"), Ray: e("./collision/Ray"), RaycastVehicle: e("./objects/RaycastVehicle"), RaycastResult: e("./collision/RaycastResult"), RigidVehicle: e("./objects/RigidVehicle"), RotationalEquation: e("./equations/RotationalEquation"), RotationalMotorEquation: e("./equations/RotationalMotorEquation"), SAPBroadphase: e("./collision/SAPBroadphase"), SPHSystem: e("./objects/SPHSystem"), Shape: e("./shapes/Shape"), Solver: e("./solver/Solver"), Sphere: e("./shapes/Sphere"), SplitSolver: e("./solver/SplitSolver"), Spring: e("./objects/Spring"), Trimesh: e("./shapes/Trimesh"), Vec3: e("./math/Vec3"), Vec3Pool: e("./utils/Vec3Pool"), World: e("./world/World") } }, { "../package.json": 1, "./collision/AABB": 3, "./collision/ArrayCollisionMatrix": 4, "./collision/Broadphase": 5, "./collision/GridBroadphase": 6, "./collision/NaiveBroadphase": 7, "./collision/ObjectCollisionMatrix": 8, "./collision/Ray": 9, "./collision/RaycastResult": 10, "./collision/SAPBroadphase": 11, "./constraints/ConeTwistConstraint": 12, "./constraints/Constraint": 13, "./constraints/DistanceConstraint": 14, "./constraints/HingeConstraint": 15, "./constraints/LockConstraint": 16, "./constraints/PointToPointConstraint": 17, "./equations/ContactEquation": 19, "./equations/Equation": 20, "./equations/FrictionEquation": 21, "./equations/RotationalEquation": 22, "./equations/RotationalMotorEquation": 23, "./material/ContactMaterial": 24, "./material/Material": 25, "./math/Mat3": 27, "./math/Quaternion": 28, "./math/Vec3": 30, "./objects/Body": 31, "./objects/RaycastVehicle": 32, "./objects/RigidVehicle": 33, "./objects/SPHSystem": 34, "./objects/Spring": 35, "./shapes/Box": 37, "./shapes/ConvexPolyhedron": 38, "./shapes/Cylinder": 39, "./shapes/Heightfield": 40, "./shapes/Particle": 41, "./shapes/Plane": 42, "./shapes/Shape": 43, "./shapes/Sphere": 44, "./shapes/Trimesh": 45, "./solver/GSSolver": 46, "./solver/Solver": 47, "./solver/SplitSolver": 48, "./utils/EventTarget": 49, "./utils/Pool": 51, "./utils/Vec3Pool": 54, "./world/Narrowphase": 55, "./world/World": 56 }], 3: [function (e, t, i) { var r = e("../math/Vec3"); function n(e) { e = e || {}, this.lowerBound = new r, e.lowerBound && this.lowerBound.copy(e.lowerBound), this.upperBound = new r, e.upperBound && this.upperBound.copy(e.upperBound) } e("../utils/Utils"), t.exports = n; var c = new r, a = (n.prototype.setFromPoints = function (e, t, i, r) { var n = this.lowerBound, a = this.upperBound, o = i; n.copy(e[0]), o && o.vmult(n, n), a.copy(n); for (var s = 1; s < e.length; s++) { var l = e[s]; o && (o.vmult(l, c), l = c), l.x > a.x && (a.x = l.x), l.x < n.x && (n.x = l.x), l.y > a.y && (a.y = l.y), l.y < n.y && (n.y = l.y), l.z > a.z && (a.z = l.z), l.z < n.z && (n.z = l.z) } return t && (t.vadd(n, n), t.vadd(a, a)), r && (n.x -= r, n.y -= r, n.z -= r, a.x += r, a.y += r, a.z += r), this }, n.prototype.copy = function (e) { return this.lowerBound.copy(e.lowerBound), this.upperBound.copy(e.upperBound), this }, n.prototype.clone = function () { return (new n).copy(this) }, n.prototype.extend = function (e) { var t = e.lowerBound.x, i = (this.lowerBound.x > t && (this.lowerBound.x = t), e.upperBound.x), t = (this.upperBound.x < i && (this.upperBound.x = i), e.lowerBound.y), i = (this.lowerBound.y > t && (this.lowerBound.y = t), e.upperBound.y), t = (this.upperBound.y < i && (this.upperBound.y = i), e.lowerBound.z), i = (this.lowerBound.z > t && (this.lowerBound.z = t), e.upperBound.z); this.upperBound.z < i && (this.upperBound.z = i) }, n.prototype.overlaps = function (e) { var t = this.lowerBound, i = this.upperBound, r = e.lowerBound, e = e.upperBound; return (r.x <= i.x && i.x <= e.x || t.x <= e.x && e.x <= i.x) && (r.y <= i.y && i.y <= e.y || t.y <= e.y && e.y <= i.y) && (r.z <= i.z && i.z <= e.z || t.z <= e.z && e.z <= i.z) }, n.prototype.contains = function (e) { var t = this.lowerBound, i = this.upperBound, r = e.lowerBound, e = e.upperBound; return t.x <= r.x && i.x >= e.x && t.y <= r.y && i.y >= e.y && t.z <= r.z && i.z >= e.z }, n.prototype.getCorners = function (e, t, i, r, n, a, o, s) { var l = this.lowerBound, c = this.upperBound; e.copy(l), t.set(c.x, l.y, l.z), i.set(c.x, c.y, l.z), r.set(l.x, c.y, c.z), n.set(c.x, l.y, l.z), a.set(l.x, c.y, l.z), o.set(l.x, l.y, c.z), s.copy(c) }, [new r, new r, new r, new r, new r, new r, new r, new r]); n.prototype.toLocalFrame = function (e, t) { var i = a; this.getCorners(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7]); for (var r = 0; 8 !== r; r++) { var n = i[r]; e.pointToLocal(n, n) } return t.setFromPoints(i) }, n.prototype.toWorldFrame = function (e, t) { var i = a; this.getCorners(i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7]); for (var r = 0; 8 !== r; r++) { var n = i[r]; e.pointToWorld(n, n) } return t.setFromPoints(i) } }, { "../math/Vec3": 30, "../utils/Utils": 53 }], 4: [function (e, t, i) { function r() { this.matrix = [] } (t.exports = r).prototype.get = function (e, t) { var i; return (e = e.index) < (t = t.index) && (i = t, t = e, e = i), this.matrix[(e * (e + 1) >> 1) + t - 1] }, r.prototype.set = function (e, t, i) { var r; (e = e.index) < (t = t.index) && (r = t, t = e, e = r), this.matrix[(e * (e + 1) >> 1) + t - 1] = i ? 1 : 0 }, r.prototype.reset = function () { for (var e = 0, t = this.matrix.length; e !== t; e++)this.matrix[e] = 0 }, r.prototype.setNumObjects = function (e) { this.matrix.length = e * (e - 1) >> 1 } }, {}], 5: [function (e, t, i) { var r = e("../objects/Body"), n = e("../math/Vec3"), a = e("../math/Quaternion"); function o() { this.world = null, this.useBoundingBoxes = !1, this.dirty = !0 } e("../shapes/Shape"), e("../shapes/Plane"), (t.exports = o).prototype.collisionPairs = function (e, t, i) { throw new Error("collisionPairs not implemented for this BroadPhase class!") }; var s = r.STATIC | r.KINEMATIC, l = (o.prototype.needBroadphaseCollision = function (e, t) { return 0 != (e.collisionFilterGroup & t.collisionFilterMask) && 0 != (t.collisionFilterGroup & e.collisionFilterMask) && (0 == (e.type & s) && e.sleepState !== r.SLEEPING || 0 == (t.type & s) && t.sleepState !== r.SLEEPING) }, o.prototype.intersectionTest = function (e, t, i, r) { this.useBoundingBoxes ? this.doBoundingBoxBroadphase(e, t, i, r) : this.doBoundingSphereBroadphase(e, t, i, r) }, new n), u = (new n, new a, new n, o.prototype.doBoundingSphereBroadphase = function (e, t, i, r) { var n = l, a = (t.position.vsub(e.position, n), Math.pow(e.boundingRadius + t.boundingRadius, 2)); n.norm2() < a && (i.push(e), r.push(t)) }, o.prototype.doBoundingBoxBroadphase = function (e, t, i, r) { e.aabbNeedsUpdate && e.computeAABB(), t.aabbNeedsUpdate && t.computeAABB(), e.aabb.overlaps(t.aabb) && (i.push(e), r.push(t)) }, { keys: [] }), d = [], p = [], c = (o.prototype.makePairsUnique = function (e, t) { for (var i = u, r = d, n = p, a = e.length, o = 0; o !== a; o++)r[o] = e[o], n[o] = t[o]; for (e.length = 0, o = t.length = 0; o !== a; o++) { var s = r[o].id, l = n[o].id; i[c = s < l ? s + "," + l : l + "," + s] = o, i.keys.push(c) } for (o = 0; o !== i.keys.length; o++) { var c = i.keys.pop(), h = i[c]; e.push(r[h]), t.push(n[h]), delete i[c] } }, o.prototype.setWorld = function (e) { }, new n); o.boundingSphereCheck = function (e, t) { var i = c; return e.position.vsub(t.position, i), Math.pow(e.shape.boundingSphereRadius + t.shape.boundingSphereRadius, 2) > i.norm2() }, o.prototype.aabbQuery = function (e, t, i) { return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [] } }, { "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/Body": 31, "../shapes/Plane": 42, "../shapes/Shape": 43 }], 6: [function (e, t, i) { t.exports = r; var s = e("./Broadphase"), l = e("../math/Vec3"), K = e("../shapes/Shape"); function r(e, t, i, r, n) { s.apply(this), this.nx = i || 10, this.ny = r || 10, this.nz = n || 10, this.aabbMin = e || new l(100, 100, 100), this.aabbMax = t || new l(-100, -100, -100); var a = this.nx * this.ny * this.nz; if (a <= 0) throw "GridBroadphase: Each dimension's n must be >0"; this.bins = [], this.binLengths = [], this.bins.length = a, this.binLengths.length = a; for (var o = 0; o < a; o++)this.bins[o] = [], this.binLengths[o] = 0 } (r.prototype = new s).constructor = r; var $ = new l; new l, r.prototype.collisionPairs = function (e, t, i) { for (var H = e.numObjects(), B = e.bodies, e = this.aabbMax, r = this.aabbMin, v = this.nx, g = this.ny, x = this.nz, y = g * x, _ = x, b = 1, n = e.x, a = e.y, e = e.z, w = r.x, E = r.y, T = r.z, S = v / (n - w), M = g / (a - E), A = x / (e - T), o = (n - w) / v, s = (a - E) / g, l = (e - T) / x, U = .5 * Math.sqrt(o * o + s * s + l * l), z = (r = K.types).SPHERE, O = r.PLANE, R = (r.BOX, r.COMPOUND, r.CONVEXPOLYHEDRON, this.bins), L = this.binLengths, c = this.bins.length, h = 0; h !== c; h++)L[h] = 0; var P = Math.ceil; function u(e, t, i, r, n, a, o) { var e = (e - w) * S | 0, s = (t - E) * M | 0, l = (i - T) * A | 0, c = P((r - w) * S), h = P((n - E) * M), u = P((a - T) * A); e < 0 ? e = 0 : v <= e && (e = v - 1), s < 0 ? s = 0 : g <= s && (s = g - 1), l < 0 ? l = 0 : x <= l && (l = x - 1), c < 0 ? c = 0 : v <= c && (c = v - 1), h < 0 ? h = 0 : g <= h && (h = g - 1), u < 0 ? u = 0 : x <= u && (u = x - 1), s *= _, l *= b, c *= y, h *= _, u *= b; for (var d = e *= y; d <= c; d += y)for (var p = s; p <= h; p += _)for (var f = l; f <= u; f += b) { var m = d + p + f; R[m][L[m]++] = o } } for (Math.min, Math.max, h = 0; h !== H; h++) { var d = (N = B[h]).shape; switch (d.type) { case z: var p = N.position.x, f = N.position.y, m = N.position.z, C = d.radius; u(p - C, f - C, m - C, p + C, f + C, m + C, N); break; case O: d.worldNormalNeedsUpdate && d.computeWorldNormal(N.quaternion); var V = d.worldNormal, p = w + .5 * o - N.position.x, k = E + .5 * s - N.position.y, G = T + .5 * l - N.position.z, F = $; F.set(p, k, G); for (var D = 0, W = 0; D !== v; D++, W += y, F.y = k, F.x += o)for (var I = 0, j = 0; I !== g; I++, j += _, F.z = G, F.y += s)for (var X, q = 0, Y = 0; q !== x; q++, Y += b, F.z += l)F.dot(V) < U && (R[X = W + j + Y][L[X]++] = N); break; default: N.aabbNeedsUpdate && N.computeAABB(), u(N.aabb.lowerBound.x, N.aabb.lowerBound.y, N.aabb.lowerBound.z, N.aabb.upperBound.x, N.aabb.upperBound.y, N.aabb.upperBound.z, N) } } for (h = 0; h !== c; h++) { var Q = L[h]; if (1 < Q) for (var Z = R[h], D = 0; D !== Q; D++)for (var N = Z[D], I = 0; I !== D; I++) { var J = Z[I]; this.needBroadphaseCollision(N, J) && this.intersectionTest(N, J, t, i) } } this.makePairsUnique(t, i) } }, { "../math/Vec3": 30, "../shapes/Shape": 43, "./Broadphase": 5 }], 7: [function (e, t, i) { t.exports = n; var r = e("./Broadphase"), t = e("./AABB"); function n() { r.apply(this) } ((n.prototype = new r).constructor = n).prototype.collisionPairs = function (e, t, i) { for (var r, n, a, o = e.bodies, s = o.length, l = 0; l !== s; l++)for (r = 0; r !== l; r++)n = o[l], a = o[r], this.needBroadphaseCollision(n, a) && this.intersectionTest(n, a, t, i) }, new t, n.prototype.aabbQuery = function (e, t, i) { i = i || []; for (var r = 0; r < e.bodies.length; r++) { var n = e.bodies[r]; n.aabbNeedsUpdate && n.computeAABB(), n.aabb.overlaps(t) && i.push(n) } return i } }, { "./AABB": 3, "./Broadphase": 5 }], 8: [function (e, t, i) { function r() { this.matrix = {} } (t.exports = r).prototype.get = function (e, t) { var i; return (e = e.id) < (t = t.id) && (i = t, t = e, e = i), e + "-" + t in this.matrix }, r.prototype.set = function (e, t, i) { var r; (e = e.id) < (t = t.id) && (r = t, t = e, e = r), i ? this.matrix[e + "-" + t] = !0 : delete this.matrix[e + "-" + t] }, r.prototype.reset = function () { this.matrix = {} }, r.prototype.setNumObjects = function (e) { } }, {}], 9: [function (e, t, i) { t.exports = f; var p = e("../math/Vec3"), t = e("../math/Quaternion"), w = e("../math/Transform"), r = (e("../shapes/ConvexPolyhedron"), e("../shapes/Box"), e("../collision/RaycastResult")), n = e("../shapes/Shape"), e = e("../collision/AABB"); function f(e, t) { this.from = e ? e.clone() : new p, this.to = t ? t.clone() : new p, this._direction = new p, this.precision = 1e-4, this.checkCollisionResponse = !0, this.skipBackfaces = !1, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = f.ANY, this.result = new r, this.hasHit = !1, this.callback = function (e) { } } (f.prototype.constructor = f).CLOSEST = 1, f.ANY = 2, f.ALL = 4; var a = new e, o = [], s = (f.prototype.intersectWorld = function (e, t) { return this.mode = t.mode || f.ANY, this.result = t.result || new r, this.skipBackfaces = !!t.skipBackfaces, this.collisionFilterMask = void 0 !== t.collisionFilterMask ? t.collisionFilterMask : -1, this.collisionFilterGroup = void 0 !== t.collisionFilterGroup ? t.collisionFilterGroup : -1, t.from && this.from.copy(t.from), t.to && this.to.copy(t.to), this.callback = t.callback || function () { }, this.hasHit = !1, this.result.reset(), this._updateDirection(), this.getAABB(a), o.length = 0, e.broadphase.aabbQuery(e, a, o), this.intersectBodies(o), this.hasHit }, new p), l = new p; function T(e, t, i, r) { r.vsub(t, u), i.vsub(t, s), e.vsub(t, l); var n, r = u.dot(u), i = u.dot(s), e = u.dot(l), t = s.dot(s), a = s.dot(l); return 0 <= (n = t * e - i * a) && 0 <= (a = r * a - i * e) && n + a < r * t - i * i } f.pointInTriangle = T; var c = new p, h = new t, S = (f.prototype.intersectBody = function (e, t) { t && (this.result = t, this._updateDirection()); var i = this.checkCollisionResponse; if ((!i || e.collisionResponse) && 0 != (this.collisionFilterGroup & e.collisionFilterMask) && 0 != (e.collisionFilterGroup & this.collisionFilterMask)) for (var r = c, n = h, a = 0, o = e.shapes.length; a < o; a++) { var s = e.shapes[a]; if ((!i || s.collisionResponse) && (e.quaternion.mult(e.shapeOrientations[a], n), e.quaternion.vmult(e.shapeOffsets[a], r), r.vadd(e.position, r), this.intersectShape(s, n, r, e), this.result._shouldStop)) break } }, f.prototype.intersectBodies = function (e, t) { t && (this.result = t, this._updateDirection()); for (var i = 0, r = e.length; !this.result._shouldStop && i < r; i++)this.intersectBody(e[i]) }, f.prototype._updateDirection = function () { this.to.vsub(this.from, this._direction), this._direction.normalize() }, f.prototype.intersectShape = function (e, t, i, r) { var n, a, o = this.from, s = this._direction; (n = i).vsub(o, u), a = u.dot(s), s.mult(a, g), g.vadd(o, g), n.distanceTo(g) > e.boundingSphereRadius || (s = this[e.type]) && s.call(this, e, t, i, r) }, new p, new p, new p), M = new p, A = new p, R = new p, m = (new p, new r, f.prototype[n.types.BOX] = f.prototype.intersectBox = function (e, t, i, r) { return this.intersectConvex(e.convexPolyhedronRepresentation, t, i, r) }, f.prototype[n.types.PLANE] = f.prototype.intersectPlane = function (e, t, i, r) { var n, a = this.from, o = this.to, s = this._direction, l = new p(0, 0, 1), t = (t.vmult(l, l), new p), c = (a.vsub(i, t), t.dot(l)); o.vsub(i, t), 0 < c * t.dot(l) || a.distanceTo(o) < c || (t = l.dot(s), Math.abs(t) < this.precision || (o = new p, c = new p, n = new p, a.vsub(i, o), i = -l.dot(o) / t, s.scale(i, c), a.vadd(c, n), this.reportIntersection(l, n, e, r, -1))) }, f.prototype.getAABB = function (e) { var t = this.to, i = this.from; e.lowerBound.x = Math.min(t.x, i.x), e.lowerBound.y = Math.min(t.y, i.y), e.lowerBound.z = Math.min(t.z, i.z), e.upperBound.x = Math.max(t.x, i.x), e.upperBound.y = Math.max(t.y, i.y), e.upperBound.z = Math.max(t.z, i.z) }, { faceList: [0] }), d = (f.prototype[n.types.HEIGHTFIELD] = f.prototype.intersectHeightfield = function (e, t, i, r) { e.data, e.elementSize; var n = new p, a = new f(this.from, this.to), o = (w.pointToLocalFrame(i, t, a.from, a.from), w.pointToLocalFrame(i, t, a.to, a.to), []), s = null, l = null, c = null, h = null; if (e.getIndexOfPosition(a.from.x, a.from.y, o, !1) && (c = s = o[0], h = l = o[1]), e.getIndexOfPosition(a.to.x, a.to.y, o, !1) && ((null === s || o[0] < s) && (s = o[0]), (null === c || c < o[0]) && (c = o[0]), (null === l || o[1] < l) && (l = o[1]), (null === h || h < o[1]) && (h = o[1])), null !== s) { e.getRectMinMax(s, l, c, h, []); for (var u = s; u <= c; u++)for (var d = l; d <= h; d++) { if (this.result._shouldStop) return; if (e.getConvexTrianglePillar(u, d, !1), w.pointToWorldFrame(i, t, e.pillarOffset, n), this.intersectConvex(e.pillarConvex, t, n, r, m), this.result._shouldStop) return; e.getConvexTrianglePillar(u, d, !0), w.pointToWorldFrame(i, t, e.pillarOffset, n), this.intersectConvex(e.pillarConvex, t, n, r, m) } } }, new p), v = new p, L = (f.prototype[n.types.SPHERE] = f.prototype.intersectSphere = function (e, t, i, r) { var n, a = this.from, o = this.to, s = e.radius, l = Math.pow(o.x - a.x, 2) + Math.pow(o.y - a.y, 2) + Math.pow(o.z - a.z, 2), c = 2 * ((o.x - a.x) * (a.x - i.x) + (o.y - a.y) * (a.y - i.y) + (o.z - a.z) * (a.z - i.z)), s = Math.pow(a.x - i.x, 2) + Math.pow(a.y - i.y, 2) + Math.pow(a.z - i.z, 2) - Math.pow(s, 2), s = Math.pow(c, 2) - 4 * l * s, h = d, u = v; s < 0 || (0 == s ? (a.lerp(o, s, h), h.vsub(i, u), u.normalize(), this.reportIntersection(u, h, e, r, -1)) : (n = (-c - Math.sqrt(s)) / (2 * l), c = (-c + Math.sqrt(s)) / (2 * l), 0 <= n && n <= 1 && (a.lerp(o, n, h), h.vsub(i, u), u.normalize(), this.reportIntersection(u, h, e, r, -1)), this.result._shouldStop || 0 <= c && c <= 1 && (a.lerp(o, c, h), h.vsub(i, u), u.normalize(), this.reportIntersection(u, h, e, r, -1)))) }, new p), P = (new p, new p, new p), E = (f.prototype[n.types.CONVEXPOLYHEDRON] = f.prototype.intersectConvex = function (e, t, i, r, n) { for (var a = L, o = P, s = n && n.faceList || null, l = e.faces, c = e.vertices, h = e.faceNormals, u = this._direction, d = this.from, n = this.to, p = d.distanceTo(n), f = (s || l).length, m = this.result, v = 0; !m._shouldStop && v < f; v++) { var g = s ? s[v] : v, x = l[g], y = h[g], _ = t, b = i, y = (o.copy(c[x[0]]), _.vmult(o, o), o.vadd(b, o), o.vsub(d, o), _.vmult(y, a), u.dot(a)); if (!(Math.abs(y) < this.precision || (y = a.dot(o) / y) < 0)) { u.mult(y, S), S.vadd(d, S), M.copy(c[x[0]]), _.vmult(M, M), b.vadd(M, M); for (var w = 1; !m._shouldStop && w < x.length - 1; w++) { A.copy(c[x[w]]), R.copy(c[x[w + 1]]), _.vmult(A, A), _.vmult(R, R), b.vadd(A, A), b.vadd(R, R); var E = S.distanceTo(d); !T(S, M, A, R) && !T(S, A, M, R) || p < E || this.reportIntersection(a, S, e, r, g) } } } }, new p), C = new p, F = new p, D = new p, I = new p, N = new p, H = (new e, []), B = new w, u = (f.prototype[n.types.TRIMESH] = f.prototype.intersectTrimesh = function (e, t, i, r, n) { var a = E, o = H, s = B, l = P, c = C, h = F, u = D, d = N, p = I, f = (n && n.faceList, e.indices), n = (e.vertices, e.faceNormals, this.from), m = this.to, v = this._direction, g = (s.position.copy(i), s.quaternion.copy(t), w.vectorToLocalFrame(i, t, v, c), w.pointToLocalFrame(i, t, n, h), w.pointToLocalFrame(i, t, m, u), h.distanceSquared(u)); e.tree.rayQuery(this, s, o); for (var x = 0, y = o.length; !this.result._shouldStop && x !== y; x++) { var _ = o[x], b = (e.getNormal(_, a), e.getVertex(f[3 * _], M), M.vsub(h, l), c.dot(a)); (b = a.dot(l) / b) < 0 || (c.scale(b, S), S.vadd(h, S), e.getVertex(f[3 * _ + 1], A), e.getVertex(f[3 * _ + 2], R), b = S.distanceSquared(h), !T(S, A, M, R) && !T(S, M, A, R) || g < b || (w.vectorToWorldFrame(t, a, p), w.pointToWorldFrame(i, t, S, d), this.reportIntersection(p, d, e, r, _))) } o.length = 0 }, f.prototype.reportIntersection = function (e, t, i, r, n) { var a = this.from, o = this.to, s = a.distanceTo(t), l = this.result; if (!(this.skipBackfaces && 0 < e.dot(this._direction))) switch (l.hitFaceIndex = void 0 !== n ? n : -1, this.mode) { case f.ALL: this.hasHit = !0, l.set(a, o, e, t, i, r, s), l.hasHit = !0, this.callback(l); break; case f.CLOSEST: (s < l.distance || !l.hasHit) && (this.hasHit = !0, l.hasHit = !0, l.set(a, o, e, t, i, r, s)); break; case f.ANY: this.hasHit = !0, l.hasHit = !0, l.set(a, o, e, t, i, r, s), l._shouldStop = !0 } }, new p), g = new p }, { "../collision/AABB": 3, "../collision/RaycastResult": 10, "../math/Quaternion": 28, "../math/Transform": 29, "../math/Vec3": 30, "../shapes/Box": 37, "../shapes/ConvexPolyhedron": 38, "../shapes/Shape": 43 }], 10: [function (e, t, i) { var r = e("../math/Vec3"); function n() { this.rayFromWorld = new r, this.rayToWorld = new r, this.hitNormalWorld = new r, this.hitPointWorld = new r, this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1 } (t.exports = n).prototype.reset = function () { this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = !1, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this._shouldStop = !1 }, n.prototype.abort = function () { this._shouldStop = !0 }, n.prototype.set = function (e, t, i, r, n, a, o) { this.rayFromWorld.copy(e), this.rayToWorld.copy(t), this.hitNormalWorld.copy(i), this.hitPointWorld.copy(r), this.shape = n, this.body = a, this.distance = o } }, { "../math/Vec3": 30 }], 11: [function (e, t, i) { e("../shapes/Shape"); var r = e("../collision/Broadphase"); function h(e) { r.apply(this), this.axisList = [], this.world = null, this.axisIndex = 0; var t = this.axisList; this._addBodyHandler = function (e) { t.push(e.body) }, this._removeBodyHandler = function (e) { -1 !== (e = t.indexOf(e.body)) && t.splice(e, 1) }, e && this.setWorld(e) } ((t.exports = h).prototype = new r).setWorld = function (e) { for (var t = this.axisList.length = 0; t < e.bodies.length; t++)this.axisList.push(e.bodies[t]); e.removeEventListener("addBody", this._addBodyHandler), e.removeEventListener("removeBody", this._removeBodyHandler), e.addEventListener("addBody", this._addBodyHandler), e.addEventListener("removeBody", this._removeBodyHandler), this.world = e, this.dirty = !0 }, h.insertionSortX = function (e) { for (var t = 1, i = e.length; t < i; t++) { for (var r = e[t], n = t - 1; 0 <= n && !(e[n].aabb.lowerBound.x <= r.aabb.lowerBound.x); n--)e[n + 1] = e[n]; e[n + 1] = r } return e }, h.insertionSortY = function (e) { for (var t = 1, i = e.length; t < i; t++) { for (var r = e[t], n = t - 1; 0 <= n && !(e[n].aabb.lowerBound.y <= r.aabb.lowerBound.y); n--)e[n + 1] = e[n]; e[n + 1] = r } return e }, h.insertionSortZ = function (e) { for (var t = 1, i = e.length; t < i; t++) { for (var r = e[t], n = t - 1; 0 <= n && !(e[n].aabb.lowerBound.z <= r.aabb.lowerBound.z); n--)e[n + 1] = e[n]; e[n + 1] = r } return e }, h.prototype.collisionPairs = function (e, t, i) { var r, n = this.axisList, a = n.length, o = this.axisIndex; for (this.dirty && (this.sortList(), this.dirty = !1), r = 0; r !== a; r++)for (var s = n[r], l = r + 1; l < a; l++) { var c = n[l]; if (this.needBroadphaseCollision(s, c)) { if (!h.checkBounds(s, c, o)) break; this.intersectionTest(s, c, t, i) } } }, h.prototype.sortList = function () { for (var e = this.axisList, t = this.axisIndex, i = e.length, r = 0; r !== i; r++) { var n = e[r]; n.aabbNeedsUpdate && n.computeAABB() } 0 === t ? h.insertionSortX(e) : 1 === t ? h.insertionSortY(e) : 2 === t && h.insertionSortZ(e) }, h.checkBounds = function (e, t, i) { 0 === i ? (r = e.position.x, n = t.position.x) : 1 === i ? (r = e.position.y, n = t.position.y) : 2 === i && (r = e.position.z, n = t.position.z); var r, n, i = e.boundingRadius; return n - (e = t.boundingRadius) < r + i }, h.prototype.autoDetectAxis = function () { for (var e = 0, t = 0, i = 0, r = 0, n = 0, a = 0, o = this.axisList, s = o.length, l = 1 / s, c = 0; c !== s; c++) { var h = o[c], u = h.position.x; e += u, t += u * u, i += u = h.position.y, r += u * u, n += u = h.position.z, a += u * u } var d = t - e * e * l, p = r - i * i * l, l = a - n * n * l; this.axisIndex = p < d ? l < d ? 0 : 2 : l < p ? 1 : 2 }, h.prototype.aabbQuery = function (e, t, i) { i = i || [], this.dirty && (this.sortList(), this.dirty = !1); for (var r = 2 === (r = this.axisIndex) ? "z" : 1 === r ? "y" : "x", n = this.axisList, a = (t.lowerBound[r], t.upperBound[r], 0); a < n.length; a++) { var o = n[a]; o.aabbNeedsUpdate && o.computeAABB(), o.aabb.overlaps(t) && i.push(o) } return i } }, { "../collision/Broadphase": 5, "../shapes/Shape": 43 }], 12: [function (e, t, i) { t.exports = r, e("./Constraint"); var o = e("./PointToPointConstraint"), s = e("../equations/ConeEquation"), l = e("../equations/RotationalEquation"), c = (e("../equations/ContactEquation"), e("../math/Vec3")); function r(e, t, i) { var r = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = i.pivotA ? i.pivotA.clone() : new c, a = i.pivotB ? i.pivotB.clone() : new c, n = (this.axisA = i.axisA ? i.axisA.clone() : new c, this.axisB = i.axisB ? i.axisB.clone() : new c, o.call(this, e, n, t, a, r), this.collideConnected = !!i.collideConnected, this.angle = void 0 !== i.angle ? i.angle : 0, this.coneEquation = new s(e, t, i)), a = this.twistEquation = new l(e, t, i); this.twistAngle = void 0 !== i.twistAngle ? i.twistAngle : 0, n.maxForce = 0, n.minForce = -r, a.maxForce = 0, a.minForce = -r, this.equations.push(n, a) } r.prototype = new o, r.constructor = r, new c, new c, r.prototype.update = function () { var e = this.bodyA, t = this.bodyB, i = this.coneEquation, r = this.twistEquation; o.prototype.update.call(this), e.vectorToWorldFrame(this.axisA, i.axisA), t.vectorToWorldFrame(this.axisB, i.axisB), this.axisA.tangents(r.axisA, r.axisA), e.vectorToWorldFrame(r.axisA, r.axisA), this.axisB.tangents(r.axisB, r.axisB), t.vectorToWorldFrame(r.axisB, r.axisB), i.angle = this.angle, r.maxAngle = this.twistAngle } }, { "../equations/ConeEquation": 18, "../equations/ContactEquation": 19, "../equations/RotationalEquation": 22, "../math/Vec3": 30, "./Constraint": 13, "./PointToPointConstraint": 17 }], 13: [function (e, t, i) { t.exports = n; var r = e("../utils/Utils"); function n(e, t, i) { i = r.defaults(i, { collideConnected: !0, wakeUpBodies: !0 }), this.equations = [], this.bodyA = e, this.bodyB = t, this.id = n.idCounter++, this.collideConnected = i.collideConnected, i.wakeUpBodies && (e && e.wakeUp(), t && t.wakeUp()) } n.prototype.update = function () { throw new Error("method update() not implmemented in this Constraint subclass!") }, n.prototype.enable = function () { for (var e = this.equations, t = 0; t < e.length; t++)e[t].enabled = !0 }, n.prototype.disable = function () { for (var e = this.equations, t = 0; t < e.length; t++)e[t].enabled = !1 }, n.idCounter = 0 }, { "../utils/Utils": 53 }], 14: [function (e, t, i) { t.exports = r; var n = e("./Constraint"), a = e("../equations/ContactEquation"); function r(e, t, i, r) { n.call(this, e, t), void 0 === i && (i = e.position.distanceTo(t.position)), void 0 === r && (r = 1e6), this.distance = i, i = this.distanceEquation = new a(e, t), this.equations.push(i), i.minForce = -r, i.maxForce = r } (r.prototype = new n).update = function () { var e = this.bodyA, t = this.bodyB, i = this.distanceEquation, r = .5 * this.distance, n = i.ni; t.position.vsub(e.position, n), n.normalize(), n.mult(r, i.ri), n.mult(-r, i.rj) } }, { "../equations/ContactEquation": 19, "./Constraint": 13 }], 15: [function (e, t, i) { t.exports = r, e("./Constraint"); var c = e("./PointToPointConstraint"), o = e("../equations/RotationalEquation"), s = e("../equations/RotationalMotorEquation"), l = (e("../equations/ContactEquation"), e("../math/Vec3")); function r(e, t, i) { var r = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = i.pivotA ? i.pivotA.clone() : new l, a = i.pivotB ? i.pivotB.clone() : new l; c.call(this, e, n, t, a, r), (this.axisA = i.axisA ? i.axisA.clone() : new l(1, 0, 0)).normalize(), (this.axisB = i.axisB ? i.axisB.clone() : new l(1, 0, 0)).normalize(), n = this.rotationalEquation1 = new o(e, t, i), a = this.rotationalEquation2 = new o(e, t, i), (i = this.motorEquation = new s(e, t, r)).enabled = !1, this.equations.push(n, a, i) } r.prototype = new c, (r.constructor = r).prototype.enableMotor = function () { this.motorEquation.enabled = !0 }, r.prototype.disableMotor = function () { this.motorEquation.enabled = !1 }, r.prototype.setMotorSpeed = function (e) { this.motorEquation.targetVelocity = e }, r.prototype.setMotorMaxForce = function (e) { this.motorEquation.maxForce = e, this.motorEquation.minForce = -e }; var h = new l, u = new l; r.prototype.update = function () { var e = this.bodyA, t = this.bodyB, i = this.motorEquation, r = this.rotationalEquation1, n = this.rotationalEquation2, a = h, o = u, s = this.axisA, l = this.axisB; c.prototype.update.call(this), e.quaternion.vmult(s, a), t.quaternion.vmult(l, o), a.tangents(r.axisA, n.axisA), r.axisB.copy(o), n.axisB.copy(o), this.motorEquation.enabled && (e.quaternion.vmult(this.axisA, i.axisA), t.quaternion.vmult(this.axisB, i.axisB)) } }, { "../equations/ContactEquation": 19, "../equations/RotationalEquation": 22, "../equations/RotationalMotorEquation": 23, "../math/Vec3": 30, "./Constraint": 13, "./PointToPointConstraint": 17 }], 16: [function (e, t, i) { t.exports = r, e("./Constraint"); var s = e("./PointToPointConstraint"), l = e("../equations/RotationalEquation"), c = (e("../equations/RotationalMotorEquation"), e("../equations/ContactEquation"), e("../math/Vec3")); function r(e, t, i) { var r = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6, n = new c, a = new c, o = new c, o = (e.position.vadd(t.position, o), o.scale(.5, o), t.pointToLocalFrame(o, a), e.pointToLocalFrame(o, n), s.call(this, e, n, t, a, r), this.rotationalEquation1 = new l(e, t, i)), n = this.rotationalEquation2 = new l(e, t, i), a = this.rotationalEquation3 = new l(e, t, i); this.equations.push(o, n, a) } r.prototype = new s, r.constructor = r, new c, new c, r.prototype.update = function () { var e = this.bodyA, t = this.bodyB, i = (this.motorEquation, this.rotationalEquation1), r = this.rotationalEquation2, n = this.rotationalEquation3; s.prototype.update.call(this), e.vectorToWorldFrame(c.UNIT_X, i.axisA), t.vectorToWorldFrame(c.UNIT_Y, i.axisB), e.vectorToWorldFrame(c.UNIT_Y, r.axisA), t.vectorToWorldFrame(c.UNIT_Z, r.axisB), e.vectorToWorldFrame(c.UNIT_Z, n.axisA), t.vectorToWorldFrame(c.UNIT_X, n.axisB) } }, { "../equations/ContactEquation": 19, "../equations/RotationalEquation": 22, "../equations/RotationalMotorEquation": 23, "../math/Vec3": 30, "./Constraint": 13, "./PointToPointConstraint": 17 }], 17: [function (e, t, i) { t.exports = r; var a = e("./Constraint"), o = e("../equations/ContactEquation"), s = e("../math/Vec3"); function r(e, t, i, r, n) { a.call(this, e, i), n = void 0 !== n ? n : 1e6, this.pivotA = t ? t.clone() : new s, this.pivotB = r ? r.clone() : new s, t = this.equationX = new o(e, i), r = this.equationY = new o(e, i), e = this.equationZ = new o(e, i), this.equations.push(t, r, e), t.minForce = r.minForce = e.minForce = -n, t.maxForce = r.maxForce = e.maxForce = n, t.ni.set(1, 0, 0), r.ni.set(0, 1, 0), e.ni.set(0, 0, 1) } (r.prototype = new a).update = function () { var e = this.bodyA, t = this.bodyB, i = this.equationX, r = this.equationY, n = this.equationZ; e.quaternion.vmult(this.pivotA, i.ri), t.quaternion.vmult(this.pivotB, i.rj), r.ri.copy(i.ri), r.rj.copy(i.rj), n.ri.copy(i.ri), n.rj.copy(i.rj) } }, { "../equations/ContactEquation": 19, "../math/Vec3": 30, "./Constraint": 13 }], 18: [function (e, t, i) { t.exports = r; var n = e("../math/Vec3"), a = (e("../math/Mat3"), e("./Equation")); function r(e, t, i) { var r = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6; a.call(this, e, t, -r, r), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.angle = void 0 !== i.angle ? i.angle : 0 } (r.prototype = new a).constructor = r; var c = new n, h = new n; r.prototype.computeB = function (e) { var t = this.a, i = this.b, r = this.axisA, n = this.axisB, a = c, o = h, s = this.jacobianElementA, l = this.jacobianElementB; return r.cross(n, a), n.cross(r, o), s.rotational.copy(o), l.rotational.copy(a), -(Math.cos(this.angle) - r.dot(n)) * t - this.computeGW() * i - e * this.computeGiMf() } }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 19: [function (e, t, i) { t.exports = a; var r = e("./Equation"), n = e("../math/Vec3"); function a(e, t, i) { r.call(this, e, t, 0, i = void 0 !== i ? i : 1e6), this.restitution = 0, this.ri = new n, this.rj = new n, this.ni = new n } e("../math/Mat3"), (a.prototype = new r).constructor = a; var g = new n, x = new n, y = new n, o = (a.prototype.computeB = function (e) { var t = this.a, i = this.b, r = this.bi, n = this.bj, a = this.ri, o = this.rj, s = g, l = x, c = r.velocity, h = r.angularVelocity, u = (r.force, r.torque, n.velocity), d = n.angularVelocity, p = (n.force, n.torque, y), f = this.jacobianElementA, m = this.jacobianElementB, v = this.ni; return a.cross(v, s), o.cross(v, l), v.negate(f.spatial), s.negate(f.rotational), m.spatial.copy(v), m.rotational.copy(l), p.copy(n.position), p.vadd(o, p), p.vsub(r.position, p), p.vsub(a, p), -v.dot(p) * t - ((m = this.restitution + 1) * u.dot(v) - m * c.dot(v) + d.dot(l) - h.dot(s)) * i - e * this.computeGiMf() }, new n), s = new n, l = new n, c = new n, h = new n; a.prototype.getImpactVelocityAlongNormal = function () { var e = o, t = s, i = l, r = c, n = h; return this.bi.position.vadd(this.ri, i), this.bj.position.vadd(this.rj, r), this.bi.getVelocityAtWorldPoint(i, e), this.bj.getVelocityAtWorldPoint(r, t), e.vsub(t, n), this.ni.dot(n) } }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 20: [function (e, t, i) { t.exports = a; var n = e("../math/JacobianElement"), t = e("../math/Vec3"); function a(e, t, i, r) { this.id = a.id++, this.minForce = void 0 === i ? -1e6 : i, this.maxForce = void 0 === r ? 1e6 : r, this.bi = e, this.bj = t, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new n, this.jacobianElementB = new n, this.enabled = !0, this.setSpookParams(1e7, 4, 1 / 60) } (a.prototype.constructor = a).id = 0, a.prototype.setSpookParams = function (e, t, i) { this.a = 4 / (i * (1 + 4 * t)), this.b = 4 * t / (1 + 4 * t), this.eps = 4 / (i * i * e * (1 + 4 * t)) }, a.prototype.computeB = function (e, t, i) { var r = this.computeGW(); return -this.computeGq() * e - r * t - this.computeGiMf() * i }, a.prototype.computeGq = function () { var e = this.jacobianElementA, t = this.jacobianElementB, i = this.bi, r = this.bj, i = i.position, r = r.position; return e.spatial.dot(i) + t.spatial.dot(r) }; var o = new t, h = (a.prototype.computeGW = function () { var e = this.jacobianElementA, t = this.jacobianElementB, i = this.bi, r = this.bj, n = i.velocity, a = r.velocity, i = i.angularVelocity || o, r = r.angularVelocity || o; return e.multiplyVectors(n, i) + t.multiplyVectors(a, r) }, a.prototype.computeGWlambda = function () { var e = this.jacobianElementA, t = this.jacobianElementB, i = this.bi, r = this.bj, n = i.vlambda, a = r.vlambda, i = i.wlambda || o, r = r.wlambda || o; return e.multiplyVectors(n, i) + t.multiplyVectors(a, r) }, new t), u = new t, d = new t, p = new t, s = (a.prototype.computeGiMf = function () { var e = this.jacobianElementA, t = this.jacobianElementB, i = this.bi, r = this.bj, n = i.force, a = i.torque, o = r.force, s = r.torque, l = i.invMassSolve, c = r.invMassSolve; return i.invInertiaWorldSolve ? i.invInertiaWorldSolve.vmult(a, d) : d.set(0, 0, 0), r.invInertiaWorldSolve ? r.invInertiaWorldSolve.vmult(s, p) : p.set(0, 0, 0), n.mult(l, h), o.mult(c, u), e.multiplyVectors(h, d) + t.multiplyVectors(u, p) }, new t), l = (a.prototype.computeGiMGt = function () { var e = this.jacobianElementA, t = this.jacobianElementB, i = this.bi, r = this.bj, n = i.invMassSolve, a = r.invMassSolve, i = i.invInertiaWorldSolve, r = r.invInertiaWorldSolve, n = n + a; return i && (i.vmult(e.rotational, s), n += s.dot(e.rotational)), r && (r.vmult(t.rotational, s), n += s.dot(t.rotational)), n }, new t); new t, new t, new t, new t, new t, a.prototype.addToWlambda = function (e) { var t = this.jacobianElementA, i = this.jacobianElementB, r = this.bi, n = this.bj, a = l; t.spatial.mult(r.invMassSolve * e, a), r.vlambda.vadd(a, r.vlambda), i.spatial.mult(n.invMassSolve * e, a), n.vlambda.vadd(a, n.vlambda), r.invInertiaWorldSolve && (r.invInertiaWorldSolve.vmult(t.rotational, a), a.mult(e, a), r.wlambda.vadd(a, r.wlambda)), n.invInertiaWorldSolve && (n.invInertiaWorldSolve.vmult(i.rotational, a), a.mult(e, a), n.wlambda.vadd(a, n.wlambda)) }, a.prototype.computeC = function () { return this.computeGiMGt() + this.eps } }, { "../math/JacobianElement": 26, "../math/Vec3": 30 }], 21: [function (e, t, i) { t.exports = a; var r = e("./Equation"), n = e("../math/Vec3"); function a(e, t, i) { r.call(this, e, t, -i, i), this.ri = new n, this.rj = new n, this.t = new n } e("../math/Mat3"), (a.prototype = new r).constructor = a; var s = new n, l = new n; a.prototype.computeB = function (e) { this.a; var t = this.b, i = (this.bi, this.bj, this.ri), r = this.rj, n = s, a = l, o = this.t, i = (i.cross(o, n), r.cross(o, a), this.jacobianElementA), r = this.jacobianElementB; return o.negate(i.spatial), n.negate(i.rotational), r.spatial.copy(o), r.rotational.copy(a), -this.computeGW() * t - e * this.computeGiMf() } }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 22: [function (e, t, i) { t.exports = r; var n = e("../math/Vec3"), a = (e("../math/Mat3"), e("./Equation")); function r(e, t, i) { var r = void 0 !== (i = i || {}).maxForce ? i.maxForce : 1e6; a.call(this, e, t, -r, r), this.axisA = i.axisA ? i.axisA.clone() : new n(1, 0, 0), this.axisB = i.axisB ? i.axisB.clone() : new n(0, 1, 0), this.maxAngle = Math.PI / 2 } (r.prototype = new a).constructor = r; var c = new n, h = new n; r.prototype.computeB = function (e) { var t = this.a, i = this.b, r = this.axisA, n = this.axisB, a = c, o = h, s = this.jacobianElementA, l = this.jacobianElementB; return r.cross(n, a), n.cross(r, o), s.rotational.copy(o), l.rotational.copy(a), -(Math.cos(this.maxAngle) - r.dot(n)) * t - this.computeGW() * i - e * this.computeGiMf() } }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 23: [function (e, t, i) { t.exports = a; var r = e("../math/Vec3"), n = (e("../math/Mat3"), e("./Equation")); function a(e, t, i) { n.call(this, e, t, -(i = void 0 !== i ? i : 1e6), i), this.axisA = new r, this.axisB = new r, this.targetVelocity = 0 } ((a.prototype = new n).constructor = a).prototype.computeB = function (e) { this.a; var t = this.b, i = (this.bi, this.bj, this.axisA), r = this.axisB, n = this.jacobianElementA, a = this.jacobianElementB; return n.rotational.copy(i), r.negate(a.rotational), -(this.computeGW() - this.targetVelocity) * t - e * this.computeGiMf() } }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 24: [function (e, t, i) { var r = e("../utils/Utils"); function n(e, t, i) { i = r.defaults(i, { friction: .3, restitution: .3, contactEquationStiffness: 1e7, contactEquationRelaxation: 3, frictionEquationStiffness: 1e7, frictionEquationRelaxation: 3 }), this.id = n.idCounter++, this.materials = [e, t], this.friction = i.friction, this.restitution = i.restitution, this.contactEquationStiffness = i.contactEquationStiffness, this.contactEquationRelaxation = i.contactEquationRelaxation, this.frictionEquationStiffness = i.frictionEquationStiffness, this.frictionEquationRelaxation = i.frictionEquationRelaxation } (t.exports = n).idCounter = 0 }, { "../utils/Utils": 53 }], 25: [function (e, t, i) { function r(e) { var t = ""; "string" == typeof (e = e || {}) ? (t = e, e = {}) : "object" == typeof e && (t = ""), this.name = t, this.id = r.idCounter++, this.friction = void 0 !== e.friction ? e.friction : -1, this.restitution = void 0 !== e.restitution ? e.restitution : -1 } (t.exports = r).idCounter = 0 }, {}], 26: [function (e, t, i) { t.exports = n; var r = e("./Vec3"); function n() { this.spatial = new r, this.rotational = new r } n.prototype.multiplyElement = function (e) { return e.spatial.dot(this.spatial) + e.rotational.dot(this.rotational) }, n.prototype.multiplyVectors = function (e, t) { return e.dot(this.spatial) + t.dot(this.rotational) } }, { "./Vec3": 30 }], 27: [function (e, t, i) { t.exports = c; var h = e("./Vec3"); function c(e) { this.elements = e || [0, 0, 0, 0, 0, 0, 0, 0, 0] } c.prototype.identity = function () { var e = this.elements; e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1 }, c.prototype.setZero = function () { var e = this.elements; e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 0 }, c.prototype.setTrace = function (e) { var t = this.elements; t[0] = e.x, t[4] = e.y, t[8] = e.z }, c.prototype.getTrace = function (e) { var e = e || new h, t = this.elements; e.x = t[0], e.y = t[4], e.z = t[8] }, c.prototype.vmult = function (e, t) { t = t || new h; var i = this.elements, r = e.x, n = e.y, e = e.z; return t.x = i[0] * r + i[1] * n + i[2] * e, t.y = i[3] * r + i[4] * n + i[5] * e, t.z = i[6] * r + i[7] * n + i[8] * e, t }, c.prototype.smult = function (e) { for (var t = 0; t < this.elements.length; t++)this.elements[t] *= e }, c.prototype.mmult = function (e, t) { for (var i = t || new c, r = 0; r < 3; r++)for (var n = 0; n < 3; n++) { for (var a = 0, o = 0; o < 3; o++)a += e.elements[r + 3 * o] * this.elements[o + 3 * n]; i.elements[r + 3 * n] = a } return i }, c.prototype.scale = function (e, t) { t = t || new c; for (var i = this.elements, r = t.elements, n = 0; 3 !== n; n++)r[3 * n + 0] = e.x * i[3 * n + 0], r[3 * n + 1] = e.y * i[3 * n + 1], r[3 * n + 2] = e.z * i[3 * n + 2]; return t }, c.prototype.solve = function (e, t) { t = t || new h; for (var i, r = [], n = 0; n < 12; n++)r.push(0); for (n = 0; n < 3; n++)for (i = 0; i < 3; i++)r[n + 4 * i] = this.elements[n + 3 * i]; r[3] = e.x, r[7] = e.y, r[11] = e.z; var a, o = 3, s = o; do { if (0 === r[(n = s - o) + 4 * n]) for (i = n + 1; i < s; i++)if (0 !== r[n + 4 * i]) { for (c = 4; r[(a = 4 - c) + 4 * n] += r[a + 4 * i], --c;); break } if (0 !== r[n + 4 * n]) for (i = n + 1; i < s; i++)for (var l = r[n + 4 * i] / r[n + 4 * n], c = 4; r[(a = 4 - c) + 4 * i] = a <= n ? 0 : r[a + 4 * i] - r[a + 4 * n] * l, --c;); } while (--o); if (t.z = r[11] / r[10], t.y = (r[7] - r[6] * t.z) / r[5], t.x = (r[3] - r[2] * t.z - r[1] * t.y) / r[0], isNaN(t.x) || isNaN(t.y) || isNaN(t.z) || t.x === 1 / 0 || t.y === 1 / 0 || t.z === 1 / 0) throw "Could not solve equation! Got x=[" + t.toString() + "], b=[" + e.toString() + "], A=[" + this.toString() + "]"; return t }, c.prototype.e = function (e, t, i) { if (void 0 === i) return this.elements[t + 3 * e]; this.elements[t + 3 * e] = i }, c.prototype.copy = function (e) { for (var t = 0; t < e.elements.length; t++)this.elements[t] = e.elements[t]; return this }, c.prototype.toString = function () { for (var e = "", t = 0; t < 9; t++)e += this.elements[t] + ","; return e }, c.prototype.reverse = function (e) { e = e || new c; for (var t, i = [], r = 0; r < 18; r++)i.push(0); for (r = 0; r < 3; r++)for (t = 0; t < 3; t++)i[r + 6 * t] = this.elements[r + 3 * t]; i[3] = 1, i[9] = 0, i[15] = 0, i[4] = 0, i[10] = 1, i[16] = 0, i[5] = 0, i[11] = 0, i[17] = 1; var n, a = 3, o = a; do { if (0 === i[(r = o - a) + 6 * r]) for (t = r + 1; t < o; t++)if (0 !== i[r + 6 * t]) { for (l = 6; i[(n = 6 - l) + 6 * r] += i[n + 6 * t], --l;); break } if (0 !== i[r + 6 * r]) for (t = r + 1; t < o; t++)for (var s = i[r + 6 * t] / i[r + 6 * r], l = 6; i[(n = 6 - l) + 6 * t] = n <= r ? 0 : i[n + 6 * t] - i[n + 6 * r] * s, --l;); } while (--a); r = 2; do { t = r - 1; do { for (s = i[r + 6 * t] / i[r + 6 * r], l = 6; i[(n = 6 - l) + 6 * t] = i[n + 6 * t] - i[n + 6 * r] * s, --l;); } while (t--) } while (--r); r = 2; do { for (s = 1 / i[r + 6 * r], l = 6; i[(n = 6 - l) + 6 * r] = i[n + 6 * r] * s, --l;); } while (r--); r = 2; do { t = 2; do { if (n = i[3 + t + 6 * r], isNaN(n) || n === 1 / 0) throw "Could not reverse! A=[" + this.toString() + "]" } while (e.e(r, t, n), t--) } while (r--); return e }, c.prototype.setRotationFromQuaternion = function (e) { var t = e.x, i = e.y, r = (s = e.z) + s, n = t * (l = t + t), a = t * (c = i + i), t = t * r, o = i * c, i = i * r, s = s * r, l = (e = e.w) * l, c = e * c, e = e * r; return (r = this.elements)[0] = 1 - (o + s), r[1] = a - e, r[2] = t + c, r[3] = a + e, r[4] = 1 - (n + s), r[5] = i - l, r[6] = t - c, r[7] = i + l, r[8] = 1 - (n + o), this }, c.prototype.transpose = function (e) { for (var t = (e = e || new c).elements, i = this.elements, r = 0; 3 !== r; r++)for (var n = 0; 3 !== n; n++)t[3 * r + n] = i[3 * n + r]; return e } }, { "./Vec3": 30 }], 28: [function (e, t, i) { t.exports = o; var u = e("./Vec3"); function o(e, t, i, r) { this.x = void 0 !== e ? e : 0, this.y = void 0 !== t ? t : 0, this.z = void 0 !== i ? i : 0, this.w = void 0 !== r ? r : 1 } o.prototype.set = function (e, t, i, r) { this.x = e, this.y = t, this.z = i, this.w = r }, o.prototype.toString = function () { return this.x + "," + this.y + "," + this.z + "," + this.w }, o.prototype.toArray = function () { return [this.x, this.y, this.z, this.w] }, o.prototype.setFromAxisAngle = function (e, t) { var i = Math.sin(.5 * t); this.x = e.x * i, this.y = e.y * i, this.z = e.z * i, this.w = Math.cos(.5 * t) }, o.prototype.toAxisAngle = function (e) { e = e || new u, this.normalize(); var t = 2 * Math.acos(this.w), i = Math.sqrt(1 - this.w * this.w); return i < .001 ? (e.x = this.x, e.y = this.y, e.z = this.z) : (e.x = this.x / i, e.y = this.y / i, e.z = this.z / i), [e, t] }; var r = new u, n = new u, s = (o.prototype.setFromVectors = function (e, t) { var i; e.isAntiparallelTo(t) ? (e.tangents(i = r, n), this.setFromAxisAngle(i, Math.PI)) : (i = e.cross(t), this.x = i.x, this.y = i.y, this.z = i.z, this.w = Math.sqrt(Math.pow(e.norm(), 2) * Math.pow(t.norm(), 2)) + e.dot(t), this.normalize()) }, new u), l = new u, c = new u; o.prototype.mult = function (e, t) { t = t || new o; var i = this.w, r = s, n = l, a = c; return r.set(this.x, this.y, this.z), n.set(e.x, e.y, e.z), t.w = i * e.w - r.dot(n), r.cross(n, a), t.x = i * n.x + e.w * r.x + a.x, t.y = i * n.y + e.w * r.y + a.y, t.z = i * n.z + e.w * r.z + a.z, t }, o.prototype.inverse = function (e) { var t = this.x, i = this.y, r = this.z, n = this.w, t = (e = e || new o, this.conjugate(e), 1 / (t * t + i * i + r * r + n * n)); return e.x *= t, e.y *= t, e.z *= t, e.w *= t, e }, o.prototype.conjugate = function (e) { return (e = e || new o).x = -this.x, e.y = -this.y, e.z = -this.z, e.w = this.w, e }, o.prototype.normalize = function () { var e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w); 0 === e ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e = 1 / e, this.y *= e, this.z *= e, this.w *= e) }, o.prototype.normalizeFast = function () { var e = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2; 0 == e ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e, this.y *= e, this.z *= e, this.w *= e) }, o.prototype.vmult = function (e, t) { t = t || new u; var i = e.x, r = e.y, e = e.z, n = this.x, a = this.y, o = this.z, s = this.w, l = s * i + a * e - o * r, c = s * r + o * i - n * e, h = s * e + n * r - a * i; return t.x = l * s + (i = -n * i - a * r - o * e) * -n + c * -o - h * -a, t.y = c * s + i * -a + h * -n - l * -o, t.z = h * s + i * -o + l * -a - c * -n, t }, o.prototype.copy = function (e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this }, o.prototype.toEuler = function (e, t) { var i, r, n, a, o, s = this.x, l = this.y, c = this.z, h = this.w; if ("YZX" !== (t = t || "YZX")) throw new Error("Euler order " + t + " not supported yet."); .499 < (t = s * l + c * h) && (n = 2 * Math.atan2(s, h), a = Math.PI / 2, o = 0), t < -.499 && (n = -2 * Math.atan2(s, h), a = -Math.PI / 2, o = 0), isNaN(n) && (i = s * s, r = c * c, n = Math.atan2(2 * l * h - 2 * s * c, 1 - l * l * 2 - 2 * r), a = Math.asin(2 * t), o = Math.atan2(2 * s * h - 2 * l * c, 1 - 2 * i - 2 * r)), e.y = n, e.z = a, e.x = o }, o.prototype.setFromEuler = function (e, t, i, r) { r = r || "XYZ"; var n = Math.cos(e / 2), a = Math.cos(t / 2), o = Math.cos(i / 2), e = Math.sin(e / 2), t = Math.sin(t / 2), i = Math.sin(i / 2); return "XYZ" === r ? (this.x = e * a * o + n * t * i, this.y = n * t * o - e * a * i, this.z = n * a * i + e * t * o, this.w = n * a * o - e * t * i) : "YXZ" === r ? (this.x = e * a * o + n * t * i, this.y = n * t * o - e * a * i, this.z = n * a * i - e * t * o, this.w = n * a * o + e * t * i) : "ZXY" === r ? (this.x = e * a * o - n * t * i, this.y = n * t * o + e * a * i, this.z = n * a * i + e * t * o, this.w = n * a * o - e * t * i) : "ZYX" === r ? (this.x = e * a * o - n * t * i, this.y = n * t * o + e * a * i, this.z = n * a * i - e * t * o, this.w = n * a * o + e * t * i) : "YZX" === r ? (this.x = e * a * o + n * t * i, this.y = n * t * o + e * a * i, this.z = n * a * i - e * t * o, this.w = n * a * o - e * t * i) : "XZY" === r && (this.x = e * a * o - n * t * i, this.y = n * t * o - e * a * i, this.z = n * a * i + e * t * o, this.w = n * a * o + e * t * i), this }, o.prototype.clone = function () { return new o(this.x, this.y, this.z, this.w) } }, { "./Vec3": 30 }], 29: [function (e, t, i) { var n = e("./Vec3"), r = e("./Quaternion"); function a(e) { e = e || {}, this.position = new n, e.position && this.position.copy(e.position), this.quaternion = new r, e.quaternion && this.quaternion.copy(e.quaternion) } t.exports = a; var o = new r; a.pointToLocalFrame = function (e, t, i, r) { return r = r || new n, i.vsub(e, r), t.conjugate(o), o.vmult(r, r), r }, a.prototype.pointToLocal = function (e, t) { return a.pointToLocalFrame(this.position, this.quaternion, e, t) }, a.pointToWorldFrame = function (e, t, i, r) { return r = r || new n, t.vmult(i, r), r.vadd(e, r), r }, a.prototype.pointToWorld = function (e, t) { return a.pointToWorldFrame(this.position, this.quaternion, e, t) }, a.prototype.vectorToWorldFrame = function (e, t) { return t = t || new n, this.quaternion.vmult(e, t), t }, a.vectorToWorldFrame = function (e, t, i) { return e.vmult(t, i), i }, a.vectorToLocalFrame = function (e, t, i, r) { return r = r || new n, t.w *= -1, t.vmult(i, r), t.w *= -1, r } }, { "./Quaternion": 28, "./Vec3": 30 }], 30: [function (e, t, i) { t.exports = s; var r = e("./Mat3"); function s(e, t, i) { this.x = e || 0, this.y = t || 0, this.z = i || 0 } s.ZERO = new s(0, 0, 0), s.UNIT_X = new s(1, 0, 0), s.UNIT_Y = new s(0, 1, 0), s.UNIT_Z = new s(0, 0, 1), s.prototype.cross = function (e, t) { var i = e.x, r = e.y, e = e.z, n = this.x, a = this.y, o = this.z; return (t = t || new s).x = a * e - o * r, t.y = o * i - n * e, t.z = n * r - a * i, t }, s.prototype.set = function (e, t, i) { return this.x = e, this.y = t, this.z = i, this }, s.prototype.setZero = function () { this.x = this.y = this.z = 0 }, s.prototype.vadd = function (e, t) { if (!t) return new s(this.x + e.x, this.y + e.y, this.z + e.z); t.x = e.x + this.x, t.y = e.y + this.y, t.z = e.z + this.z }, s.prototype.vsub = function (e, t) { if (!t) return new s(this.x - e.x, this.y - e.y, this.z - e.z); t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z }, s.prototype.crossmat = function () { return new r([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]) }, s.prototype.normalize = function () { var e = this.x, t = this.y, i = this.z; return 0 < (e = Math.sqrt(e * e + t * t + i * i)) ? (this.x *= t = 1 / e, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), e }, s.prototype.unit = function (e) { e = e || new s; var t = this.x, i = this.y, r = this.z, n = Math.sqrt(t * t + i * i + r * r); return 0 < n ? (e.x = t * (n = 1 / n), e.y = i * n, e.z = r * n) : (e.x = 1, e.y = 0, e.z = 0), e }, s.prototype.length = s.prototype.norm = function () { var e = this.x, t = this.y, i = this.z; return Math.sqrt(e * e + t * t + i * i) }, s.prototype.lengthSquared = s.prototype.norm2 = function () { return this.dot(this) }, s.prototype.distanceTo = function (e) { var t = this.x, i = this.y, r = this.z, n = e.x, a = e.y, e = e.z; return Math.sqrt((n - t) * (n - t) + (a - i) * (a - i) + (e - r) * (e - r)) }, s.prototype.distanceSquared = function (e) { var t = this.x, i = this.y, r = this.z, n = e.x, a = e.y; return (n - t) * (n - t) + (a - i) * (a - i) + ((e = e.z) - r) * (e - r) }, s.prototype.scale = s.prototype.mult = function (e, t) { t = t || new s; var i = this.x, r = this.y, n = this.z; return t.x = e * i, t.y = e * r, t.z = e * n, t }, s.prototype.dot = function (e) { return this.x * e.x + this.y * e.y + this.z * e.z }, s.prototype.isZero = function () { return 0 === this.x && 0 === this.y && 0 === this.z }, s.prototype.negate = function (e) { return (e = e || new s).x = -this.x, e.y = -this.y, e.z = -this.z, e }; var n = new s, a = new s, o = (s.prototype.tangents = function (e, t) { var i, r = this.norm(); 0 < r ? ((i = n).set(this.x * (r = 1 / r), this.y * r, this.z * r), r = a, Math.abs(i.x) < .9 ? r.set(1, 0, 0) : r.set(0, 1, 0), i.cross(r, e), i.cross(e, t)) : (e.set(1, 0, 0), t.set(0, 1, 0)) }, s.prototype.toString = function () { return this.x + "," + this.y + "," + this.z }, s.prototype.toArray = function () { return [this.x, this.y, this.z] }, s.prototype.copy = function (e) { return this.x = e.x, this.y = e.y, this.z = e.z, this }, s.prototype.lerp = function (e, t, i) { var r = this.x, n = this.y, a = this.z; i.x = r + (e.x - r) * t, i.y = n + (e.y - n) * t, i.z = a + (e.z - a) * t }, s.prototype.almostEquals = function (e, t) { return void 0 === t && (t = 1e-6), !(Math.abs(this.x - e.x) > t || Math.abs(this.y - e.y) > t || Math.abs(this.z - e.z) > t) }, s.prototype.almostZero = function (e) { return void 0 === e && (e = 1e-6), !(Math.abs(this.x) > e || Math.abs(this.y) > e || Math.abs(this.z) > e) }, new s); s.prototype.isAntiparallelTo = function (e, t) { return this.negate(o), o.almostEquals(e, t) }, s.prototype.clone = function () { return new s(this.x, this.y, this.z) } }, { "./Mat3": 27 }], 31: [function (e, t, i) { t.exports = c; var r = e("../utils/EventTarget"), a = (e("../shapes/Shape"), e("../math/Vec3")), n = e("../math/Mat3"), o = e("../math/Quaternion"), s = (e("../material/Material"), e("../collision/AABB")), l = e("../shapes/Box"); function c(e) { e = e || {}, r.apply(this), this.id = c.idCounter++, this.world = null, this.preStep = null, this.postStep = null, this.vlambda = new a, this.collisionFilterGroup = "number" == typeof e.collisionFilterGroup ? e.collisionFilterGroup : 1, this.collisionFilterMask = "number" == typeof e.collisionFilterMask ? e.collisionFilterMask : 1, this.collisionResponse = !0, this.position = new a, e.position && this.position.copy(e.position), this.previousPosition = new a, this.initPosition = new a, this.velocity = new a, e.velocity && this.velocity.copy(e.velocity), this.initVelocity = new a, this.force = new a; var t = "number" == typeof e.mass ? e.mass : 0; this.mass = t, this.invMass = 0 < t ? 1 / t : 0, this.material = e.material || null, this.linearDamping = "number" == typeof e.linearDamping ? e.linearDamping : .01, this.type = t <= 0 ? c.STATIC : c.DYNAMIC, typeof e.type == typeof c.STATIC && (this.type = e.type), this.allowSleep = void 0 === e.allowSleep || e.allowSleep, this.sleepState = 0, this.sleepSpeedLimit = void 0 !== e.sleepSpeedLimit ? e.sleepSpeedLimit : .1, this.sleepTimeLimit = void 0 !== e.sleepTimeLimit ? e.sleepTimeLimit : 1, this.timeLastSleepy = 0, this._wakeUpAfterNarrowphase = !1, this.torque = new a, this.quaternion = new o, e.quaternion && this.quaternion.copy(e.quaternion), this.initQuaternion = new o, this.angularVelocity = new a, e.angularVelocity && this.angularVelocity.copy(e.angularVelocity), this.initAngularVelocity = new a, this.interpolatedPosition = new a, this.interpolatedQuaternion = new o, this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new a, this.invInertia = new a, this.invInertiaWorld = new n, this.invMassSolve = 0, this.invInertiaSolve = new a, this.invInertiaWorldSolve = new n, this.fixedRotation = void 0 !== e.fixedRotation && e.fixedRotation, this.angularDamping = void 0 !== e.angularDamping ? e.angularDamping : .01, this.aabb = new s, this.aabbNeedsUpdate = !0, this.wlambda = new a, e.shape && this.addShape(e.shape), this.updateMassProperties() } ((c.prototype = new r).constructor = c).DYNAMIC = 1, c.STATIC = 2, c.KINEMATIC = 4, c.AWAKE = 0, c.SLEEPY = 1, c.SLEEPING = 2, c.idCounter = 0, c.prototype.wakeUp = function () { var e = this.sleepState; this.sleepState = 0, e === c.SLEEPING && this.dispatchEvent({ type: "wakeup" }) }, c.prototype.sleep = function () { this.sleepState = c.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0) }, c.sleepyEvent = { type: "sleepy" }, c.sleepEvent = { type: "sleep" }, c.prototype.sleepTick = function (e) { var t, i, r; this.allowSleep && (t = this.sleepState, i = this.velocity.norm2() + this.angularVelocity.norm2(), r = Math.pow(this.sleepSpeedLimit, 2), t === c.AWAKE && i < r ? (this.sleepState = c.SLEEPY, this.timeLastSleepy = e, this.dispatchEvent(c.sleepyEvent)) : t === c.SLEEPY && r < i ? this.wakeUp() : t === c.SLEEPY && e - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(c.sleepEvent))) }, c.prototype.updateSolveMassProperties = function () { this.sleepState === c.SLEEPING || this.type === c.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld)) }, c.prototype.pointToLocalFrame = function (e, t) { return t = t || new a, e.vsub(this.position, t), this.quaternion.conjugate().vmult(t, t), t }, c.prototype.vectorToLocalFrame = function (e, t) { return t = t || new a, this.quaternion.conjugate().vmult(e, t), t }, c.prototype.pointToWorldFrame = function (e, t) { return t = t || new a, this.quaternion.vmult(e, t), t.vadd(this.position, t), t }, c.prototype.vectorToWorldFrame = function (e, t) { return t = t || new a, this.quaternion.vmult(e, t), t }; var u = new a, d = new o, p = (c.prototype.addShape = function (e, t, i) { var r = new a, n = new o; return t && r.copy(t), i && n.copy(i), this.shapes.push(e), this.shapeOffsets.push(r), this.shapeOrientations.push(n), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0, this }, c.prototype.updateBoundingRadius = function () { for (var e = this.shapes, t = this.shapeOffsets, i = e.length, r = 0, n = 0; n !== i; n++) { var a = e[n], o = (a.updateBoundingSphereRadius(), t[n].norm()); r < o + (a = a.boundingSphereRadius) && (r = o + a) } this.boundingRadius = r }, new s), h = (c.prototype.computeAABB = function () { for (var e = this.shapes, t = this.shapeOffsets, i = this.shapeOrientations, r = e.length, n = u, a = d, o = this.quaternion, s = this.aabb, l = p, c = 0; c !== r; c++) { var h = e[c]; i[c].mult(o, a), a.vmult(t[c], n), n.vadd(this.position, n), h.calculateWorldAABB(n, a, l.lowerBound, l.upperBound), 0 === c ? s.copy(l) : s.extend(l) } this.aabbNeedsUpdate = !1 }, new n), f = new n, m = (new n, c.prototype.updateInertiaWorld = function (e) { var t, i = this.invInertia; i.x === i.y && i.y === i.z && !e || (e = f, (t = h).setRotationFromQuaternion(this.quaternion), t.transpose(e), t.scale(i, t), t.mmult(e, this.invInertiaWorld)) }, new a), v = new a, g = (c.prototype.applyForce = function (e, t) { this.type === c.DYNAMIC && (t.vsub(this.position, t = m), t.cross(e, t = v), this.force.vadd(e, this.force), this.torque.vadd(t, this.torque)) }, new a), x = new a, y = (c.prototype.applyLocalForce = function (e, t) { var i; this.type === c.DYNAMIC && (i = x, this.vectorToWorldFrame(e, e = g), this.pointToWorldFrame(t, i), this.applyForce(e, i)) }, new a), _ = new a, b = new a, w = (c.prototype.applyImpulse = function (e, t) { var i; this.type === c.DYNAMIC && (t.vsub(this.position, t = y), (i = _).copy(e), i.mult(this.invMass, i), this.velocity.vadd(i, this.velocity), t.cross(e, i = b), this.invInertiaWorld.vmult(i, i), this.angularVelocity.vadd(i, this.angularVelocity)) }, new a), E = new a, T = (c.prototype.applyLocalImpulse = function (e, t) { var i; this.type === c.DYNAMIC && (i = E, this.vectorToWorldFrame(e, e = w), this.pointToWorldFrame(t, i), this.applyImpulse(e, i)) }, new a); c.prototype.updateMassProperties = function () { var e = T, t = (this.invMass = 0 < this.mass ? 1 / this.mass : 0, this.inertia), i = this.fixedRotation; this.computeAABB(), e.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), l.calculateInertia(e, this.mass, t), this.invInertia.set(0 < t.x && !i ? 1 / t.x : 0, 0 < t.y && !i ? 1 / t.y : 0, 0 < t.z && !i ? 1 / t.z : 0), this.updateInertiaWorld(!0) }, c.prototype.getVelocityAtWorldPoint = function (e, t) { var i = new a; return e.vsub(this.position, i), this.angularVelocity.cross(i, t), this.velocity.vadd(t, t), t } }, { "../collision/AABB": 3, "../material/Material": 25, "../math/Mat3": 27, "../math/Quaternion": 28, "../math/Vec3": 30, "../shapes/Box": 37, "../shapes/Shape": 43, "../utils/EventTarget": 49 }], 32: [function (e, t, i) { e("./Body"); var R = e("../math/Vec3"), a = e("../math/Quaternion"), r = (e("../collision/RaycastResult"), e("../collision/Ray")), n = e("../objects/WheelInfo"); function o(e) { this.chassisBody = e.chassisBody, this.wheelInfos = [], this.sliding = !1, this.world = null, this.indexRightAxis = void 0 !== e.indexRightAxis ? e.indexRightAxis : 1, this.indexForwardAxis = void 0 !== e.indexForwardAxis ? e.indexForwardAxis : 0, this.indexUpAxis = void 0 !== e.indexUpAxis ? e.indexUpAxis : 2 } t.exports = o, new R, new R, new R; var s = new R, l = new R, c = new R, h = (new r, o.prototype.addWheel = function (e) { var e = new n(e = e || {}), t = this.wheelInfos.length; return this.wheelInfos.push(e), t }, o.prototype.setSteeringValue = function (e, t) { this.wheelInfos[t].steering = e }, new R, o.prototype.applyEngineForce = function (e, t) { this.wheelInfos[t].engineForce = e }, o.prototype.setBrake = function (e, t) { this.wheelInfos[t].brake = e }, o.prototype.addToWorld = function (e) { this.constraints, e.add(this.chassisBody); var t = this; this.preStepCallback = function () { t.updateVehicle(e.dt) }, e.addEventListener("preStep", this.preStepCallback), this.world = e }, o.prototype.getVehicleAxisWorld = function (e, t) { t.set(0 === e ? 1 : 0, 1 === e ? 1 : 0, 2 === e ? 1 : 0), this.chassisBody.vectorToWorldFrame(t, t) }, o.prototype.updateVehicle = function (e) { for (var t = this.wheelInfos, i = t.length, r = this.chassisBody, n = 0; n < i; n++)this.updateWheelTransform(n); this.currentVehicleSpeedKmHour = 3.6 * r.velocity.norm(); var a = new R; for (this.getVehicleAxisWorld(this.indexForwardAxis, a), a.dot(r.velocity) < 0 && (this.currentVehicleSpeedKmHour *= -1), n = 0; n < i; n++)this.castRay(t[n]); this.updateSuspension(e); for (var o = new R, s = new R, n = 0; n < i; n++) { var l = (p = t[n]).suspensionForce; l > p.maxSuspensionForce && (l = p.maxSuspensionForce), p.raycastResult.hitNormalWorld.scale(l * e, o), p.raycastResult.hitPointWorld.vsub(r.position, s), r.applyImpulse(o, p.raycastResult.hitPointWorld) } this.updateFriction(e); var c = new R, h = new R, u = new R; for (n = 0; n < i; n++) { var d, p = t[n], f = (r.getVelocityAtWorldPoint(p.chassisConnectionPointWorld, u), 1); 1 === this.indexUpAxis && (f = -1), p.isInContact && (this.getVehicleAxisWorld(this.indexForwardAxis, h), d = h.dot(p.raycastResult.hitNormalWorld), p.raycastResult.hitNormalWorld.scale(d, c), h.vsub(c, h), d = h.dot(u), p.deltaRotation = f * d * e / p.radius), !p.sliding && p.isInContact || 0 === p.engineForce || !p.useCustomSlidingRotationalSpeed || (p.deltaRotation = (0 < p.engineForce ? 1 : -1) * p.customSlidingRotationalSpeed * e), Math.abs(p.brake) > Math.abs(p.engineForce) && (p.deltaRotation = 0), p.rotation += p.deltaRotation, p.deltaRotation *= .99 } }, o.prototype.updateSuspension = function (e) { for (var t = this.chassisBody.mass, i = this.wheelInfos, r = i.length, n = 0; n < r; n++) { var a, o, s = i[n]; s.isInContact ? (a = s.suspensionRestLength, o = s.suspensionLength, a = s.suspensionStiffness * (a - o) * s.clippedInvContactDotSuspension, a -= ((o = s.suspensionRelativeVelocity) < 0 ? s.dampingCompression : s.dampingRelaxation) * o, s.suspensionForce = a * t, s.suspensionForce < 0 && (s.suspensionForce = 0)) : s.suspensionForce = 0 } }, o.prototype.removeFromWorld = function (e) { this.constraints, e.remove(this.chassisBody), e.removeEventListener("preStep", this.preStepCallback), this.world = null }, new R), u = new R, L = (o.prototype.castRay = function (e) { var t = h, i = u, r = (this.updateWheelTransformWorld(e), this.chassisBody), n = -1, a = e.suspensionRestLength + e.radius, o = (e.directionWorld.scale(a, t), (a = e.chassisConnectionPointWorld).vadd(t, i), (t = e.raycastResult).reset(), r.collisionResponse), a = (r.collisionResponse = !1, this.world.rayTest(a, i, t), r.collisionResponse = o, t.body); return e.raycastResult.groundObject = 0, a ? (n = t.distance, e.raycastResult.hitNormalWorld = t.hitNormalWorld, e.isInContact = !0, i = t.distance, e.suspensionLength = i - e.radius, o = e.suspensionRestLength - e.maxSuspensionTravel, a = e.suspensionRestLength + e.maxSuspensionTravel, e.suspensionLength < o && (e.suspensionLength = o), e.suspensionLength > a && (e.suspensionLength = a, e.raycastResult.reset()), t = e.raycastResult.hitNormalWorld.dot(e.directionWorld), i = new R, r.getVelocityAtWorldPoint(e.raycastResult.hitPointWorld, i), o = e.raycastResult.hitNormalWorld.dot(i), -.1 <= t ? (e.suspensionRelativeVelocity = 0, e.clippedInvContactDotSuspension = 10) : (e.suspensionRelativeVelocity = o * (a = -1 / t), e.clippedInvContactDotSuspension = a)) : (e.suspensionLength = e.suspensionRestLength + 0 * e.maxSuspensionTravel, e.suspensionRelativeVelocity = 0, e.directionWorld.scale(-1, e.raycastResult.hitNormalWorld), e.clippedInvContactDotSuspension = 1), n }, o.prototype.updateWheelTransformWorld = function (e) { e.isInContact = !1; var t = this.chassisBody; t.pointToWorldFrame(e.chassisConnectionPointLocal, e.chassisConnectionPointWorld), t.vectorToWorldFrame(e.directionLocal, e.directionWorld), t.vectorToWorldFrame(e.axleLocal, e.axleWorld) }, o.prototype.updateWheelTransform = function (e) { var t = s, i = l, r = c, e = this.wheelInfos[e], r = (this.updateWheelTransformWorld(e), e.directionLocal.scale(-1, t), i.copy(e.axleLocal), t.cross(i, r), r.normalize(), i.normalize(), e.steering), n = new a; n.setFromAxisAngle(t, r), (t = new a).setFromAxisAngle(i, e.rotation), r = e.worldTransform.quaternion, this.chassisBody.quaternion.mult(n, r), r.mult(t, r), r.normalize(), (i = e.worldTransform.position).copy(e.directionWorld), i.scale(e.suspensionLength, i), i.vadd(e.chassisConnectionPointWorld, i) }, [new R(1, 0, 0), new R(0, 1, 0), new R(0, 0, 1)]), P = (o.prototype.getWheelTransformWorld = function (e) { return this.wheelInfos[e].worldTransform }, new R), C = [], F = [], D = (o.prototype.updateFriction = function (e) { for (var t = P, i = this.wheelInfos, r = i.length, n = this.chassisBody, a = F, o = C, s = 0; s < r; s++)w = (M = i[s]).raycastResult.body, M.sideImpulse = 0, M.forwardImpulse = 0, a[s] || (a[s] = new R), o[s] || (o[s] = new R); for (var l, c, h, u, d, p, f, m, v, g, x, s = 0; s < r; s++)(w = (M = i[s]).raycastResult.body) && (l = o[s], this.getWheelTransformWorld(s).vectorToWorldFrame(L[this.indexRightAxis], l), c = M.raycastResult.hitNormalWorld, h = l.dot(c), c.scale(h, t), l.vsub(t, l), l.normalize(), c.cross(l, a[s]), a[s].normalize(), M.sideImpulse = function (e, t, i, r, n) { if (1.1 < n.norm2()) return 0; var a = B, o = U, s = z; return e.getVelocityAtWorldPoint(t, a), i.getVelocityAtWorldPoint(r, o), a.vsub(o, s), -.2 * n.dot(s) * (1 / (e.invMass + i.invMass)) }(n, M.raycastResult.hitPointWorld, w, M.raycastResult.hitPointWorld, l), M.sideImpulse *= 1); for (this.sliding = !1, s = 0; s < r; s++) { var y, _, b, w = (M = i[s]).raycastResult.body, E = 0; M.slipInfo = 1, w && (b = M.brake || 0, d = w, p = M.raycastResult.hitPointWorld, f = a[s], m = b, _ = y = g = v = void 0, v = 0, y = I, _ = N, (u = n).getVelocityAtWorldPoint(x = p, g = D), d.getVelocityAtWorldPoint(x, y), g.vsub(y, _), x = f.dot(_), E = v = (v = m < (v = 1 / ((g = H(u, p, f)) + H(d, p, f)) * -x) ? m : v) < -m ? -m : v, b /= E += M.engineForce * e, M.slipInfo *= b), M.forwardImpulse = 0, M.skidInfo = 1, w && (M.skidInfo = 1, _ = (y = M.suspensionForce * e * M.frictionSlip) * y, M.forwardImpulse = E, E = (E = .5 * M.forwardImpulse) * E + (E = +M.sideImpulse) * E, M.sliding = !1, _ < E && (this.sliding = !0, M.sliding = !0, b = y / Math.sqrt(E), M.skidInfo *= b)) } if (this.sliding) for (s = 0; s < r; s++)0 !== (M = i[s]).sideImpulse && M.skidInfo < 1 && (M.forwardImpulse *= M.skidInfo, M.sideImpulse *= M.skidInfo); for (s = 0; s < r; s++) { var T, S, M = i[s], A = new R; A.copy(M.raycastResult.hitPointWorld), 0 !== M.forwardImpulse && (T = new R, a[s].scale(M.forwardImpulse, T), n.applyImpulse(T, A)), 0 !== M.sideImpulse && (w = M.raycastResult.body, (T = new R).copy(M.raycastResult.hitPointWorld), S = new R, o[s].scale(M.sideImpulse, S), n.pointToLocalFrame(A, A), A["xyz"[this.indexUpAxis]] *= M.rollInfluence, n.pointToWorldFrame(A, A), n.applyImpulse(S, A), S.scale(-1, S), w.applyImpulse(S, T)) } }, new R), I = new R, N = new R, d = new R, p = new R, f = new R, m = new R; function H(e, t, i) { var r = d, n = p, a = f, o = m; return t.vsub(e.position, r), r.cross(i, n), e.invInertiaWorld.vmult(n, o), o.cross(r, a), e.invMass + i.dot(a) } var B = new R, U = new R, z = new R }, { "../collision/Ray": 9, "../collision/RaycastResult": 10, "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/WheelInfo": 36, "./Body": 31 }], 33: [function (e, t, i) { var n = e("./Body"), a = e("../shapes/Sphere"), r = e("../shapes/Box"), o = e("../math/Vec3"), s = e("../constraints/HingeConstraint"); function l(e) { this.wheelBodies = [], this.coordinateSystem = void 0 === e.coordinateSystem ? new o(1, 2, 3) : e.coordinateSystem.clone(), this.chassisBody = e.chassisBody, this.chassisBody || (e = new r(new o(5, 2, .5)), this.chassisBody = new n(1, e)), this.constraints = [], this.wheelAxes = [], this.wheelForces = [] } (t.exports = l).prototype.addWheel = function (e) { var t = (t = (e = e || {}).body) || new n(1, new a(1.2)), i = (this.wheelBodies.push(t), this.wheelForces.push(0), new o, void 0 !== e.position ? e.position.clone() : new o), r = new o, r = (this.chassisBody.pointToWorldFrame(i, r), t.position.set(r.x, r.y, r.z), void 0 !== e.axis ? e.axis.clone() : new o(0, 1, 0)), e = (this.wheelAxes.push(r), new s(this.chassisBody, t, { pivotA: i, axisA: r, pivotB: o.ZERO, axisB: r, collideConnected: !1 })); return this.constraints.push(e), this.wheelBodies.length - 1 }, l.prototype.setSteeringValue = function (e, t) { var i = this.wheelAxes[t], r = Math.cos(e), e = Math.sin(e), n = i.x, i = i.y; this.constraints[t].axisA.set(r * n - e * i, e * n + r * i, 0) }, l.prototype.setMotorSpeed = function (e, t) { (t = this.constraints[t]).enableMotor(), t.motorTargetVelocity = e }, l.prototype.disableMotor = function (e) { this.constraints[e].disableMotor() }; var c = new o, h = (l.prototype.setWheelForce = function (e, t) { this.wheelForces[t] = e }, l.prototype.applyWheelForce = function (e, t) { var i = this.wheelAxes[t], r = (t = this.wheelBodies[t]).torque; i.scale(e, c), t.vectorToWorldFrame(c, c), r.vadd(c, r) }, l.prototype.addToWorld = function (e) { for (var t = this.constraints, i = this.wheelBodies.concat([this.chassisBody]), r = 0; r < i.length; r++)e.add(i[r]); for (r = 0; r < t.length; r++)e.addConstraint(t[r]); e.addEventListener("preStep", this._update.bind(this)) }, l.prototype._update = function () { for (var e = this.wheelForces, t = 0; t < e.length; t++)this.applyWheelForce(e[t], t) }, l.prototype.removeFromWorld = function (e) { for (var t = this.constraints, i = this.wheelBodies.concat([this.chassisBody]), r = 0; r < i.length; r++)e.remove(i[r]); for (r = 0; r < t.length; r++)e.removeConstraint(t[r]) }, new o); l.prototype.getWheelSpeed = function (e) { var t = this.wheelAxes[e], e = this.wheelBodies[e].angularVelocity; return this.chassisBody.vectorToWorldFrame(t, h), e.dot(h) } }, { "../constraints/HingeConstraint": 15, "../math/Vec3": 30, "../shapes/Box": 37, "../shapes/Sphere": 44, "./Body": 31 }], 34: [function (e, t, i) { function r() { this.particles = [], this.density = 1, this.smoothingRadius = 1, this.speedOfSound = 1, this.viscosity = .01, this.eps = 1e-6, this.pressures = [], this.densities = [], this.neighbors = [] } t.exports = r, e("../shapes/Shape"), t = e("../math/Vec3"), e("../math/Quaternion"), e("../shapes/Particle"), e("../objects/Body"), e("../material/Material"), r.prototype.add = function (e) { this.particles.push(e), this.neighbors.length < this.particles.length && this.neighbors.push([]) }, r.prototype.remove = function (e) { -1 !== (e = this.particles.indexOf(e)) && (this.particles.splice(e, 1), this.neighbors.length > this.particles.length && this.neighbors.pop()) }; var l = new t, _ = (r.prototype.getNeighbors = function (e, t) { for (var i = this.particles.length, r = e.id, n = this.smoothingRadius * this.smoothingRadius, a = l, o = 0; o !== i; o++) { var s = this.particles[o]; s.position.vsub(e.position, a), r !== s.id && a.norm2() < n && t.push(s) } }, new t), b = new t, w = new t, E = new t, T = new t, S = new t; r.prototype.update = function () { for (var e = this.particles.length, t = _, i = this.speedOfSound, r = this.eps, n = 0; n !== e; n++) { for (var a = this.particles[n], o = ((v = this.neighbors[n]).length = 0, this.getNeighbors(a, v), v.push(this.particles[n]), v.length), s = 0, l = 0; l !== o; l++) { a.position.vsub(v[l].position, t); var c = t.norm(), c = this.w(c); s += v[l].mass * c } this.densities[n] = s, this.pressures[n] = i * i * (this.densities[n] - this.density) } for (var h = b, u = w, d = E, p = T, f = S, n = 0; n !== e; n++) { var m = this.particles[n]; h.set(0, 0, 0), u.set(0, 0, 0); for (var v, o = (v = this.neighbors[n]).length, l = 0; l !== o; l++) { var g = v[l], x = (m.position.vsub(g.position, p), p.norm()), y = -g.mass * (this.pressures[n] / (this.densities[n] * this.densities[n] + r) + this.pressures[l] / (this.densities[l] * this.densities[l] + r)); this.gradw(p, d), d.mult(y, d), h.vadd(d, h), g.velocity.vsub(m.velocity, f), f.mult(1 / (1e-4 + this.densities[n] * this.densities[l]) * this.viscosity * g.mass, f), y = this.nablaw(x), f.mult(y, f), u.vadd(f, u) } u.mult(m.mass, u), h.mult(m.mass, h), m.force.vadd(u, m.force), m.force.vadd(h, m.force) } }, r.prototype.w = function (e) { var t = this.smoothingRadius; return 315 / (64 * Math.PI * Math.pow(t, 9)) * Math.pow(t * t - e * e, 3) }, r.prototype.gradw = function (e, t) { var i = e.norm(), r = this.smoothingRadius; e.mult(945 / (32 * Math.PI * Math.pow(r, 9)) * Math.pow(r * r - i * i, 2), t) }, r.prototype.nablaw = function (e) { var t = this.smoothingRadius; return 945 / (32 * Math.PI * Math.pow(t, 9)) * (t * t - e * e) * (7 * e * e - 3 * t * t) } }, { "../material/Material": 25, "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/Body": 31, "../shapes/Particle": 41, "../shapes/Shape": 43 }], 35: [function (e, t, i) { var r = e("../math/Vec3"); function n(e, t, i) { this.restLength = "number" == typeof (i = i || {}).restLength ? i.restLength : 1, this.stiffness = i.stiffness || 100, this.damping = i.damping || 1, this.bodyA = e, this.bodyB = t, this.localAnchorA = new r, this.localAnchorB = new r, i.localAnchorA && this.localAnchorA.copy(i.localAnchorA), i.localAnchorB && this.localAnchorB.copy(i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB) } (t.exports = n).prototype.setWorldAnchorA = function (e) { this.bodyA.pointToLocalFrame(e, this.localAnchorA) }, n.prototype.setWorldAnchorB = function (e) { this.bodyB.pointToLocalFrame(e, this.localAnchorB) }, n.prototype.getWorldAnchorA = function (e) { this.bodyA.pointToWorldFrame(this.localAnchorA, e) }, n.prototype.getWorldAnchorB = function (e) { this.bodyB.pointToWorldFrame(this.localAnchorB, e) }; var v = new r, g = new r, x = new r, y = new r, _ = new r, b = new r, w = new r, E = new r, T = new r, S = new r, M = new r; n.prototype.applyForce = function () { var e = this.stiffness, t = this.damping, i = this.restLength, r = this.bodyA, n = this.bodyB, a = v, o = g, s = x, l = y, c = M, h = _, u = b, d = w, p = E, f = T, m = S, u = (this.getWorldAnchorA(h), this.getWorldAnchorB(u), h.vsub(r.position, d), u.vsub(n.position, p), u.vsub(h, a), a.norm()); o.copy(a), o.normalize(), n.velocity.vsub(r.velocity, s), n.angularVelocity.cross(p, c), s.vadd(c, s), r.angularVelocity.cross(d, c), s.vsub(c, s), o.mult(-e * (u - i) - t * s.dot(o), l), r.force.vsub(l, r.force), n.force.vadd(l, n.force), d.cross(l, f), p.cross(l, m), r.torque.vsub(f, r.torque), n.torque.vadd(m, n.torque) } }, { "../math/Vec3": 30 }], 36: [function (e, t, i) { var r = e("../math/Vec3"), n = e("../math/Transform"), a = e("../collision/RaycastResult"), o = e("../utils/Utils"); function s(e) { e = o.defaults(e, { chassisConnectionPointLocal: new r, chassisConnectionPointWorld: new r, directionLocal: new r, directionWorld: new r, axleLocal: new r, axleWorld: new r, suspensionRestLength: 1, suspensionMaxLength: 2, radius: 1, suspensionStiffness: 100, dampingCompression: 10, dampingRelaxation: 10, frictionSlip: 1e4, steering: 0, rotation: 0, deltaRotation: 0, rollInfluence: .01, maxSuspensionForce: Number.MAX_VALUE, isFrontWheel: !0, clippedInvContactDotSuspension: 1, suspensionRelativeVelocity: 0, suspensionForce: 0, skidInfo: 0, suspensionLength: 0, maxSuspensionTravel: 1, useCustomSlidingRotationalSpeed: !1, customSlidingRotationalSpeed: -.1 }), this.maxSuspensionTravel = e.maxSuspensionTravel, this.customSlidingRotationalSpeed = e.customSlidingRotationalSpeed, this.useCustomSlidingRotationalSpeed = e.useCustomSlidingRotationalSpeed, this.sliding = !1, this.chassisConnectionPointLocal = e.chassisConnectionPointLocal.clone(), this.chassisConnectionPointWorld = e.chassisConnectionPointWorld.clone(), this.directionLocal = e.directionLocal.clone(), this.directionWorld = e.directionWorld.clone(), this.axleLocal = e.axleLocal.clone(), this.axleWorld = e.axleWorld.clone(), this.suspensionRestLength = e.suspensionRestLength, this.suspensionMaxLength = e.suspensionMaxLength, this.radius = e.radius, this.suspensionStiffness = e.suspensionStiffness, this.dampingCompression = e.dampingCompression, this.dampingRelaxation = e.dampingRelaxation, this.frictionSlip = e.frictionSlip, this.steering = 0, this.rotation = 0, this.deltaRotation = 0, this.rollInfluence = e.rollInfluence, this.maxSuspensionForce = e.maxSuspensionForce, this.engineForce = 0, this.brake = 0, this.isFrontWheel = e.isFrontWheel, this.clippedInvContactDotSuspension = 1, this.suspensionRelativeVelocity = 0, this.suspensionForce = 0, this.skidInfo = 0, this.suspensionLength = 0, this.sideImpulse = 0, this.forwardImpulse = 0, this.raycastResult = new a, this.worldTransform = new n, this.isInContact = !1 } t.exports = s, new r; var l = new r, c = new r; s.prototype.updateWheel = function (e) { var t, i = this.raycastResult; this.isInContact ? (t = i.hitNormalWorld.dot(i.directionWorld), i.hitPointWorld.vsub(e.position, l), e.getVelocityAtWorldPoint(l, c), e = i.hitNormalWorld.dot(c), -.1 <= t ? (this.suspensionRelativeVelocity = 0, this.clippedInvContactDotSuspension = 10) : (this.suspensionRelativeVelocity = e * (e = -1 / t), this.clippedInvContactDotSuspension = e)) : (i.suspensionLength = this.suspensionRestLength, this.suspensionRelativeVelocity = 0, i.directionWorld.scale(-1, i.hitNormalWorld), this.clippedInvContactDotSuspension = 1) } }, { "../collision/RaycastResult": 10, "../math/Transform": 29, "../math/Vec3": 30, "../utils/Utils": 53 }], 37: [function (e, t, i) { t.exports = o; var r = e("./Shape"), n = e("../math/Vec3"), a = e("./ConvexPolyhedron"); function o(e) { r.call(this), this.type = r.types.BOX, this.halfExtents = e, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius() } ((o.prototype = new r).constructor = o).prototype.updateConvexPolyhedronRepresentation = function () { var e = this.halfExtents.x, t = this.halfExtents.y, i = this.halfExtents.z, r = n, e = [new r(-e, -t, -i), new r(e, -t, -i), new r(e, t, -i), new r(-e, t, -i), new r(-e, -t, i), new r(e, -t, i), new r(e, t, i), new r(-e, t, i)], t = (new r(0, 0, 1), new r(0, 1, 0), new r(1, 0, 0), new a(e, [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]])); (this.convexPolyhedronRepresentation = t).material = this.material }, o.prototype.calculateLocalInertia = function (e, t) { return t = t || new n, o.calculateInertia(this.halfExtents, e, t), t }, o.calculateInertia = function (e, t, i) { i.x = 1 / 12 * t * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z), i.y = 1 / 12 * t * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z), i.z = 1 / 12 * t * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x) }, o.prototype.getSideNormals = function (e, t) { var i = e, e = this.halfExtents; if (i[0].set(e.x, 0, 0), i[1].set(0, e.y, 0), i[2].set(0, 0, e.z), i[3].set(-e.x, 0, 0), i[4].set(0, -e.y, 0), i[5].set(0, 0, -e.z), void 0 !== t) for (var r = 0; r !== i.length; r++)t.vmult(i[r], i[r]); return i }, o.prototype.volume = function () { return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z }, o.prototype.updateBoundingSphereRadius = function () { this.boundingSphereRadius = this.halfExtents.norm() }; var s = new n, h = (new n, o.prototype.forEachWorldCorner = function (e, t, i) { for (var r = this.halfExtents, n = [[r.x, r.y, r.z], [-r.x, r.y, r.z], [-r.x, -r.y, r.z], [-r.x, -r.y, -r.z], [r.x, -r.y, -r.z], [r.x, r.y, -r.z], [-r.x, r.y, -r.z], [r.x, -r.y, r.z]], a = 0; a < n.length; a++)s.set(n[a][0], n[a][1], n[a][2]), t.vmult(s, s), e.vadd(s, s), i(s.x, s.y, s.z) }, [new n, new n, new n, new n, new n, new n, new n, new n]); o.prototype.calculateWorldAABB = function (e, t, i, r) { var n = this.halfExtents, a = (h[0].set(n.x, n.y, n.z), h[1].set(-n.x, n.y, n.z), h[2].set(-n.x, -n.y, n.z), h[3].set(-n.x, -n.y, -n.z), h[4].set(n.x, -n.y, -n.z), h[5].set(n.x, n.y, -n.z), h[6].set(-n.x, n.y, -n.z), h[7].set(n.x, -n.y, n.z), h[0]); t.vmult(a, a), e.vadd(a, a), r.copy(a), i.copy(a); for (var o = 1; o < 8; o++) { var a = h[o], s = (t.vmult(a, a), e.vadd(a, a), a.x), l = a.y, c = a.z; s > r.x && (r.x = s), l > r.y && (r.y = l), c > r.z && (r.z = c), s < i.x && (i.x = s), l < i.y && (i.y = l), c < i.z && (i.z = c) } } }, { "../math/Vec3": 30, "./ConvexPolyhedron": 38, "./Shape": 43 }], 38: [function (e, t, i) { t.exports = o; var r = e("./Shape"), _ = e("../math/Vec3"), p = (e("../math/Quaternion"), e("../math/Transform")); function o(e, t, i) { r.call(this), this.type = r.types.CONVEXPOLYHEDRON, this.vertices = e || [], this.worldVertices = [], this.worldVerticesNeedsUpdate = !0, this.faces = t || [], this.faceNormals = [], this.computeNormals(), this.worldFaceNormalsNeedsUpdate = !0, this.worldFaceNormals = [], this.uniqueEdges = [], this.uniqueAxes = i ? i.slice() : null, this.computeEdges(), this.updateBoundingSphereRadius() } (o.prototype = new r).constructor = o; var h = new _, n = (o.prototype.computeEdges = function () { for (var e = this.faces, t = this.vertices, i = (t.length, this.uniqueEdges), r = (i.length = 0, h), n = 0; n !== e.length; n++)for (var a = e[n], o = a.length, s = 0; s !== o; s++) { t[a[s]].vsub(t[a[(s + 1) % o]], r), r.normalize(); for (var l = !1, c = 0; c !== i.length; c++)if (i[c].almostEquals(r) || i[c].almostEquals(r)) { l = !0; break } l || i.push(r.clone()) } }, o.prototype.computeNormals = function () { this.faceNormals.length = this.faces.length; for (var e = 0; e < this.faces.length; e++) { for (var t = 0; t < this.faces[e].length; t++)if (!this.vertices[this.faces[e][t]]) throw new Error("Vertex " + this.faces[e][t] + " not found!"); var i = this.faceNormals[e] || new _, r = (this.getFaceNormal(e, i), i.negate(i), this.faceNormals[e] = i, this.vertices[this.faces[e][0]]); if (i.dot(r) < 0) for (console.error(".faceNormals[" + e + "] = Vec3(" + i.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule."), t = 0; t < this.faces[e].length; t++)console.warn(".vertices[" + this.faces[e][t] + "] = Vec3(" + this.vertices[this.faces[e][t]].toString() + ")") } }, new _), a = new _, b = (o.computeNormal = function (e, t, i, r) { t.vsub(e, a), i.vsub(t, n), n.cross(a, r), r.isZero() || r.normalize() }, o.prototype.getFaceNormal = function (e, t) { var e = this.faces[e], i = this.vertices[e[0]], r = this.vertices[e[1]], e = this.vertices[e[2]]; return o.computeNormal(i, r, e, t) }, new _), T = (o.prototype.clipAgainstHull = function (e, t, i, r, n, a, o, s, l) { for (var c = b, h = -1, u = -Number.MAX_VALUE, d = 0; d < i.faces.length; d++) { c.copy(i.faceNormals[d]), n.vmult(c, c); var p = c.dot(a); u < p && (u = p, h = d) } for (var f = [], m = i.faces[h], v = m.length, g = 0; g < v; g++) { var x = i.vertices[m[g]], y = new _; y.copy(x), n.vmult(y, y), r.vadd(y, y), f.push(y) } 0 <= h && this.clipFaceAgainstHull(a, e, t, f, o, s, l) }, new _), S = new _, M = new _, A = new _, R = new _, L = new _, s = (o.prototype.findSeparatingAxis = function (e, t, i, r, n, a, o, s) { var l = T, c = S, h = M, u = A, d = R, p = L, f = Number.MAX_VALUE, m = this; if (m.uniqueAxes) for (g = 0; g !== m.uniqueAxes.length; g++) { if (i.vmult(m.uniqueAxes[g], l), !1 === (_ = m.testSepAxis(l, e, t, i, r, n))) return !1; _ < f && (f = _, a.copy(l)) } else for (var v = (o || m.faces).length, g = 0; g < v; g++) { var x = o ? o[g] : g; if (l.copy(m.faceNormals[x]), i.vmult(l, l), !1 === (_ = m.testSepAxis(l, e, t, i, r, n))) return !1; _ < f && (f = _, a.copy(l)) } if (e.uniqueAxes) for (g = 0; g !== e.uniqueAxes.length; g++) { if (n.vmult(e.uniqueAxes[g], c), !1 === (_ = m.testSepAxis(c, e, t, i, r, n))) return !1; _ < f && (f = _, a.copy(c)) } else for (var y = (s || e.faces).length, g = 0; g < y; g++) { var _, x = s ? s[g] : g; if (c.copy(e.faceNormals[x]), n.vmult(c, c), !1 === (_ = m.testSepAxis(c, e, t, i, r, n))) return !1; _ < f && (f = _, a.copy(c)) } for (var b = 0; b !== m.uniqueEdges.length; b++) { i.vmult(m.uniqueEdges[b], u); for (var w = 0; w !== e.uniqueEdges.length; w++)if (n.vmult(e.uniqueEdges[w], d), u.cross(d, p), !p.almostZero()) { p.normalize(); var E = m.testSepAxis(p, e, t, i, r, n); if (!1 === E) return !1; E < f && (f = E, a.copy(p)) } } return r.vsub(t, h), 0 < h.dot(a) && a.negate(a), !0 }, []), l = [], c = (o.prototype.testSepAxis = function (e, t, i, r, n, a) { return o.project(this, e, i, r, s), o.project(t, e, n, a, l), r = s[1], t = l[0], !((i = s[0]) < (e = l[1]) || t < r) && ((n = i - e) < (a = t - r) ? n : a) }, new _), u = new _, D = (o.prototype.calculateLocalInertia = function (e, t) { this.computeLocalAABB(c, u); var i = u.x - c.x, r = u.y - c.y, n = u.z - c.z; t.x = 1 / 12 * e * (2 * r * 2 * r + 2 * n * 2 * n), t.y = 1 / 12 * e * (2 * i * 2 * i + 2 * n * 2 * n), t.z = 1 / 12 * e * (2 * r * 2 * r + 2 * i * 2 * i) }, o.prototype.getPlaneConstantOfFace = function (e) { var t = this.faces[e], e = this.faceNormals[e], t = this.vertices[t[0]]; return -e.dot(t) }, new _), I = new _, N = new _, H = new _, B = new _, U = new _, z = new _, O = new _, f = (o.prototype.clipFaceAgainstHull = function (e, t, i, r, n, a, o) { for (var s = D, l = I, c = N, h = H, u = B, d = U, p = z, f = O, m = this, v = r, g = [], x = -1, y = Number.MAX_VALUE, _ = 0; _ < m.faces.length; _++) { s.copy(m.faceNormals[_]), i.vmult(s, s); var b = s.dot(e); b < y && (y = b, x = _) } if (!(x < 0)) { var w = m.faces[x]; w.connectedFaces = []; for (var E = 0; E < m.faces.length; E++)for (var T = 0; T < m.faces[E].length; T++)-1 !== w.indexOf(m.faces[E][T]) && E !== x && -1 === w.connectedFaces.indexOf(E) && w.connectedFaces.push(E); v.length; for (var S = w.length, M = 0; M < S; M++) { var A = m.vertices[w[M]], R = m.vertices[w[(M + 1) % S]], R = (A.vsub(R, l), c.copy(l), i.vmult(c, c), t.vadd(c, c), h.copy(this.faceNormals[x]), i.vmult(h, h), t.vadd(h, h), c.cross(h, u), u.negate(u), d.copy(A), i.vmult(d, d), t.vadd(d, d), d.dot(u), w.connectedFaces[M]), L = (p.copy(this.faceNormals[R]), this.getPlaneConstantOfFace(R)), P = (f.copy(p), i.vmult(f, f), L - f.dot(t)); for (this.clipFaceAgainstPlane(v, g, f, P); v.length;)v.shift(); for (; g.length;)v.push(g.shift()) } for (p.copy(this.faceNormals[x]), L = this.getPlaneConstantOfFace(x), f.copy(p), i.vmult(f, f), P = L - f.dot(t), E = 0; E < v.length; E++) { var C, F = f.dot(v[E]) + P; F <= n && ( F = n), F <= a && (C = v[E], F <= 0 && o.push({ point: C, normal: f, depth: F })) } } }, o.prototype.clipFaceAgainstPlane = function (e, t, i, r) { var n = e.length; if (n < 2) return t; for (var a = e[e.length - 1], o = (e[0], i.dot(a) + r), s = 0; s < n; s++) { var l, c = e[s], h = i.dot(c) + r; o < 0 ? (h < 0 ? (l = new _).copy(c) : (l = new _, a.lerp(c, o / (o - h), l)), t.push(l)) : h < 0 && (l = new _, a.lerp(c, o / (o - h), l), t.push(l), t.push(c)), a = c, o = h } return t }, o.prototype.computeWorldVertices = function (e, t) { for (var i = this.vertices.length; this.worldVertices.length < i;)this.worldVertices.push(new _); for (var r = this.vertices, n = this.worldVertices, a = 0; a !== i; a++)t.vmult(r[a], n[a]), e.vadd(n[a], n[a]); this.worldVerticesNeedsUpdate = !1 }, new _, o.prototype.computeLocalAABB = function (e, t) { var i = this.vertices.length, r = this.vertices; e.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), t.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE); for (var n = 0; n < i; n++) { var a = r[n]; a.x < e.x ? e.x = a.x : a.x > t.x && (t.x = a.x), a.y < e.y ? e.y = a.y : a.y > t.y && (t.y = a.y), a.z < e.z ? e.z = a.z : a.z > t.z && (t.z = a.z) } }, o.prototype.computeWorldFaceNormals = function (e) { for (var t = this.faceNormals.length; this.worldFaceNormals.length < t;)this.worldFaceNormals.push(new _); for (var i = this.faceNormals, r = this.worldFaceNormals, n = 0; n !== t; n++)e.vmult(i[n], r[n]); this.worldFaceNormalsNeedsUpdate = !1 }, o.prototype.updateBoundingSphereRadius = function () { for (var e = 0, t = this.vertices, i = 0, r = t.length; i !== r; i++) { var n = t[i].norm2(); e < n && (e = n) } this.boundingSphereRadius = Math.sqrt(e) }, new _), d = (o.prototype.calculateWorldAABB = function (e, t, i, r) { for (var n, a, o, s, l, c, h = this.vertices.length, u = this.vertices, d = 0; d < h; d++)f.copy(u[d]), t.vmult(f, f), e.vadd(f, f), f.x < n || void 0 === n ? n = f.x : (f.x > s || void 0 === s) && (s = f.x), f.y < a || void 0 === a ? a = f.y : (f.y > l || void 0 === l) && (l = f.y), f.z < o || void 0 === o ? o = f.z : (f.z > c || void 0 === c) && (c = f.z); i.set(n, a, o), r.set(s, l, c) }, o.prototype.volume = function () { return 4 * Math.PI * this.boundingSphereRadius / 3 }, o.prototype.getAveragePointLocal = function (e) { e = e || new _; for (var t = this.vertices.length, i = this.vertices, r = 0; r < t; r++)e.vadd(i[r], e); return e.mult(1 / t, e), e }, o.prototype.transformAllPoints = function (e, t) { var i = this.vertices.length, r = this.vertices; if (t) { for (var n = 0; n < i; n++) { var a = r[n]; t.vmult(a, a) } for (n = 0; n < this.faceNormals.length; n++)a = this.faceNormals[n], t.vmult(a, a) } if (e) for (n = 0; n < i; n++)(a = r[n]).vadd(e, a) }, new _), m = new _, v = new _, g = (o.prototype.pointIsInside = function (e) { var t = this.vertices.length, i = this.vertices, r = this.faces, n = this.faceNormals, a = this.faces.length, o = d; this.getAveragePointLocal(o); for (var s = 0; s < a; s++) { this.faces[s].length; var t = n[s], l = i[r[s][0]], c = (e.vsub(l, c = m), t.dot(c)), h = v, l = (o.vsub(l, h), t.dot(h)); if (c < 0 && 0 < l || 0 < c && l < 0) return !1 } return -1 }, new _, new _), x = new _; o.project = function (e, t, i, r, n) { for (var a = e.vertices.length, o = g, s = 0, l = 0, c = x, h = e.vertices, e = (c.setZero(), p.vectorToLocalFrame(i, r, t, o), p.pointToLocalFrame(i, r, c, c), c.dot(o)), l = s = h[0].dot(o), u = 1; u < a; u++) { var d = h[u].dot(o); s < d && (s = d), d < l && (l = d) } (s -= e) < (l -= e) && (t = l, l = s, s = t), n[0] = s, n[1] = l } }, { "../math/Quaternion": 28, "../math/Transform": 29, "../math/Vec3": 30, "./Shape": 43 }], 39: [function (e, t, i) { t.exports = r; var v = e("./Shape"), g = e("../math/Vec3"), x = (e("../math/Quaternion"), e("./ConvexPolyhedron")); function r(e, t, i, r) { var n = r, a = [], o = [], s = [], l = [], c = [], h = Math.cos, u = Math.sin; a.push(new g(t * h(0), t * u(0), .5 * -i)), l.push(0), a.push(new g(e * h(0), e * u(0), .5 * i)), c.push(1); for (var d = 0; d < n; d++) { var p = 2 * Math.PI / n * (d + 1), f = 2 * Math.PI / n * (d + .5); d < n - 1 ? (a.push(new g(t * h(p), t * u(p), .5 * -i)), l.push(2 * d + 2), a.push(new g(e * h(p), e * u(p), .5 * i)), c.push(2 * d + 3), s.push([2 * d + 2, 2 * d + 3, 2 * d + 1, 2 * d])) : s.push([0, 1, 2 * d + 1, 2 * d]), (n % 2 == 1 || d < n / 2) && o.push(new g(h(f), u(f), 0)) } s.push(c), o.push(new g(0, 0, 1)); for (var m = [], d = 0; d < l.length; d++)m.push(l[l.length - d - 1]); s.push(m), this.type = v.types.CONVEXPOLYHEDRON, x.call(this, a, s, o) } r.prototype = new x }, { "../math/Quaternion": 28, "../math/Vec3": 30, "./ConvexPolyhedron": 38, "./Shape": 43 }], 40: [function (e, t, i) { var r = e("./Shape"), u = e("./ConvexPolyhedron"), d = e("../math/Vec3"), n = e("../utils/Utils"); function a(e, t) { t = n.defaults(t, { maxValue: null, minValue: null, elementSize: 1 }), this.data = e, this.maxValue = t.maxValue, this.minValue = t.minValue, this.elementSize = t.elementSize, null === t.minValue && this.updateMinValue(), null === t.maxValue && this.updateMaxValue(), this.cacheEnabled = !0, r.call(this), this.pillarConvex = new u, this.pillarOffset = new d, this.type = r.types.HEIGHTFIELD, this.updateBoundingSphereRadius(), this._cachedPillars = {} } ((t.exports = a).prototype = new r).update = function () { this._cachedPillars = {} }, a.prototype.updateMinValue = function () { for (var e = this.data, t = e[0][0], i = 0; i !== e.length; i++)for (var r = 0; r !== e[i].length; r++) { var n = e[i][r]; n < t && (t = n) } this.minValue = t }, a.prototype.updateMaxValue = function () { for (var e = this.data, t = e[0][0], i = 0; i !== e.length; i++)for (var r = 0; r !== e[i].length; r++) { var n = e[i][r]; t < n && (t = n) } this.maxValue = t }, a.prototype.setHeightValueAtIndex = function (e, t, i) { this.data[e][t] = i, this.clearCachedConvexTrianglePillar(e, t, !1), 0 < e && (this.clearCachedConvexTrianglePillar(e - 1, t, !0), this.clearCachedConvexTrianglePillar(e - 1, t, !1)), 0 < t && (this.clearCachedConvexTrianglePillar(e, t - 1, !0), this.clearCachedConvexTrianglePillar(e, t - 1, !1)), 0 < t && 0 < e && this.clearCachedConvexTrianglePillar(e - 1, t - 1, !0) }, a.prototype.getRectMinMax = function (e, t, i, r, n) { n = n || []; for (var a = this.data, o = this.minValue, s = e; s <= i; s++)for (var l = t; l <= r; l++) { var c = a[s][l]; o < c && (o = c) } n[0] = this.minValue, n[1] = o }, a.prototype.getIndexOfPosition = function (e, t, i, r) { var n = this.elementSize, a = this.data, e = Math.floor(e / n), t = Math.floor(t / n); return i[0] = e, i[1] = t, r && ((e = e < 0 ? 0 : e) >= a.length - 1 && (e = a.length - 1), (t = t < 0 ? 0 : t) >= a[0].length - 1 && (t = a[0].length - 1)), !(e < 0 || t < 0 || e >= a.length - 1 || t >= a[0].length - 1) }, a.prototype.getHeightAt = function (e, t, i) { var r = [], e = (this.getIndexOfPosition(e, t, r, i), []); return this.getRectMinMax(r[0], r[1] + 1, r[0], r[1] + 1, e), (e[0] + e[1]) / 2 }, a.prototype.getCacheConvexTrianglePillarKey = function (e, t, i) { return e + "_" + t + "_" + (i ? 1 : 0) }, a.prototype.getCachedConvexTrianglePillar = function (e, t, i) { return this._cachedPillars[this.getCacheConvexTrianglePillarKey(e, t, i)] }, a.prototype.setCachedConvexTrianglePillar = function (e, t, i, r, n) { this._cachedPillars[this.getCacheConvexTrianglePillarKey(e, t, i)] = { convex: r, offset: n } }, a.prototype.clearCachedConvexTrianglePillar = function (e, t, i) { delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(e, t, i)] }, a.prototype.getConvexTrianglePillar = function (e, t, i) { var r = this.pillarConvex, n = this.pillarOffset; if (this.cacheEnabled) { if (a = this.getCachedConvexTrianglePillar(e, t, i)) return this.pillarConvex = a.convex, void (this.pillarOffset = a.offset); r = new u, n = new d, this.pillarConvex = r, this.pillarOffset = n } var a = this.data, o = this.elementSize, s = r.faces; r.vertices.length = 6; for (var l = 0; l < 6; l++)r.vertices[l] || (r.vertices[l] = new d); for (s.length = 5, l = 0; l < 5; l++)s[l] || (s[l] = []); var c = r.vertices, h = (Math.min(a[e][t], a[e + 1][t], a[e][t + 1], a[e + 1][t + 1]) - this.minValue) / 2 + this.minValue; i ? (n.set((e + .75) * o, (t + .75) * o, h), c[0].set(.25 * o, .25 * o, a[e + 1][t + 1] - h), c[1].set(-.75 * o, .25 * o, a[e][t + 1] - h), c[2].set(.25 * o, -.75 * o, a[e + 1][t] - h), c[3].set(.25 * o, .25 * o, -h - 1), c[4].set(-.75 * o, .25 * o, -h - 1), c[5].set(.25 * o, -.75 * o, -h - 1), s[0][0] = 0, s[0][1] = 1, s[0][2] = 2, s[1][0] = 5, s[1][1] = 4, s[1][2] = 3, s[2][0] = 2, s[2][1] = 5, s[2][2] = 3, s[2][3] = 0, s[3][0] = 3, s[3][1] = 4, s[3][2] = 1, s[3][3] = 0, s[4][0] = 1, s[4][1] = 4, s[4][2] = 5, s[4][3] = 2) : (n.set((e + .25) * o, (t + .25) * o, h), c[0].set(-.25 * o, -.25 * o, a[e][t] - h), c[1].set(.75 * o, -.25 * o, a[e + 1][t] - h), c[2].set(-.25 * o, .75 * o, a[e][t + 1] - h), c[3].set(-.25 * o, -.25 * o, -h - 1), c[4].set(.75 * o, -.25 * o, -h - 1), c[5].set(-.25 * o, .75 * o, -h - 1), s[0][0] = 0, s[0][1] = 1, s[0][2] = 2, s[1][0] = 5, s[1][1] = 4, s[1][2] = 3, s[2][0] = 0, s[2][1] = 2, s[2][2] = 5, s[2][3] = 3, s[3][0] = 1, s[3][1] = 0, s[3][2] = 3, s[3][3] = 4, s[4][0] = 4, s[4][1] = 5, s[4][2] = 2, s[4][3] = 1), r.computeNormals(), r.computeEdges(), r.updateBoundingSphereRadius(), this.setCachedConvexTrianglePillar(e, t, i, r, n) }, a.prototype.calculateLocalInertia = function (e, t) { return (t = t || new d).set(0, 0, 0), t }, a.prototype.volume = function () { return Number.MAX_VALUE }, a.prototype.calculateWorldAABB = function (e, t, i, r) { i.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), r.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE) }, a.prototype.updateBoundingSphereRadius = function () { var e = this.data, t = this.elementSize; this.boundingSphereRadius = new d(e.length * t, e[0].length * t, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm() } }, { "../math/Vec3": 30, "../utils/Utils": 53, "./ConvexPolyhedron": 38, "./Shape": 43 }], 41: [function (e, t, i) { t.exports = a; var r = e("./Shape"), n = e("../math/Vec3"); function a() { r.call(this), this.type = r.types.PARTICLE } ((a.prototype = new r).constructor = a).prototype.calculateLocalInertia = function (e, t) { return (t = t || new n).set(0, 0, 0), t }, a.prototype.volume = function () { return 0 }, a.prototype.updateBoundingSphereRadius = function () { this.boundingSphereRadius = 0 }, a.prototype.calculateWorldAABB = function (e, t, i, r) { i.copy(e), r.copy(e) } }, { "../math/Vec3": 30, "./Shape": 43 }], 42: [function (e, t, i) { t.exports = a; var r = e("./Shape"), n = e("../math/Vec3"); function a() { r.call(this), this.type = r.types.PLANE, this.worldNormal = new n, this.worldNormalNeedsUpdate = !0, this.boundingSphereRadius = Number.MAX_VALUE } ((a.prototype = new r).constructor = a).prototype.computeWorldNormal = function (e) { var t = this.worldNormal; t.set(0, 0, 1), e.vmult(t, t), this.worldNormalNeedsUpdate = !1 }, a.prototype.calculateLocalInertia = function (e, t) { return t || new n }, a.prototype.volume = function () { return Number.MAX_VALUE }; var o = new n; a.prototype.calculateWorldAABB = function (e, t, i, r) { o.set(0, 0, 1), t.vmult(o, o), t = Number.MAX_VALUE, i.set(-t, -t, -t), r.set(t, t, t), 1 === o.x && (r.x = e.x), 1 === o.y && (r.y = e.y), 1 === o.z && (r.z = e.z), -1 === o.x && (i.x = e.x), -1 === o.y && (i.y = e.y), -1 === o.z && (i.z = e.z) }, a.prototype.updateBoundingSphereRadius = function () { this.boundingSphereRadius = Number.MAX_VALUE } }, { "../math/Vec3": 30, "./Shape": 43 }], 43: [function (e, t, i) { t.exports = r; var r = e("./Shape"); function r() { this.id = r.idCounter++, this.type = 0, this.boundingSphereRadius = 0, this.collisionResponse = !0, this.material = null } e("../math/Vec3"), e("../math/Quaternion"), e("../material/Material"), (r.prototype.constructor = r).prototype.updateBoundingSphereRadius = function () { throw "computeBoundingSphereRadius() not implemented for shape type " + this.type }, r.prototype.volume = function () { throw "volume() not implemented for shape type " + this.type }, r.prototype.calculateLocalInertia = function (e, t) { throw "calculateLocalInertia() not implemented for shape type " + this.type }, r.idCounter = 0, r.types = { SPHERE: 1, PLANE: 2, BOX: 4, COMPOUND: 8, CONVEXPOLYHEDRON: 16, HEIGHTFIELD: 32, PARTICLE: 64, CYLINDER: 128, TRIMESH: 256 } }, { "../material/Material": 25, "../math/Quaternion": 28, "../math/Vec3": 30, "./Shape": 43 }], 44: [function (e, t, i) { t.exports = a; var r = e("./Shape"), n = e("../math/Vec3"); function a(e) { if (r.call(this), this.radius = void 0 !== e ? Number(e) : 1, this.type = r.types.SPHERE, this.radius < 0) throw new Error("The sphere radius cannot be negative."); this.updateBoundingSphereRadius() } ((a.prototype = new r).constructor = a).prototype.calculateLocalInertia = function (e, t) { return t = t || new n, e = 2 * e * this.radius * this.radius / 5, t.x = e, t.y = e, t.z = e, t }, a.prototype.volume = function () { return 4 * Math.PI * this.radius / 3 }, a.prototype.updateBoundingSphereRadius = function () { this.boundingSphereRadius = this.radius }, a.prototype.calculateWorldAABB = function (e, t, i, r) { for (var n = this.radius, a = ["x", "y", "z"], o = 0; o < a.length; o++) { var s = a[o]; i[s] = e[s] - n, r[s] = e[s] + n } } }, { "../math/Vec3": 30, "./Shape": 43 }], 45: [function (e, t, i) { t.exports = m; var r = e("./Shape"), c = e("../math/Vec3"), n = (e("../math/Quaternion"), e("../math/Transform")), h = e("../collision/AABB"), a = e("../utils/Octree"); function m(e, t) { r.call(this), this.type = r.types.TRIMESH, this.vertices = new Float32Array(e), this.indices = new Int16Array(t), this.normals = new Float32Array(t.length), this.aabb = new h, this.edges = null, this.scale = new c(1, 1, 1), this.tree = new a, this.updateEdges(), this.updateNormals(), this.updateAABB(), this.updateBoundingSphereRadius(), this.updateTree() } (m.prototype = new r).constructor = m; var s = new c, o = (m.prototype.updateTree = function () { for (var e = this.tree, t = (e.reset(), e.aabb.copy(this.aabb), this.scale), i = (e.aabb.lowerBound.x *= 1 / t.x, e.aabb.lowerBound.y *= 1 / t.y, e.aabb.lowerBound.z *= 1 / t.z, e.aabb.upperBound.x *= 1 / t.x, e.aabb.upperBound.y *= 1 / t.y, e.aabb.upperBound.z *= 1 / t.z, new h), r = new c, n = new c, a = new c, o = [r, n, a], s = 0; s < this.indices.length / 3; s++) { var l = 3 * s; this._getUnscaledVertex(this.indices[l], r), this._getUnscaledVertex(this.indices[1 + l], n), this._getUnscaledVertex(this.indices[2 + l], a), i.setFromPoints(o), e.insert(i, s) } e.removeEmptyNodes() }, new h), l = (m.prototype.getTrianglesInAABB = function (e, t) { o.copy(e); var i = (e = this.scale).x, r = e.y, e = e.z, n = o.lowerBound, a = o.upperBound; return n.x /= i, n.y /= r, n.z /= e, a.x /= i, a.y /= r, a.z /= e, this.tree.aabbQuery(o, t) }, m.prototype.setScale = function (e) { var t = this.scale.x === this.scale.y === this.scale.z, i = e.x === e.y === e.z; t && i || this.updateNormals(), this.scale.copy(e), this.updateAABB(), this.updateBoundingSphereRadius() }, m.prototype.updateNormals = function () { for (var e = s, t = this.normals, i = 0; i < this.indices.length / 3; i++) { var r = 3 * i, n = this.indices[r], a = this.indices[1 + r], o = this.indices[2 + r]; this.getVertex(n, f), this.getVertex(a, v), this.getVertex(o, g), m.computeNormal(v, f, g, e), t[r] = e.x, t[1 + r] = e.y, t[2 + r] = e.z } }, m.prototype.updateEdges = function () { function e() { t[n < a ? n + "_" + a : a + "_" + n] = !0 } for (var t = {}, i = 0; i < this.indices.length / 3; i++) { var r = 3 * i, n = this.indices[r], a = this.indices[1 + r]; this.indices[2 + r], e(), e(), e() } var o = Object.keys(t); for (this.edges = new Int16Array(2 * o.length), i = 0; i < o.length; i++) { var s = o[i].split("_"); this.edges[2 * i] = parseInt(s[0], 10), this.edges[2 * i + 1] = parseInt(s[1], 10) } }, m.prototype.getEdgeVertex = function (e, t, i) { e = this.edges[2 * e + (t ? 1 : 0)], this.getVertex(e, i) }, new c), u = new c, d = (m.prototype.getEdgeVector = function (e, t) { var i = l, r = u; this.getEdgeVertex(e, 0, i), this.getEdgeVertex(e, 1, r), r.vsub(i, t) }, new c), p = new c, f = (m.computeNormal = function (e, t, i, r) { t.vsub(e, p), i.vsub(t, d), d.cross(p, r), r.isZero() || r.normalize() }, new c), v = new c, g = new c, x = (m.prototype.getVertex = function (e, t) { var i = this.scale; return this._getUnscaledVertex(e, t), t.x *= i.x, t.y *= i.y, t.z *= i.z, t }, m.prototype._getUnscaledVertex = function (e, t) { var e = 3 * e, i = this.vertices; return t.set(i[e], i[1 + e], i[2 + e]) }, m.prototype.getWorldVertex = function (e, t, i, r) { return this.getVertex(e, r), n.pointToWorldFrame(t, i, r, r), r }, m.prototype.getTriangleVertices = function (e, t, i, r) { this.getVertex(this.indices[e *= 3], t), this.getVertex(this.indices[1 + e], i), this.getVertex(this.indices[2 + e], r) }, m.prototype.getNormal = function (e, t) { return t.set(this.normals[e *= 3], this.normals[1 + e], this.normals[2 + e]) }, new h), y = (m.prototype.calculateLocalInertia = function (e, t) { this.computeLocalAABB(x); var i = x.upperBound.x - x.lowerBound.x, r = x.upperBound.y - x.lowerBound.y, n = x.upperBound.z - x.lowerBound.z; return t.set(1 / 12 * e * (2 * r * 2 * r + 2 * n * 2 * n), 1 / 12 * e * (2 * i * 2 * i + 2 * n * 2 * n), 1 / 12 * e * (2 * r * 2 * r + 2 * i * 2 * i)) }, new c), _ = (m.prototype.computeLocalAABB = function (e) { var t = e.lowerBound, i = e.upperBound, r = this.vertices.length, n = (this.vertices, y); this.getVertex(0, n), t.copy(n), i.copy(n); for (var a = 0; a !== r; a++)this.getVertex(a, n), n.x < t.x ? t.x = n.x : n.x > i.x && (i.x = n.x), n.y < t.y ? t.y = n.y : n.y > i.y && (i.y = n.y), n.z < t.z ? t.z = n.z : n.z > i.z && (i.z = n.z) }, m.prototype.updateAABB = function () { this.computeLocalAABB(this.aabb) }, m.prototype.updateBoundingSphereRadius = function () { for (var e = 0, t = this.vertices, i = new c, r = 0, n = t.length / 3; r !== n; r++) { this.getVertex(r, i); var a = i.norm2(); e < a && (e = a) } this.boundingSphereRadius = Math.sqrt(e) }, new c, new n), b = new h; m.prototype.calculateWorldAABB = function (e, t, i, r) { var n = _, a = b; n.position = e, n.quaternion = t, this.aabb.toWorldFrame(n, a), i.copy(a.lowerBound), r.copy(a.upperBound) }, m.prototype.volume = function () { return 4 * Math.PI * this.boundingSphereRadius / 3 }, m.createTorus = function (e, t, i, r, n) { e = e || 1, t = t || .5, i = i || 8, r = r || 6, n = n || 2 * Math.PI; for (var a = [], o = [], s = 0; s <= i; s++)for (var l = 0; l <= r; l++) { var c = l / r * n, h = s / i * Math.PI * 2, u = (e + t * Math.cos(h)) * Math.cos(c), c = (e + t * Math.cos(h)) * Math.sin(c), h = t * Math.sin(h); a.push(u, c, h) } for (s = 1; s <= i; s++)for (l = 1; l <= r; l++) { var d = (r + 1) * (s - 1) + l - 1, p = (r + 1) * (s - 1) + l, f = (r + 1) * s + l; o.push((r + 1) * s + l - 1, d, f), o.push(d, p, f) } return new m(a, o) } }, { "../collision/AABB": 3, "../math/Quaternion": 28, "../math/Transform": 29, "../math/Vec3": 30, "../utils/Octree": 50, "./Shape": 43 }], 46: [function (e, t, i) { t.exports = n, e("../math/Vec3"), e("../math/Quaternion"); var r = e("./Solver"); function n() { r.call(this), this.iterations = 10, this.tolerance = 1e-7 } n.prototype = new r; var S = [], M = [], A = []; n.prototype.solve = function (e, t) { var i = 0, r = this.iterations, n = this.tolerance * this.tolerance, a = this.equations, o = a.length, s = t.bodies, l = s.length, c = e; if (0 !== o) for (var h = 0; h !== l; h++)s[h].updateSolveMassProperties(); var u = M, d = A, p = S; for (u.length = o, d.length = o, p.length = o, h = 0; h !== o; h++) { var f = a[h]; p[h] = 0, d[h] = f.computeB(c), u[h] = 1 / f.computeC() } if (0 !== o) { for (h = 0; h !== l; h++) { var m = (w = s[h]).vlambda, v = w.wlambda; m.set(0, 0, 0), v && v.set(0, 0, 0) } for (i = 0; i !== r; i++) { for (var g = 0, x = 0; x !== o; x++) { var y, f = a[x], _ = d[x], b = u[x]; (y = p[x]) + (b *= _ - f.computeGWlambda() - f.eps * y) < f.minForce ? b = f.minForce - y : y + b > f.maxForce && (b = f.maxForce - y), p[x] += b, g += 0 < b ? b : -b, f.addToWlambda(b) } if (g * g < n) break } for (h = 0; h !== l; h++) { var w, E = (w = s[h]).velocity, T = w.angularVelocity; E.vadd(w.vlambda, E), T && T.vadd(w.wlambda, T) } } return i } }, { "../math/Quaternion": 28, "../math/Vec3": 30, "./Solver": 47 }], 47: [function (e, t, i) { function r() { this.equations = [] } (t.exports = r).prototype.solve = function (e, t) { return 0 }, r.prototype.addEquation = function (e) { e.enabled && this.equations.push(e) }, r.prototype.removeEquation = function (e) { var t = this.equations; -1 !== (e = t.indexOf(e)) && t.splice(e, 1) }, r.prototype.removeAllEquations = function () { this.equations.length = 0 } }, {}], 48: [function (e, t, i) { t.exports = n, e("../math/Vec3"), e("../math/Quaternion"); var r = e("./Solver"), t = e("../objects/Body"); function n(e) { for (r.call(this), this.iterations = 10, this.tolerance = 1e-7, this.subsolver = e, this.nodes = [], this.nodePool = []; this.nodePool.length < 128;)this.nodePool.push(this.createNode()) } n.prototype = new r; var M = [], A = [], R = { bodies: [] }, a = t.STATIC; function L(e) { for (var t = e.length, i = 0; i !== t; i++) { var r = e[i]; if (!(r.visited || r.body.type & a)) return r } return !1 } var P = []; function C(e, t, i) { t.push(e.body); for (var r = e.eqs.length, n = 0; n !== r; n++) { var a = e.eqs[n]; -1 === i.indexOf(a) && i.push(a) } } function F(e, t) { return t.id - e.id } n.prototype.createNode = function () { return { body: null, children: [], eqs: [], visited: !1 } }, n.prototype.solve = function (e, t) { for (var i = M, r = this.nodePool, n = t.bodies, a = this.equations, o = a.length, s = n.length, l = this.subsolver; r.length < s;)r.push(this.createNode()); i.length = s; for (var c = 0; c < s; c++)i[c] = r[c]; for (c = 0; c !== s; c++) { var h = i[c]; h.body = n[c], h.children.length = 0, h.eqs.length = 0, h.visited = !1 } for (var u = 0; u !== o; u++) { var d = a[u], c = n.indexOf(d.bi), p = n.indexOf(d.bj), f = i[c], p = i[p]; f.children.push(p), f.eqs.push(d), p.children.push(f), p.eqs.push(d) } for (var m, v = 0, g = A, x = (l.tolerance = this.tolerance, l.iterations = this.iterations, R); m = L(i);) { g.length = 0; var y = b = _ = void (x.bodies.length = 0), _ = m, b = C, w = x.bodies, E = g; for (P.push(_), _.visited = !0, b(_, w, E); P.length;)for (var T = P.pop(); y = L(T.children);)y.visited = !0, b(y, w, E), P.push(y); for (var S = g.length, g = g.sort(F), c = 0; c !== S; c++)l.addEquation(g[c]); l.solve(e, x), l.removeAllEquations(), v++ } return v } }, { "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/Body": 31, "./Solver": 47 }], 49: [function (e, t, i) { function r() { } (t.exports = r).prototype = { constructor: r, addEventListener: function (e, t) { void 0 === this._listeners && (this._listeners = {}); var i = this._listeners; return void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t), this }, hasEventListener: function (e, t) { if (void 0 === this._listeners) return !1; var i = this._listeners; return void 0 !== i[e] && -1 !== i[e].indexOf(t) }, removeEventListener: function (e, t) { if (void 0 === this._listeners) return this; var i = this._listeners; return void 0 !== i[e] && -1 !== (t = i[e].indexOf(t)) && i[e].splice(t, 1), this }, dispatchEvent: function (e) { if (void 0 === this._listeners) return this; var t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; for (var i = 0, r = t.length; i < r; i++)t[i].call(this, e) } return this } } }, {}], 50: [function (e, t, i) { var s = e("../collision/AABB"), l = e("../math/Vec3"); function c(e) { this.root = (e = e || {}).root || null, this.aabb = e.aabb ? e.aabb.clone() : new s, this.data = [], this.children = [] } (t.exports = function (e, t) { (t = t || {}).root = null, t.aabb = e, c.call(this, t), this.maxDepth = void 0 !== t.maxDepth ? t.maxDepth : 8 }).prototype = new c, c.prototype.reset = function (e, t) { this.children.length = this.data.length = 0 }, c.prototype.insert = function (e, t, i) { var r = this.data; if (i = i || 0, !this.aabb.contains(e)) return !1; var n = this.children; if (i < (this.maxDepth || this.root.maxDepth)) { var a = !1; n.length || (this.subdivide(), a = !0); for (var o = 0; 8 !== o; o++)if (n[o].insert(e, t, i + 1)) return !0; a && (n.length = 0) } return r.push(t), !0 }; var h = new l, r = (c.prototype.subdivide = function () { for (var e = (t = this.aabb).lowerBound, t = t.upperBound, i = this.children, r = (i.push(new c({ aabb: new s({ lowerBound: new l(0, 0, 0) }) }), new c({ aabb: new s({ lowerBound: new l(1, 0, 0) }) }), new c({ aabb: new s({ lowerBound: new l(1, 1, 0) }) }), new c({ aabb: new s({ lowerBound: new l(1, 1, 1) }) }), new c({ aabb: new s({ lowerBound: new l(0, 1, 1) }) }), new c({ aabb: new s({ lowerBound: new l(0, 0, 1) }) }), new c({ aabb: new s({ lowerBound: new l(1, 0, 1) }) }), new c({ aabb: new s({ lowerBound: new l(0, 1, 0) }) })), t.vsub(e, h), h.scale(.5, h), this.root || this), n = 0; 8 !== n; n++) { var a = i[n], o = (a.root = r, a.aabb.lowerBound); o.x *= h.x, o.y *= h.y, o.z *= h.z, o.vadd(e, o), o.vadd(h, a.aabb.upperBound) } }, c.prototype.aabbQuery = function (e, t) { this.data, this.children; for (var i = [this]; i.length;) { var r = i.pop(); r.aabb.overlaps(e) && Array.prototype.push.apply(t, r.data), Array.prototype.push.apply(i, r.children) } return t }, new s); c.prototype.rayQuery = function (e, t, i) { return e.getAABB(r), r.toLocalFrame(t, r), this.aabbQuery(r, i), i }, c.prototype.removeEmptyNodes = function () { for (var e = [this]; e.length;) { for (var t = e.pop(), i = t.children.length - 1; 0 <= i; i--)t.children[i].data.length || t.children.splice(i, 1); Array.prototype.push.apply(e, t.children) } } }, { "../collision/AABB": 3, "../math/Vec3": 30 }], 51: [function (e, t, i) { function r() { this.objects = [], this.type = Object } (t.exports = r).prototype.release = function () { for (var e = arguments.length, t = 0; t !== e; t++)this.objects.push(arguments[t]) }, r.prototype.get = function () { return 0 === this.objects.length ? this.constructObject() : this.objects.pop() }, r.prototype.constructObject = function () { throw new Error("constructObject() not implemented in this Pool subclass yet!") } }, {}], 52: [function (e, t, i) { function r() { this.data = { keys: [] } } (t.exports = r).prototype.get = function (e, t) { var i; return t < e && (i = t, t = e, e = i), this.data[e + "-" + t] }, r.prototype.set = function (e, t, i) { t < e && (r = t, t = e, e = r); var r = e + "-" + t; this.get(e, t) || this.data.keys.push(r), this.data[r] = i }, r.prototype.reset = function () { for (var e = this.data, t = e.keys; 0 < t.length;)delete e[t.pop()] } }, {}], 53: [function (e, t, i) { (t.exports = function () { }).defaults = function (e, t) { for (var i in e = e || {}, t) i in e || (e[i] = t[i]); return e } }, {}], 54: [function (e, t, i) { t.exports = a; var r = e("../math/Vec3"), n = e("./Pool"); function a() { n.call(this), this.type = r } (a.prototype = new n).constructObject = function () { return new r } }, { "../math/Vec3": 30, "./Pool": 51 }], 55: [function (e, t, o) { t.exports = a; var t = e("../collision/AABB"), i = e("../shapes/Shape"), C = e("../collision/Ray"), f = e("../math/Vec3"), F = e("../math/Transform"), r = (e("../shapes/ConvexPolyhedron"), e("../math/Quaternion")), n = (e("../solver/Solver"), e("../utils/Vec3Pool")), l = e("../equations/ContactEquation"), h = e("../equations/FrictionEquation"); function a(e) { this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], this.v3pool = new n, this.world = e, this.currentContactMaterial = null, this.enableFrictionReduction = !1 } a.prototype.createContactEquation = function (e, t, i, r, n, a) { this.contactPointPool.length ? ((o = this.contactPointPool.pop()).bi = e, o.bj = t) : o = new l(e, t), o.enabled = e.collisionResponse && t.collisionResponse && i.collisionResponse && r.collisionResponse; var o, s = this.currentContactMaterial, s = (o.restitution = s.restitution, o.setSpookParams(s.contactEquationStiffness, s.contactEquationRelaxation, this.world.dt), i.material || e.material), e = r.material || t.material; return s && e && 0 <= s.restitution && 0 <= e.restitution && (o.restitution = s.restitution * e.restitution), o.si = n || i, o.sj = a || r, o }, a.prototype.createFrictionEquationsFromContact = function (e, t) { var i, r = e.bi, n = e.bj, a = e.si, o = e.sj, s = this.world, l = this.currentContactMaterial, c = l.friction, a = a.material || r.material, o = o.material || n.material; return 0 < (c = a && o && 0 <= a.friction && 0 <= o.friction ? a.friction * o.friction : c) && (a = c * s.gravity.length(), 0 < (o = r.invMass + n.invMass) && (o = 1 / o), i = (c = this.frictionEquationPool).length ? c.pop() : new h(r, n, a * o), c = c.length ? c.pop() : new h(r, n, a * o), i.bi = c.bi = r, i.bj = c.bj = n, i.minForce = c.minForce = -a * o, i.maxForce = c.maxForce = a * o, i.ri.copy(e.ri), i.rj.copy(e.rj), c.ri.copy(e.ri), c.rj.copy(e.rj), e.ni.tangents(i.t, c.t), i.setSpookParams(l.frictionEquationStiffness, l.frictionEquationRelaxation, s.dt), c.setSpookParams(l.frictionEquationStiffness, l.frictionEquationRelaxation, s.dt), i.enabled = c.enabled = e.enabled, t.push(i, c), !0) }; var s = new f, c = new f, u = new f, b = (a.prototype.createFrictionFromAverage = function (e) { var t = this.result[this.result.length - 1]; if (this.createFrictionEquationsFromContact(t, this.frictionResult) && 1 !== e) { for (var i = this.frictionResult[this.frictionResult.length - 2], r = this.frictionResult[this.frictionResult.length - 1], n = (s.setZero(), c.setZero(), u.setZero(), t.bi), a = (t.bj, 0); a !== e; a++)(t = this.result[this.result.length - 1 - a]).bodyA !== n ? (s.vadd(t.ni, s), c.vadd(t.ri, c), u.vadd(t.rj, u)) : (s.vsub(t.ni, s), c.vadd(t.rj, c), u.vadd(t.ri, u)); var o = 1 / e; c.scale(o, i.ri), u.scale(o, i.rj), r.ri.copy(i.ri), r.rj.copy(i.rj), s.normalize(), s.tangents(i.t, r.t) } }, new f), w = new f, E = new r, T = new r, m = (a.prototype.getContacts = function (e, t, i, r, n, a, o) { this.contactPointPool = n, this.frictionEquationPool = o, this.result = r, this.frictionResult = a; for (var s = E, l = T, c = b, h = w, u = 0, d = e.length; u !== d; u++) { var p = e[u], f = t[u], m = null; p.material && f.material && (m = i.getContactMaterial(p.material, f.material) || null); for (var v = 0; v < p.shapes.length; v++) { p.quaternion.mult(p.shapeOrientations[v], s), p.quaternion.vmult(p.shapeOffsets[v], c), c.vadd(p.position, c); for (var g = p.shapes[v], x = 0; x < f.shapes.length; x++) { f.quaternion.mult(f.shapeOrientations[x], l), f.quaternion.vmult(f.shapeOffsets[x], h), h.vadd(f.position, h); var y, _ = f.shapes[x]; c.distanceTo(h) > g.boundingSphereRadius + _.boundingSphereRadius || (y = null, g.material && _.material && (y = i.getContactMaterial(g.material, _.material) || null), this.currentContactMaterial = y || m || i.defaultContactMaterial, (y = this[g.type | _.type]) && (g.type < _.type ? y.call(this, g, _, c, h, s, l, p, f, g, _) : y.call(this, _, g, h, c, l, s, f, p, g, _))) } } } }, a.prototype[i.types.BOX | i.types.BOX] = a.prototype.boxBox = function (e, t, i, r, n, a, o, s) { e.convexPolyhedronRepresentation.material = e.material, t.convexPolyhedronRepresentation.material = t.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.convexConvex(e.convexPolyhedronRepresentation, t.convexPolyhedronRepresentation, i, r, n, a, o, s, e, t) }, a.prototype[i.types.BOX | i.types.CONVEXPOLYHEDRON] = a.prototype.boxConvex = function (e, t, i, r, n, a, o, s) { e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexConvex(e.convexPolyhedronRepresentation, t, i, r, n, a, o, s, e, t) }, a.prototype[i.types.BOX | i.types.PARTICLE] = a.prototype.boxParticle = function (e, t, i, r, n, a, o, s) { e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexParticle(e.convexPolyhedronRepresentation, t, i, r, n, a, o, s, e, t) }, a.prototype[i.types.SPHERE] = a.prototype.sphereSphere = function (e, t, i, r, n, a, o, s) { var l = this.createContactEquation(o, s, e, t); r.vsub(i, l.ni), l.ni.normalize(), l.ri.copy(l.ni), l.rj.copy(l.ni), l.ri.mult(e.radius, l.ri), l.rj.mult(-t.radius, l.rj), l.ri.vadd(i, l.ri), l.ri.vsub(o.position, l.ri), l.rj.vadd(r, l.rj), l.rj.vsub(s.position, l.rj), this.result.push(l), this.createFrictionEquationsFromContact(l, this.frictionResult) }, new f), v = new f, g = new f, D = (a.prototype[i.types.PLANE | i.types.TRIMESH] = a.prototype.planeTrimesh = function (e, t, i, r, n, a, o, s) { var l = new f, c = m; c.set(0, 0, 1), n.vmult(c, c); for (var h = 0; h < t.vertices.length / 3; h++) { t.getVertex(h, l), (p = new f).copy(l), F.pointToWorldFrame(r, a, p, l); var u, d, p = v; l.vsub(i, p), c.dot(p) <= 0 && ((u = this.createContactEquation(o, s, e, t)).ni.copy(c), d = g, c.scale(p.dot(c), d), l.vsub(d, d), u.ri.copy(d), u.ri.vsub(o.position, u.ri), u.rj.copy(l), u.rj.vsub(s.position, u.rj), this.result.push(u), this.createFrictionEquationsFromContact(u, this.frictionResult)) } }, new f), I = new f, N = (new f, new f), H = new f, B = new f, U = new f, z = new f, O = new f, V = new f, k = new f, G = new f, j = new f, X = new f, q = new t, Y = [], d = (a.prototype[i.types.SPHERE | i.types.TRIMESH] = a.prototype.sphereTrimesh = function (e, t, i, r, n, a, o, s) { for (var l = B, c = U, h = z, u = O, d = V, p = k, f = q, m = H, v = I, g = Y, x = (F.pointToLocalFrame(r, a, i, d), e.radius), y = (f.lowerBound.set(d.x - x, d.y - x, d.z - x), f.upperBound.set(d.x + x, d.y + x, d.z + x), t.getTrianglesInAABB(f, g), N), _ = e.radius * e.radius, b = 0; b < g.length; b++)for (var w = 0; w < 3; w++)t.getVertex(t.indices[3 * g[b] + w], y), y.vsub(d, v), v.norm2() <= _ && (m.copy(y), F.pointToWorldFrame(r, a, m, y), y.vsub(i, v), (L = this.createContactEquation(o, s, e, t)).ni.copy(v), L.ni.normalize(), L.ri.copy(L.ni), L.ri.scale(e.radius, L.ri), L.ri.vadd(i, L.ri), L.ri.vsub(o.position, L.ri), L.rj.copy(y), L.rj.vsub(s.position, L.rj), this.result.push(L), this.createFrictionEquationsFromContact(L, this.frictionResult)); for (b = 0; b < g.length; b++)for (w = 0; w < 3; w++) { t.getVertex(t.indices[3 * g[b] + w], l), t.getVertex(t.indices[3 * g[b] + (w + 1) % 3], c), c.vsub(l, h), d.vsub(c, p); var E = p.dot(h); d.vsub(l, p), 0 < p.dot(h) && E < 0 && (d.vsub(l, p), u.copy(h), u.normalize(), E = p.dot(u), u.scale(E, p), p.vadd(l, p), (P = p.distanceTo(d)) < e.radius && (L = this.createContactEquation(o, s, e, t), p.vsub(d, L.ni), L.ni.normalize(), L.ni.scale(e.radius, L.ri), F.pointToWorldFrame(r, a, p, p), p.vsub(s.position, L.rj), F.vectorToWorldFrame(a, L.ni, L.ni), F.vectorToWorldFrame(a, L.ri, L.ri), this.result.push(L), this.createFrictionEquationsFromContact(L, this.frictionResult))) } for (var T = G, S = j, M = X, A = D, b = 0, R = g.length; b !== R; b++) { t.getTriangleVertices(g[b], T, S, M), t.getNormal(g[b], A), d.vsub(T, p); var L, P = p.dot(A); A.scale(P, p), d.vsub(p, p), P = p.distanceTo(d), C.pointInTriangle(p, T, S, M) && P < e.radius && (L = this.createContactEquation(o, s, e, t), p.vsub(d, L.ni), L.ni.normalize(), L.ni.scale(e.radius, L.ri), F.pointToWorldFrame(r, a, p, p), p.vsub(s.position, L.rj), F.vectorToWorldFrame(a, L.ni, L.ni), F.vectorToWorldFrame(a, L.ri, L.ri), this.result.push(L), this.createFrictionEquationsFromContact(L, this.frictionResult)) } g.length = 0 }, new f), p = new f, Q = (a.prototype[i.types.SPHERE | i.types.PLANE] = a.prototype.spherePlane = function (e, t, i, r, n, a, o, s) { (t = this.createContactEquation(o, s, e, t)).ni.set(0, 0, 1), a.vmult(t.ni, t.ni), t.ni.negate(t.ni), t.ni.normalize(), t.ni.mult(e.radius, t.ri), i.vsub(r, d), t.ni.mult(t.ni.dot(d), p), d.vsub(p, t.rj), -d.dot(t.ni) <= e.radius && (a = t.ri, e = t.rj, a.vadd(i, a), a.vsub(o.position, a), e.vadd(r, e), e.vsub(s.position, e), this.result.push(t), this.createFrictionEquationsFromContact(t, this.frictionResult)) }, new f), Z = new f, J = new f, W = new f, K = new f, $ = new f, ee = new f, te = [new f, new f, new f, new f, new f, new f], ie = new f, re = new f, ne = new f, ae = new f, oe = (a.prototype[i.types.SPHERE | i.types.BOX] = a.prototype.sphereBox = function (e, t, i, r, H, B, n, a) { for (var o = this.v3pool, s = te, l = (i.vsub(r, W), t.getSideNormals(s, B), e.radius), c = !1, h = re, u = ne, d = ae, p = null, U = 0, z = 0, O = 0, f = null, m = 0, V = s.length; m !== V && !1 === c; m++) { var v, g, x, y, _, b, w = K, E = (w.copy(s[m]), w.norm()), T = (w.normalize(), W.dot(w)); T < E + l && 0 < T && (g = ee, (v = $).copy(s[(m + 1) % 3]), g.copy(s[(m + 2) % 3]), x = v.norm(), y = g.norm(), v.normalize(), g.normalize(), _ = W.dot(v), b = W.dot(g), _ < x && -x < _ && b < y && -y < b && (I = Math.abs(T - E - l), (null === f || I < f) && (f = I, z = _, O = b, p = E, h.copy(w), u.copy(v), d.copy(g), U++))) } U && (c = !0, F = this.createContactEquation(n, a, e, t), h.mult(-l, F.ri), F.ni.copy(h), F.ni.negate(F.ni), h.mult(p, h), u.mult(z, u), h.vadd(u, h), d.mult(O, d), h.vadd(d, F.rj), F.ri.vadd(i, F.ri), F.ri.vsub(n.position, F.ri), F.rj.vadd(r, F.rj), F.rj.vsub(a.position, F.rj), this.result.push(F), this.createFrictionEquationsFromContact(F, this.frictionResult)); for (var S = o.get(), M = ie, A = 0; 2 !== A && !c; A++)for (var R = 0; 2 !== R && !c; R++)for (var L = 0; 2 !== L && !c; L++)S.set(0, 0, 0), A ? S.vadd(s[0], S) : S.vsub(s[0], S), R ? S.vadd(s[1], S) : S.vsub(s[1], S), L ? S.vadd(s[2], S) : S.vsub(s[2], S), r.vadd(S, M), M.vsub(i, M), M.norm2() < l * l && (c = !0, (F = this.createContactEquation(n, a, e, t)).ri.copy(M), F.ri.normalize(), F.ni.copy(F.ri), F.ri.mult(l, F.ri), F.rj.copy(S), F.ri.vadd(i, F.ri), F.ri.vsub(n.position, F.ri), F.rj.vadd(r, F.rj), F.rj.vsub(a.position, F.rj), this.result.push(F), this.createFrictionEquationsFromContact(F, this.frictionResult)); o.release(S); for (var S = null, P = o.get(), C = o.get(), F = o.get(), D = o.get(), I = o.get(), k = s.length, A = 0; A !== k && !c; A++)for (R = 0; R !== k && !c; R++)if (A % 3 != R % 3) { s[R].cross(s[A], P), P.normalize(), s[A].vadd(s[R], C), F.copy(i), F.vsub(C, F), F.vsub(r, F); for (var N = F.dot(P), L = (P.mult(N, D), 0); L === A % 3 || L === R % 3;)L++; I.copy(i), I.vsub(D, I), I.vsub(C, I), I.vsub(r, I); var N = Math.abs(N), G = I.norm(); N < s[L].norm() && G < l && (c = !0, N = this.createContactEquation(n, a, e, t), C.vadd(D, N.rj), N.rj.copy(N.rj), I.negate(N.ni), N.ni.normalize(), N.ri.copy(N.rj), N.ri.vadd(r, N.ri), N.ri.vsub(i, N.ri), N.ri.normalize(), N.ri.mult(l, N.ri), N.ri.vadd(i, N.ri), N.ri.vsub(n.position, N.ri), N.rj.vadd(r, N.rj), N.rj.vsub(a.position, N.rj), this.result.push(N), this.createFrictionEquationsFromContact(N, this.frictionResult)) } o.release(P, C, F, D, I) }, new f), se = new f, le = new f, ce = new f, he = new f, ue = new f, de = new f, pe = new f, fe = new f, me = new f, _ = (a.prototype[i.types.SPHERE | i.types.CONVEXPOLYHEDRON] = a.prototype.sphereConvex = function (e, t, i, r, N, n, a, o) { for (var s = this.v3pool, l = (i.vsub(r, oe), t.faceNormals), c = t.faces, h = t.vertices, u = e.radius, d = 0; d !== h.length; d++) { var p = h[d], f = he, p = (n.vmult(p, f), r.vadd(f, f), ce); if (f.vsub(i, p), p.norm2() < u * u) return m = !0, (M = this.createContactEquation(a, o, e, t)).ri.copy(p), M.ri.normalize(), M.ni.copy(M.ri), M.ri.mult(u, M.ri), f.vsub(r, M.rj), M.ri.vadd(i, M.ri), M.ri.vsub(a.position, M.ri), M.rj.vadd(r, M.rj), M.rj.vsub(o.position, M.rj), this.result.push(M), void this.createFrictionEquationsFromContact(M, this.frictionResult) } for (var m = !1, d = 0, v = c.length; d !== v && !1 === m; d++) { var g = l[d], x = c[d], y = ue, g = (n.vmult(g, y), de), _ = (n.vmult(h[x[0]], g), g.vadd(r, g), pe), b = (y.mult(-u, _), i.vadd(_, _), fe), _ = (_.vsub(g, b), b.dot(y)), b = me; if (i.vsub(g, b), _ < 0 && 0 < b.dot(y)) { for (var w = [], E = 0, T = x.length; E !== T; E++) { var S = s.get(); n.vmult(h[x[E]], S), r.vadd(S, S), w.push(S) } if (function (e, t, i) { for (var r = null, n = e.length, a = 0; a !== n; a++) { var o = e[a], s = Q, l = (e[(a + 1) % n].vsub(o, s), Z), s = (s.cross(t, l), J), o = (i.vsub(o, s), l.dot(s)); if (!(null === r || 0 < o && !0 === r || o <= 0 && !1 === r)) return; null === r && (r = 0 < o) } return 1 }(w, y, i)) { var m = !0, M = this.createContactEquation(a, o, e, t), g = (y.mult(-u, M.ri), y.negate(M.ni), s.get()), b = (y.mult(-_, g), s.get()); y.mult(-u, b), i.vsub(r, M.rj), M.rj.vadd(b, M.rj), M.rj.vadd(g, M.rj), M.rj.vadd(r, M.rj), M.rj.vsub(o.position, M.rj), M.ri.vadd(i, M.ri), M.ri.vsub(a.position, M.ri), s.release(g), s.release(b), this.result.push(M), this.createFrictionEquationsFromContact(M, this.frictionResult); for (var E = 0, A = w.length; E !== A; E++)s.release(w[E]); return } for (E = 0; E !== x.length; E++) { var R = s.get(), L = s.get(), P = (n.vmult(h[x[(E + 1) % x.length]], R), n.vmult(h[x[(E + 2) % x.length]], L), r.vadd(R, R), r.vadd(L, L), se), C = (L.vsub(R, P), le), F = (P.unit(C), s.get()), D = s.get(), I = (i.vsub(R, D), D.dot(C)), C = (C.mult(I, F), F.vadd(R, F), s.get()); if (F.vsub(i, C), 0 < I && I * I < P.norm2() && C.norm2() < u * u) { for (M = this.createContactEquation(a, o, e, t), F.vsub(r, M.rj), F.vsub(i, M.ni), M.ni.normalize(), M.ni.mult(u, M.ri), M.rj.vadd(r, M.rj), M.rj.vsub(o.position, M.rj), M.ri.vadd(i, M.ri), M.ri.vsub(a.position, M.ri), this.result.push(M), this.createFrictionEquationsFromContact(M, this.frictionResult), E = 0, A = w.length; E !== A; E++)s.release(w[E]); return s.release(R), s.release(L), s.release(F), s.release(C), void s.release(D) } s.release(R), s.release(L), s.release(F), s.release(C), s.release(D) } for (E = 0, A = w.length; E !== A; E++)s.release(w[E]) } } }, new f, new f, a.prototype[i.types.PLANE | i.types.BOX] = a.prototype.planeBox = function (e, t, i, r, n, a, o, s) { t.convexPolyhedronRepresentation.material = t.material, t.convexPolyhedronRepresentation.collisionResponse = t.collisionResponse, this.planeConvex(e, t.convexPolyhedronRepresentation, i, r, n, a, o, s) }, new f), S = new f, M = new f, A = new f, R = (a.prototype[i.types.PLANE | i.types.CONVEXPOLYHEDRON] = a.prototype.planeConvex = function (e, t, i, r, n, a, o, s) { for (var l, c, h = _, u = S, d = (u.set(0, 0, 1), n.vmult(u, u), 0), p = M, f = 0; f !== t.vertices.length; f++)h.copy(t.vertices[f]), a.vmult(h, h), r.vadd(h, h), h.vsub(i, p), u.dot(p) <= 0 && (l = this.createContactEquation(o, s, e, t), c = A, u.mult(u.dot(p), c), h.vsub(c, c), c.vsub(i, l.ri), l.ni.copy(u), h.vsub(r, l.rj), l.ri.vadd(i, l.ri), l.ri.vsub(o.position, l.ri), l.rj.vadd(r, l.rj), l.rj.vsub(s.position, l.rj), this.result.push(l), d++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(l, this.frictionResult)); this.enableFrictionReduction && d && this.createFrictionFromAverage(d) }, new f), L = new f, P = (a.prototype[i.types.CONVEXPOLYHEDRON] = a.prototype.convexConvex = function (e, t, i, r, n, a, o, s, l, c, h, u) { var d = R; if (!(i.distanceTo(r) > e.boundingSphereRadius + t.boundingSphereRadius) && e.findSeparatingAxis(t, i, n, r, a, d, h, u)) { for (var p = [], f = L, m = (e.clipAgainstHull(i, n, t, r, a, d, -100, 100, p), 0), v = 0; v !== p.length; v++) { var g = this.createContactEquation(o, s, e, t, l, c), x = g.ri, y = g.rj; d.negate(g.ni), p[v].normal.negate(f), f.mult(p[v].depth, f), p[v].point.vadd(f, x), y.copy(p[v].point), x.vsub(i, x), y.vsub(r, y), x.vadd(i, x), x.vsub(o.position, x), y.vadd(r, y), y.vsub(s.position, y), this.result.push(g), m++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(g, this.frictionResult) } this.enableFrictionReduction && m && this.createFrictionFromAverage(m) } }, new f), ve = new f, ge = new f, xe = (a.prototype[i.types.PLANE | i.types.PARTICLE] = a.prototype.planeParticle = function (e, t, i, r, n, a, o, s) { var l = P, c = (l.set(0, 0, 1), o.quaternion.vmult(l, l), ve); r.vsub(o.position, c), l.dot(c) <= 0 && ((c = this.createContactEquation(s, o, t, e)).ni.copy(l), c.ni.negate(c.ni), c.ri.set(0, 0, 0), s = ge, l.mult(l.dot(r), s), r.vsub(s, s), c.rj.copy(s), this.result.push(c), this.createFrictionEquationsFromContact(c, this.frictionResult)) }, new f), x = (a.prototype[i.types.PARTICLE | i.types.SPHERE] = a.prototype.sphereParticle = function (e, t, i, r, n, a, o, s) { var l = xe; l.set(0, 0, 1), r.vsub(i, l), l.norm2() <= e.radius * e.radius && (r = this.createContactEquation(s, o, t, e), l.normalize(), r.rj.copy(l), r.rj.mult(e.radius, r.rj), r.ni.copy(l), r.ni.negate(r.ni), r.ri.set(0, 0, 0), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult)) }, new r), ye = new f, _e = (new f, new f), y = new f, be = new f, we = (a.prototype[i.types.PARTICLE | i.types.CONVEXPOLYHEDRON] = a.prototype.convexParticle = function (e, t, i, r, n, a, o, s) { var l = -1, c = _e, h = be, u = null, d = ye; if (d.copy(r), d.vsub(i, d), n.conjugate(x), x.vmult(d, d), e.pointIsInside(d)) { e.worldVerticesNeedsUpdate && e.computeWorldVertices(i, n), e.worldFaceNormalsNeedsUpdate && e.computeWorldFaceNormals(n); for (var p = 0, f = e.faces.length; p !== f; p++) { var m = [e.worldVertices[e.faces[p][0]]], v = e.worldFaceNormals[p], m = (r.vsub(m[0], y), -v.dot(y)); (null === u || Math.abs(m) < Math.abs(u)) && (u = m, l = p, c.copy(v)) } -1 !== l ? (d = this.createContactEquation(s, o, t, e), c.mult(u, h), h.vadd(r, h), h.vsub(i, h), d.rj.copy(h), c.negate(d.ni), d.ri.set(0, 0, 0), n = d.ri, t = d.rj, n.vadd(r, n), n.vsub(s.position, n), t.vadd(i, t), t.vsub(o.position, t), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult)) : console.warn("Point found inside convex, but did not find penetrating face!") } }, a.prototype[i.types.BOX | i.types.HEIGHTFIELD] = a.prototype.boxHeightfield = function (e, t, i, r, n, a, o, s) { e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexHeightfield(e.convexPolyhedronRepresentation, t, i, r, n, a, o, s) }, new f), Ee = new f, Te = [0], Se = (a.prototype[i.types.CONVEXPOLYHEDRON | i.types.HEIGHTFIELD] = a.prototype.convexHeightfield = function (e, t, i, r, n, a, o, s) { var l = t.data, c = t.elementSize, h = e.boundingSphereRadius, u = Ee, d = Te, p = we, f = (F.pointToLocalFrame(r, a, i, p), Math.floor((p.x - h) / c) - 1), m = Math.ceil((p.x + h) / c) + 1, v = Math.floor((p.y - h) / c) - 1, g = Math.ceil((p.y + h) / c) + 1; if (!(m < 0 || g < 0 || f > l.length || v > l[0].length || ((f = f < 0 ? 0 : f) >= l.length && (f = l.length - 1), (m = m < 0 ? 0 : m) >= l.length && (m = l.length - 1), (g = g < 0 ? 0 : g) >= l[0].length && (g = l[0].length - 1), (v = v < 0 ? 0 : v) >= l[0].length && (v = l[0].length - 1), t.getRectMinMax(f, v, m, g, c = []), l = c[0], p.z - h > c[1] || p.z + h < l))) for (var x = f; x < m; x++)for (var y = v; y < g; y++)t.getConvexTrianglePillar(x, y, !1), F.pointToWorldFrame(r, a, t.pillarOffset, u), i.distanceTo(u) < t.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && this.convexConvex(e, t.pillarConvex, i, u, n, a, o, s, null, null, d, null), t.getConvexTrianglePillar(x, y, !0), F.pointToWorldFrame(r, a, t.pillarOffset, u), i.distanceTo(u) < t.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && this.convexConvex(e, t.pillarConvex, i, u, n, a, o, s, null, null, d, null) }, new f), Me = new f; a.prototype[i.types.SPHERE | i.types.HEIGHTFIELD] = a.prototype.sphereHeightfield = function (e, t, i, r, n, a, o, s) { var l = t.data, c = e.radius, h = t.elementSize, u = Me, d = Se, p = (F.pointToLocalFrame(r, a, i, d), Math.floor((d.x - c) / h) - 1), f = Math.ceil((d.x + c) / h) + 1, m = Math.floor((d.y - c) / h) - 1, v = Math.ceil((d.y + c) / h) + 1; if (!(f < 0 || v < 0 || p > l.length || v > l[0].length || ((p = p < 0 ? 0 : p) >= l.length && (p = l.length - 1), (f = f < 0 ? 0 : f) >= l.length && (f = l.length - 1), (v = v < 0 ? 0 : v) >= l[0].length && (v = l[0].length - 1), (m = m < 0 ? 0 : m) >= l[0].length && (m = l[0].length - 1), t.getRectMinMax(p, m, f, v, h = []), l = h[0], d.z - c > h[1] || d.z + c < l))) for (var g = this.result, x = p; x < f; x++)for (var y = m; y < v; y++) { var _ = g.length; if (t.getConvexTrianglePillar(x, y, !1), F.pointToWorldFrame(r, a, t.pillarOffset, u), i.distanceTo(u) < t.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && this.sphereConvex(e, t.pillarConvex, i, u, n, a, o, s), t.getConvexTrianglePillar(x, y, !0), F.pointToWorldFrame(r, a, t.pillarOffset, u), i.distanceTo(u) < t.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && this.sphereConvex(e, t.pillarConvex, i, u, n, a, o, s), 2 < g.length - _) return } } }, { "../collision/AABB": 3, "../collision/Ray": 9, "../equations/ContactEquation": 19, "../equations/FrictionEquation": 21, "../math/Quaternion": 28, "../math/Transform": 29, "../math/Vec3": 30, "../shapes/ConvexPolyhedron": 38, "../shapes/Shape": 43, "../solver/Solver": 47, "../utils/Vec3Pool": 54 }], 56: [function (e, t, i) { t.exports = m; var $ = e("../shapes/Shape"), r = e("../math/Vec3"), t = e("../math/Quaternion"), n = e("../solver/GSSolver"), a = (e("../utils/Vec3Pool"), e("../equations/ContactEquation"), e("../equations/FrictionEquation"), e("./Narrowphase")), o = e("../utils/EventTarget"), s = e("../collision/ArrayCollisionMatrix"), l = e("../material/Material"), c = e("../material/ContactMaterial"), ee = e("../objects/Body"), h = e("../utils/TupleDictionary"), u = e("../collision/RaycastResult"), d = e("../collision/AABB"), p = e("../collision/Ray"), f = e("../collision/NaiveBroadphase"); function m() { o.apply(this), this.dt = -1, this.allowSleep = !1, this.contacts = [], this.frictionEquations = [], this.quatNormalizeSkip = 0, this.quatNormalizeFast = !1, this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new r, this.broadphase = new f, this.bodies = [], this.solver = new n, this.constraints = [], this.narrowphase = new a(this), this.collisionMatrix = new s, this.collisionMatrixPrevious = new s, this.materials = [], this.contactmaterials = [], this.contactMaterialTable = new h, this.defaultMaterial = new l("default"), this.defaultContactMaterial = new c(this.defaultMaterial, this.defaultMaterial, { friction: .3, restitution: 0 }), this.doProfiling = !1, this.profile = { solve: 0, makeContactConstraints: 0, broadphase: 0, integrate: 0, narrowphase: 0 }, this.subsystems = [], this.addBodyEvent = { type: "addBody", body: null }, this.removeBodyEvent = { type: "removeBody", body: null } } m.prototype = new o, new d; var v, g = new p, x = (m.prototype.getContactMaterial = function (e, t) { return this.contactMaterialTable.get(e.id, t.id) }, m.prototype.numObjects = function () { return this.bodies.length }, m.prototype.collisionMatrixTick = function () { var e = this.collisionMatrixPrevious; this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = e, this.collisionMatrix.reset() }, m.prototype.add = m.prototype.addBody = function (e) { -1 === this.bodies.indexOf(e) && (e.index = this.bodies.length, this.bodies.push(e), e.world = this, e.initPosition.copy(e.position), e.initVelocity.copy(e.velocity), e.timeLastSleepy = this.time, e instanceof ee && (e.initAngularVelocity.copy(e.angularVelocity), e.initQuaternion.copy(e.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = e, this.dispatchEvent(this.addBodyEvent)) }, m.prototype.addConstraint = function (e) { this.constraints.push(e) }, m.prototype.removeConstraint = function (e) { -1 !== (e = this.constraints.indexOf(e)) && this.constraints.splice(e, 1) }, m.prototype.rayTest = function (e, t, i) { i instanceof u ? this.raycastClosest(e, t, { skipBackfaces: !0 }, i) : this.raycastAll(e, t, { skipBackfaces: !0 }, i) }, m.prototype.raycastAll = function (e, t, i, r) { return i.mode = p.ALL, i.from = e, i.to = t, i.callback = r, g.intersectWorld(this, i) }, m.prototype.raycastAny = function (e, t, i, r) { return i.mode = p.ANY, i.from = e, i.to = t, i.result = r, g.intersectWorld(this, i) }, m.prototype.raycastClosest = function (e, t, i, r) { return i.mode = p.CLOSEST, i.from = e, i.to = t, i.result = r, g.intersectWorld(this, i) }, m.prototype.removeBody = m.prototype.remove = function (e) { e.world = null; var t = this.bodies.length - 1, i = this.bodies, r = i.indexOf(e); if (-1 !== r) { i.splice(r, 1); for (var n = 0; n !== i.length; n++)i[n].index = n; this.collisionMatrix.setNumObjects(t), this.removeBodyEvent.body = e, this.dispatchEvent(this.removeBodyEvent) } }, m.prototype.addMaterial = function (e) { this.materials.push(e) }, m.prototype.addContactMaterial = function (e) { this.contactmaterials.push(e), this.contactMaterialTable.set(e.materials[0].id, e.materials[1].id, e) }, (performance = "undefined" == typeof performance ? {} : performance).now || (v = Date.now(), performance.timing && performance.timing.navigationStart && (v = performance.timing.navigationStart), performance.now = function () { return Date.now() - v }), new r), te = (m.prototype.step = function (e, t, i) { if (i = i || 10, 0 === (t = t || 0)) this.internalStep(e), this.time += e; else { for (var r = Math.floor((this.time + t) / e) - Math.floor(this.time / e), r = Math.min(r, i), n = performance.now(), a = 0; a !== r && (this.internalStep(e), !(performance.now() - n > 1e3 * e)); a++); this.time += t; for (var o = this.time % e / e, s = x, l = this.bodies, c = 0; c !== l.length; c++) { var h = l[c]; h.type !== ee.STATIC && h.sleepState !== ee.SLEEPING ? (h.position.vsub(h.previousPosition, s), s.scale(o, s), h.position.vadd(s, h.interpolatedPosition)) : (h.interpolatedPosition.copy(h.position), h.interpolatedQuaternion.copy(h.quaternion)) } } }, { type: "postStep" }), ie = { type: "preStep" }, re = { type: "collide", body: null, contact: null }, ne = [], ae = [], oe = [], se = [], le = (new r, new r, new r, new r, new r, new r, new r, new r, new r, new t, new t), ce = new t, he = new r; m.prototype.internalStep = function (e) { this.dt = e; var t, i, r, n = this.contacts, a = oe, o = se, s = this.numObjects(), l = this.bodies, c = this.solver, h = this.gravity, u = this.doProfiling, d = this.profile, p = ee.DYNAMIC, f = this.constraints, m = ae, H = (h.norm(), h.x), B = h.y, U = h.z, v = 0; for (u && (t = performance.now()), v = 0; v !== s; v++)(b = l[v]).type & p && (i = b.force, r = b.mass, i.x += r * H, i.y += r * B, i.z += r * U); for (var v = 0, z = this.subsystems.length; v !== z; v++)this.subsystems[v].update(); u && (t = performance.now()), a.length = 0, o.length = 0, this.broadphase.collisionPairs(this, a, o), u && (d.broadphase = performance.now() - t); var g = f.length; for (v = 0; v !== g; v++)if (!(T = f[v]).collideConnected) for (var x = a.length - 1; 0 <= x; --x)(T.bodyA === a[x] && T.bodyB === o[x] || T.bodyB === a[x] && T.bodyA === o[x]) && (a.splice(x, 1), o.splice(x, 1)); this.collisionMatrixTick(), u && (t = performance.now()); var y = ne, O = n.length; for (v = 0; v !== O; v++)y.push(n[v]); n.length = 0; var V = this.frictionEquations.length; for (v = 0; v !== V; v++)m.push(this.frictionEquations[v]); for (this.frictionEquations.length = 0, this.narrowphase.getContacts(a, o, this, n, y, this.frictionEquations, m), u && (d.narrowphase = performance.now() - t), u && (t = performance.now()), v = 0; v < this.frictionEquations.length; v++)c.addEquation(this.frictionEquations[v]); for (var k = n.length, _ = 0; _ !== k; _++) { var b = (T = n[_]).bi, w = T.bj, E = (T.si, T.sj, b.material && w.material && this.getContactMaterial(b.material, w.material) || this.defaultContactMaterial); E.friction, b.material && w.material && (0 <= b.material.friction && 0 <= w.material.friction && (b.material.friction, w.material.friction), 0 <= b.material.restitution && 0 <= w.material.restitution && (T.restitution = b.material.restitution * w.material.restitution)), c.addEquation(T), b.allowSleep && b.type === ee.DYNAMIC && b.sleepState === ee.SLEEPING && w.sleepState === ee.AWAKE && w.type !== ee.STATIC && (E = w.velocity.norm2() + w.angularVelocity.norm2(), 2 * Math.pow(w.sleepSpeedLimit, 2) <= E && (b._wakeUpAfterNarrowphase = !0)), w.allowSleep && w.type === ee.DYNAMIC && w.sleepState === ee.SLEEPING && b.sleepState === ee.AWAKE && b.type !== ee.STATIC && (E = b.velocity.norm2() + b.angularVelocity.norm2(), 2 * Math.pow(b.sleepSpeedLimit, 2) <= E && (w._wakeUpAfterNarrowphase = !0)), this.collisionMatrix.set(b, w, !0), this.collisionMatrixPrevious.get(b, w) || (re.body = w, re.contact = T, b.dispatchEvent(re), re.body = b, w.dispatchEvent(re)) } for (u && (d.makeContactConstraints = performance.now() - t, t = performance.now()), v = 0; v !== s; v++)(b = l[v])._wakeUpAfterNarrowphase && (b.wakeUp(), b._wakeUpAfterNarrowphase = !1); var T, g = f.length; for (v = 0; v !== g; v++) { (T = f[v]).update(); for (var x = 0, G = T.equations.length; x !== G; x++) { var W = T.equations[x]; c.addEquation(W) } } c.solve(e, this), u && (d.solve = performance.now() - t), c.removeAllEquations(); var S, M, j = Math.pow; for (v = 0; v !== s; v++)(b = l[v]).type & p && (S = j(1 - b.linearDamping, e), (M = b.velocity).mult(S, M), (S = b.angularVelocity) && (M = j(1 - b.angularDamping, e), S.mult(M, S))); for (this.dispatchEvent(ie), v = 0; v !== s; v++)(b = l[v]).preStep && b.preStep.call(b); u && (t = performance.now()); var X = le, A = ce, h = this.stepnumber, q = ee.DYNAMIC | ee.KINEMATIC, Y = h % (this.quatNormalizeSkip + 1) == 0, Q = this.quatNormalizeFast, R = .5 * e; for ($.types.PLANE, $.types.CONVEXPOLYHEDRON, v = 0; v !== s; v++) { var L, P, C, F, D, Z, I = l[v], N = I.force, J = I.torque; I.type & q && I.sleepState !== ee.SLEEPING && (L = I.velocity, P = I.angularVelocity, C = I.position, F = I.quaternion, D = I.invMass, Z = I.invInertiaWorld, L.x += N.x * D * e, L.y += N.y * D * e, L.z += N.z * D * e, I.angularVelocity && (Z.vmult(J, he), he.mult(e, he), he.vadd(P, P)), C.x += L.x * e, C.y += L.y * e, C.z += L.z * e, I.angularVelocity && (X.set(P.x, P.y, P.z, 0), X.mult(F, A), F.x += R * A.x, F.y += R * A.y, F.z += R * A.z, F.w += R * A.w, Y && (Q ? F.normalizeFast() : F.normalize())), I.aabb && (I.aabbNeedsUpdate = !0), I.updateInertiaWorld && I.updateInertiaWorld()) } for (this.clearForces(), this.broadphase.dirty = !0, u && (d.integrate = performance.now() - t), this.time += e, this.stepnumber += 1, this.dispatchEvent(te), v = 0; v !== s; v++) { var K = (b = l[v]).postStep; K && K.call(b) } if (this.allowSleep) for (v = 0; v !== s; v++)l[v].sleepTick(this.time) }, m.prototype.clearForces = function () { for (var e = this.bodies, t = e.length, i = 0; i !== t; i++) { var r = e[i]; r.force, r.torque, r.force.set(0, 0, 0), r.torque.set(0, 0, 0) } } }, { "../collision/AABB": 3, "../collision/ArrayCollisionMatrix": 4, "../collision/NaiveBroadphase": 7, "../collision/Ray": 9, "../collision/RaycastResult": 10, "../equations/ContactEquation": 19, "../equations/FrictionEquation": 21, "../material/ContactMaterial": 24, "../material/Material": 25, "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/Body": 31, "../shapes/Shape": 43, "../solver/GSSolver": 46, "../utils/EventTarget": 49, "../utils/TupleDictionary": 52, "../utils/Vec3Pool": 54, "./Narrowphase": 55 }] }, {}, [2])(2) }), function (e, t) { "object" == typeof exports ? module.exports = exports = t() : "function" == typeof define && define.amd ? define([], t) : e.CryptoJS = t() }(this, function () { c = Math, H = Object.create || function (e) { return Pe.prototype = e, e = new Pe, Pe.prototype = null, e }, w = (f = {}).lib = {}, t = w.Base = { extend: function (e) { var t = H(this); return e && t.mixIn(e), t.hasOwnProperty("init") && this.init !== t.init || (t.init = function () { t.$super.init.apply(this, arguments) }), (t.init.prototype = t).$super = this, t }, create: function () { var e = this.extend(); return e.init.apply(e, arguments), e }, init: function () { }, mixIn: function (e) { for (var t in e) e.hasOwnProperty(t) && (this[t] = e[t]); e.hasOwnProperty("toString") && (this.toString = e.toString) }, clone: function () { return this.init.prototype.extend(this) } }, h = w.WordArray = t.extend({ init: function (e, t) { e = this.words = e || [], this.sigBytes = null != t ? t : 4 * e.length }, toString: function (e) { return (e || B).stringify(this) }, concat: function (e) { var t = this.words, i = e.words, r = this.sigBytes, n = e.sigBytes; if (this.clamp(), r % 4) for (var a = 0; a < n; a++) { var o = i[a >>> 2] >>> 24 - a % 4 * 8 & 255; t[r + a >>> 2] |= o << 24 - (r + a) % 4 * 8 } else for (a = 0; a < n; a += 4)t[r + a >>> 2] = i[a >>> 2]; return this.sigBytes += n, this }, clamp: function () { var e = this.words, t = this.sigBytes; e[t >>> 2] &= 4294967295 << 32 - t % 4 * 8, e.length = c.ceil(t / 4) }, clone: function () { var e = t.clone.call(this); return e.words = this.words.slice(0), e }, random: function (e) { for (var t = [], i = 0; i < e; i += 4) { var r = function (e) { var t = 987654321, i = 4294967295; return function () { return ((((t = 36969 * (65535 & t) + (t >> 16) & i) << 16) + (e = 18e3 * (65535 & e) + (e >> 16) & i) & i) / 4294967296 + .5) * (.5 < c.random() ? 1 : -1) } }(4294967296 * (n || c.random())), n = 987654071 * r(); t.push(4294967296 * r() | 0) } return new h.init(t, e) } }), m = f.enc = {}, B = m.Hex = { stringify: function (e) { for (var t = e.words, i = e.sigBytes, r = [], n = 0; n < i; n++) { var a = t[n >>> 2] >>> 24 - n % 4 * 8 & 255; r.push((a >>> 4).toString(16)), r.push((15 & a).toString(16)) } return r.join("") }, parse: function (e) { for (var t = e.length, i = [], r = 0; r < t; r += 2)i[r >>> 3] |= parseInt(e.substr(r, 2), 16) << 24 - r % 8 * 4; return new h.init(i, t / 2) } }, U = m.Latin1 = { stringify: function (e) { for (var t = e.words, i = e.sigBytes, r = [], n = 0; n < i; n++) { var a = t[n >>> 2] >>> 24 - n % 4 * 8 & 255; r.push(String.fromCharCode(a)) } return r.join("") }, parse: function (e) { for (var t = e.length, i = [], r = 0; r < t; r++)i[r >>> 2] |= (255 & e.charCodeAt(r)) << 24 - r % 4 * 8; return new h.init(i, t) } }, z = m.Utf8 = { stringify: function (e) { try { return decodeURIComponent(escape(U.stringify(e))) } catch (e) { throw new Error("Malformed UTF-8 data") } }, parse: function (e) { return U.parse(unescape(encodeURIComponent(e))) } }, O = w.BufferedBlockAlgorithm = t.extend({ reset: function () { this._data = new h.init, this._nDataBytes = 0 }, _append: function (e) { "string" == typeof e && (e = z.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes }, _process: function (e) { var t = this._data, i = t.words, r = t.sigBytes, n = this.blockSize, a = r / (4 * n), o = (a = e ? c.ceil(a) : c.max((0 | a) - this._minBufferSize, 0)) * n, e = c.min(4 * o, r); if (o) { for (var s = 0; s < o; s += n)this._doProcessBlock(i, s); var l = i.splice(0, o); t.sigBytes -= e } return new h.init(l, e) }, clone: function () { var e = t.clone.call(this); return e._data = this._data.clone(), e }, _minBufferSize: 0 }), w.Hasher = O.extend({ cfg: t.extend(), init: function (e) { this.cfg = this.cfg.extend(e), this.reset() }, reset: function () { O.reset.call(this), this._doReset() }, update: function (e) { return this._append(e), this._process(), this }, finalize: function (e) { return e && this._append(e), this._doFinalize() }, blockSize: 16, _createHelper: function (i) { return function (e, t) { return new i.init(t).finalize(e) } }, _createHmacHelper: function (i) { return function (e, t) { return new Le.HMAC.init(i, t).finalize(e) } } }); var c, H, t, h, B, U, z, O, n, o, s, a, l, u, V, k, G, W, j, X, q, Y, Q, Z, J, K, $, ee, te, e, ie, re, ne, i, ae, oe, se, le, ce, he, ue, de, pe, fe, me, ve, r, ge, xe, ye, _e, be, we, Ee, Te, Se, Me, Ae, d, Re, Le = f.algo = {}, p = f; function Pe() { } Re = (m = p).lib.WordArray, m.enc.Base64 = { stringify: function (e) { var t = e.words, i = e.sigBytes, r = this._map; e.clamp(); for (var n = [], a = 0; a < i; a += 3)for (var o = (t[a >>> 2] >>> 24 - a % 4 * 8 & 255) << 16 | (t[a + 1 >>> 2] >>> 24 - (a + 1) % 4 * 8 & 255) << 8 | t[a + 2 >>> 2] >>> 24 - (a + 2) % 4 * 8 & 255, s = 0; s < 4 && a + .75 * s < i; s++)n.push(r.charAt(o >>> 6 * (3 - s) & 63)); var l = r.charAt(64); if (l) for (; n.length % 4;)n.push(l); return n.join("") }, parse: function (e) { var t = e.length, i = this._map; if (!(r = this._reverseMap)) for (var r = this._reverseMap = [], n = 0; n < i.length; n++)r[i.charCodeAt(n)] = n; for (var a, o, s = i.charAt(64), l = (s && -1 !== (s = e.indexOf(s)) && (t = s), e), c = t, h = r, u = [], d = 0, p = 0; p < c; p++)p % 4 && (a = h[l.charCodeAt(p - 1)] << p % 4 * 2, o = h[l.charCodeAt(p)] >>> 6 - p % 4 * 2, u[d >>> 2] |= (a | o) << 24 - d % 4 * 8, d++); return Re.create(u, d) }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" }; var Ce = Math; function M(e, t, i, r, n, a, o) { return ((e = e + (t & i | ~t & r) + n + o) << a | e >>> 32 - a) + t } function A(e, t, i, r, n, a, o) { return ((e = e + (t & r | i & ~r) + n + o) << a | e >>> 32 - a) + t } function R(e, t, i, r, n, a, o) { return ((e = e + (t ^ i ^ r) + n + o) << a | e >>> 32 - a) + t } function L(e, t, i, r, n, a, o) { return ((e = e + (i ^ (t | ~r)) + n + o) << a | e >>> 32 - a) + t } for (var Fe = (f = (w = p).lib).WordArray, De = f.Hasher, f = w.algo, P = [], Ie = 0; Ie < 64; Ie++)P[Ie] = 4294967296 * Ce.abs(Ce.sin(Ie + 1)) | 0; f = f.MD5 = De.extend({ _doReset: function () { this._hash = new Fe.init([1732584193, 4023233417, 2562383102, 271733878]) }, _doProcessBlock: function (e, t) { for (var i = 0; i < 16; i++) { var r = t + i, n = e[r]; e[r] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8) } var a = this._hash.words, o = e[t + 0], s = e[t + 1], l = e[t + 2], c = e[t + 3], h = e[t + 4], u = e[t + 5], d = e[t + 6], p = e[t + 7], f = e[t + 8], m = e[t + 9], v = e[t + 10], g = e[t + 11], x = e[t + 12], y = e[t + 13], _ = e[t + 14], b = e[t + 15], w = M(a[0], S = a[1], T = a[2], E = a[3], o, 7, P[0]), E = M(E, w, S, T, s, 12, P[1]), T = M(T, E, w, S, l, 17, P[2]), S = M(S, T, E, w, c, 22, P[3]), w = M(w, S, T, E, h, 7, P[4]), E = M(E, w, S, T, u, 12, P[5]), T = M(T, E, w, S, d, 17, P[6]), S = M(S, T, E, w, p, 22, P[7]); w = M(w, S, T, E, f, 7, P[8]), E = M(E, w, S, T, m, 12, P[9]), T = M(T, E, w, S, v, 17, P[10]), S = M(S, T, E, w, g, 22, P[11]), w = M(w, S, T, E, x, 7, P[12]), E = M(E, w, S, T, y, 12, P[13]), T = M(T, E, w, S, _, 17, P[14]), w = A(w, S = M(S, T, E, w, b, 22, P[15]), T, E, s, 5, P[16]), E = A(E, w, S, T, d, 9, P[17]), T = A(T, E, w, S, g, 14, P[18]), S = A(S, T, E, w, o, 20, P[19]), w = A(w, S, T, E, u, 5, P[20]), E = A(E, w, S, T, v, 9, P[21]), T = A(T, E, w, S, b, 14, P[22]), S = A(S, T, E, w, h, 20, P[23]), w = A(w, S, T, E, m, 5, P[24]), E = A(E, w, S, T, _, 9, P[25]), T = A(T, E, w, S, c, 14, P[26]), S = A(S, T, E, w, f, 20, P[27]), w = A(w, S, T, E, y, 5, P[28]), E = A(E, w, S, T, l, 9, P[29]), T = A(T, E, w, S, p, 14, P[30]), w = R(w, S = A(S, T, E, w, x, 20, P[31]), T, E, u, 4, P[32]), E = R(E, w, S, T, f, 11, P[33]), T = R(T, E, w, S, g, 16, P[34]), S = R(S, T, E, w, _, 23, P[35]), w = R(w, S, T, E, s, 4, P[36]), E = R(E, w, S, T, h, 11, P[37]), T = R(T, E, w, S, p, 16, P[38]), S = R(S, T, E, w, v, 23, P[39]), w = R(w, S, T, E, y, 4, P[40]), E = R(E, w, S, T, o, 11, P[41]), T = R(T, E, w, S, c, 16, P[42]), S = R(S, T, E, w, d, 23, P[43]), w = R(w, S, T, E, m, 4, P[44]), E = R(E, w, S, T, x, 11, P[45]), T = R(T, E, w, S, b, 16, P[46]), w = L(w, S = R(S, T, E, w, l, 23, P[47]), T, E, o, 6, P[48]), E = L(E, w, S, T, p, 10, P[49]), T = L(T, E, w, S, _, 15, P[50]), S = L(S, T, E, w, u, 21, P[51]), w = L(w, S, T, E, x, 6, P[52]), E = L(E, w, S, T, c, 10, P[53]), T = L(T, E, w, S, v, 15, P[54]), S = L(S, T, E, w, s, 21, P[55]), w = L(w, S, T, E, f, 6, P[56]), E = L(E, w, S, T, b, 10, P[57]), T = L(T, E, w, S, d, 15, P[58]), S = L(S, T, E, w, y, 21, P[59]), w = L(w, S, T, E, h, 6, P[60]), E = L(E, w, S, T, g, 10, P[61]), T = L(T, E, w, S, l, 15, P[62]), S = L(S, T, E, w, m, 21, P[63]), a[0] = a[0] + w | 0, a[1] = a[1] + S | 0, a[2] = a[2] + T | 0, a[3] = a[3] + E | 0 }, _doFinalize: function () { var e = this._data, t = e.words, i = 8 * this._nDataBytes, r = 8 * e.sigBytes, n = (t[r >>> 5] |= 128 << 24 - r % 32, Ce.floor(i / 4294967296)); t[15 + (64 + r >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8), t[14 + (64 + r >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8), e.sigBytes = 4 * (t.length + 1), this._process(); for (var a = (n = this._hash).words, o = 0; o < 4; o++) { var s = a[o]; a[o] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8) } return n }, clone: function () { var e = De.clone.call(this); return e._hash = this._hash.clone(), e } }), w.MD5 = De._createHelper(f), w.HmacMD5 = De._createHmacHelper(f), w = (m = p).lib, Me = w.WordArray, Ae = w.Hasher, w = m.algo, d = [], w = w.SHA1 = Ae.extend({ _doReset: function () { this._hash = new Me.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (e, t) { for (var i = this._hash.words, r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = 0; l < 80; l++) { l < 16 ? d[l] = 0 | e[t + l] : (c = d[l - 3] ^ d[l - 8] ^ d[l - 14] ^ d[l - 16], d[l] = c << 1 | c >>> 31); var c = (r << 5 | r >>> 27) + s + d[l]; c += l < 20 ? 1518500249 + (n & a | ~n & o) : l < 40 ? 1859775393 + (n ^ a ^ o) : l < 60 ? (n & a | n & o | a & o) - 1894007588 : (n ^ a ^ o) - 899497514, s = o, o = a, a = n << 30 | n >>> 2, n = r, r = c } i[0] = i[0] + r | 0, i[1] = i[1] + n | 0, i[2] = i[2] + a | 0, i[3] = i[3] + o | 0, i[4] = i[4] + s | 0 }, _doFinalize: function () { var e = this._data, t = e.words, i = 8 * this._nDataBytes, r = 8 * e.sigBytes; return t[r >>> 5] |= 128 << 24 - r % 32, t[14 + (64 + r >>> 9 << 4)] = Math.floor(i / 4294967296), t[15 + (64 + r >>> 9 << 4)] = i, e.sigBytes = 4 * t.length, this._process(), this._hash }, clone: function () { var e = Ae.clone.call(this); return e._hash = this._hash.clone(), e } }), m.SHA1 = Ae._createHelper(w), m.HmacSHA1 = Ae._createHmacHelper(w); var Ne = Math, He = (m = (f = p).lib).WordArray, Be = m.Hasher, m = f.algo, Ue = [], ze = []; function Oe(e) { return 4294967296 * (e - (0 | e)) | 0 } for (var Ve = 2, ke = 0; ke < 64;)!function (e) { for (var t = Ne.sqrt(e), i = 2; i <= t; i++)if (!(e % i)) return; return 1 }(Ve) || (ke < 8 && (Ue[ke] = Oe(Ne.pow(Ve, .5))), ze[ke] = Oe(Ne.pow(Ve, 1 / 3)), ke++), Ve++; for (var v = [], m = m.SHA256 = Be.extend({ _doReset: function () { this._hash = new He.init(Ue.slice(0)) }, _doProcessBlock: function (e, t) { for (var i = this._hash.words, r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = i[5], c = i[6], h = i[7], u = 0; u < 64; u++) { u < 16 ? v[u] = 0 | e[t + u] : (d = v[u - 15], p = v[u - 2], v[u] = ((d << 25 | d >>> 7) ^ (d << 14 | d >>> 18) ^ d >>> 3) + v[u - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + v[u - 16]); var d = r & n ^ r & a ^ n & a, p = h + ((s << 26 | s >>> 6) ^ (s << 21 | s >>> 11) ^ (s << 7 | s >>> 25)) + (s & l ^ ~s & c) + ze[u] + v[u], h = c, c = l, l = s, s = o + p | 0, o = a, a = n, n = r, r = p + (((r << 30 | r >>> 2) ^ (r << 19 | r >>> 13) ^ (r << 10 | r >>> 22)) + d) | 0 } i[0] = i[0] + r | 0, i[1] = i[1] + n | 0, i[2] = i[2] + a | 0, i[3] = i[3] + o | 0, i[4] = i[4] + s | 0, i[5] = i[5] + l | 0, i[6] = i[6] + c | 0, i[7] = i[7] + h | 0 }, _doFinalize: function () { var e = this._data, t = e.words, i = 8 * this._nDataBytes, r = 8 * e.sigBytes; return t[r >>> 5] |= 128 << 24 - r % 32, t[14 + (64 + r >>> 9 << 4)] = Ne.floor(i / 4294967296), t[15 + (64 + r >>> 9 << 4)] = i, e.sigBytes = 4 * t.length, this._process(), this._hash }, clone: function () { var e = Be.clone.call(this); return e._hash = this._hash.clone(), e } }), Ge = (f.SHA256 = Be._createHelper(m), f.HmacSHA256 = Be._createHmacHelper(m), Se = (w = p).lib.WordArray, (w = w.enc).Utf16 = w.Utf16BE = { stringify: function (e) { for (var t = e.words, i = e.sigBytes, r = [], n = 0; n < i; n += 2) { var a = t[n >>> 2] >>> 16 - n % 4 * 8 & 65535; r.push(String.fromCharCode(a)) } return r.join("") }, parse: function (e) { for (var t = e.length, i = [], r = 0; r < t; r++)i[r >>> 1] |= e.charCodeAt(r) << 16 - r % 2 * 16; return Se.create(i, 2 * t) } }, w.Utf16LE = { stringify: function (e) { for (var t = e.words, i = e.sigBytes, r = [], n = 0; n < i; n += 2) { var a = Nt(t[n >>> 2] >>> 16 - n % 4 * 8 & 65535); r.push(String.fromCharCode(a)) } return r.join("") }, parse: function (e) { for (var t = e.length, i = [], r = 0; r < t; r++)i[r >>> 1] |= Nt(e.charCodeAt(r) << 16 - r % 2 * 16); return Se.create(i, 2 * t) } }, "function" == typeof ArrayBuffer && (f = p.lib.WordArray, Te = f.init, (f.init = function (e) { if ((e = (e = e instanceof ArrayBuffer ? new Uint8Array(e) : e) instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e) instanceof Uint8Array) { for (var t = e.byteLength, i = [], r = 0; r < t; r++)i[r >>> 2] |= e[r] << 24 - r % 4 * 8; Te.call(this, i, t) } else Te.apply(this, arguments) }).prototype = f), Math, w = (m = p).lib, r = w.WordArray, ge = w.Hasher, w = m.algo, xe = r.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]), ye = r.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]), _e = r.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]), be = r.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]), we = r.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), Ee = r.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), w = w.RIPEMD160 = ge.extend({ _doReset: function () { this._hash = r.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (e, t) { for (var i = 0; i < 16; i++) { var r = t + i, n = e[r]; e[r] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8) } for (var a, o, s, l, c, h, u = this._hash.words, d = we.words, p = Ee.words, f = xe.words, m = ye.words, v = _e.words, g = be.words, x = a = u[0], y = o = u[1], _ = s = u[2], b = l = u[3], w = c = u[4], i = 0; i < 80; i += 1)h = (h = It(h = (h = a + e[t + f[i]] | 0) + (i < 16 ? (o ^ s ^ l) + d[0] : i < 32 ? Ft(o, s, l) + d[1] : i < 48 ? ((o | ~s) ^ l) + d[2] : i < 64 ? Dt(o, s, l) + d[3] : (o ^ (s | ~l)) + d[4]) | 0, v[i])) + c | 0, a = c, c = l, l = It(s, 10), s = o, o = h, h = (h = It(h = (h = x + e[t + m[i]] | 0) + (i < 16 ? (y ^ (_ | ~b)) + p[0] : i < 32 ? Dt(y, _, b) + p[1] : i < 48 ? ((y | ~_) ^ b) + p[2] : i < 64 ? Ft(y, _, b) + p[3] : (y ^ _ ^ b) + p[4]) | 0, g[i])) + w | 0, x = w, w = b, b = It(_, 10), _ = y, y = h; h = u[1] + s + b | 0, u[1] = u[2] + l + w | 0, u[2] = u[3] + c + x | 0, u[3] = u[4] + a + y | 0, u[4] = u[0] + o + _ | 0, u[0] = h }, _doFinalize: function () { var e = this._data, t = e.words, i = 8 * this._nDataBytes, r = 8 * e.sigBytes; t[r >>> 5] |= 128 << 24 - r % 32, t[14 + (64 + r >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8), e.sigBytes = 4 * (t.length + 1), this._process(); for (var n = (r = this._hash).words, a = 0; a < 5; a++) { var o = n[a]; n[a] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8) } return r }, clone: function () { var e = ge.clone.call(this); return e._hash = this._hash.clone(), e } }), m.RIPEMD160 = ge._createHelper(w), m.HmacRIPEMD160 = ge._createHmacHelper(w), m = (f = p).lib.Base, ve = f.enc.Utf8, f.algo.HMAC = m.extend({ init: function (e, t) { e = this._hasher = new e.init, "string" == typeof t && (t = ve.parse(t)); var i = e.blockSize, r = 4 * i; (t = t.sigBytes > r ? e.finalize(t) : t).clamp(); for (var e = this._oKey = t.clone(), t = this._iKey = t.clone(), n = e.words, a = t.words, o = 0; o < i; o++)n[o] ^= 1549556828, a[o] ^= 909522486; e.sigBytes = t.sigBytes = r, this.reset() }, reset: function () { var e = this._hasher; e.reset(), e.update(this._iKey) }, update: function (e) { return this._hasher.update(e), this }, finalize: function (e) { var t = this._hasher, e = t.finalize(e); return t.reset(), t.finalize(this._oKey.clone().concat(e)) } }), m = (f = (w = p).lib).Base, pe = f.WordArray, g = (f = w.algo).SHA1, fe = f.HMAC, me = f.PBKDF2 = m.extend({ cfg: m.extend({ keySize: 4, hasher: g, iterations: 1 }), init: function (e) { this.cfg = this.cfg.extend(e) }, compute: function (e, t) { for (var i = this.cfg, r = fe.create(i.hasher, e), n = pe.create(), a = pe.create([1]), o = n.words, s = a.words, l = i.keySize, c = i.iterations; o.length < l;) { var h = r.update(t).finalize(a); r.reset(); for (var u = h.words, d = u.length, p = h, f = 1; f < c; f++) { p = r.finalize(p), r.reset(); for (var m = p.words, v = 0; v < d; v++)u[v] ^= m[v] } n.concat(h), s[0]++ } return n.sigBytes = 4 * l, n } }), w.PBKDF2 = function (e, t, i) { return me.create(i).compute(e, t) }, g = (m = (f = p).lib).Base, ue = m.WordArray, w = (m = f.algo).MD5, de = m.EvpKDF = g.extend({ cfg: g.extend({ keySize: 4, hasher: w, iterations: 1 }), init: function (e) { this.cfg = this.cfg.extend(e) }, compute: function (e, t) { for (var i = this.cfg, r = i.hasher.create(), n = ue.create(), a = n.words, o = i.keySize, s = i.iterations; a.length < o;) { l && r.update(l); var l = r.update(e).finalize(t); r.reset(); for (var c = 1; c < s; c++)l = r.finalize(l), r.reset(); n.concat(l) } return n.sigBytes = 4 * o, n } }), f.EvpKDF = function (e, t, i) { return de.create(i).compute(e, t) }, ce = (m = p).lib.WordArray, g = m.algo, he = g.SHA256, g = g.SHA224 = he.extend({ _doReset: function () { this._hash = new ce.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]) }, _doFinalize: function () { var e = he._doFinalize.call(this); return e.sigBytes -= 4, e } }), m.SHA224 = he._createHelper(g), m.HmacSHA224 = he._createHmacHelper(g), f = (w = p).lib, se = f.Base, le = f.WordArray, (f = w.x64 = {}).Word = se.extend({ init: function (e, t) { this.high = e, this.low = t } }), f.WordArray = se.extend({ init: function (e, t) { e = this.words = e || [], this.sigBytes = null != t ? t : 8 * e.length }, toX32: function () { for (var e = this.words, t = e.length, i = [], r = 0; r < t; r++) { var n = e[r]; i.push(n.high), i.push(n.low) } return le.create(i, this.sigBytes) }, clone: function () { for (var e = se.clone.call(this), t = e.words = this.words.slice(0), i = t.length, r = 0; r < i; r++)t[r] = t[r].clone(); return e } }), Math), We = (g = (m = p).lib).WordArray, je = g.Hasher, Xe = m.x64.Word, g = m.algo, qe = [], Ye = [], Qe = [], x = 1, y = 0, Ze = 0; Ze < 24; Ze++) { qe[x + 5 * y] = (Ze + 1) * (Ze + 2) / 2 % 64; var Je = (2 * x + 3 * y) % 5, x = y % 5, y = Je } for (x = 0; x < 5; x++)for (y = 0; y < 5; y++)Ye[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5; for (var Ke = 1, $e = 0; $e < 24; $e++) { for (var et, tt = 0, it = 0, rt = 0; rt < 7; rt++)1 & Ke && ((et = (1 << rt) - 1) < 32 ? it ^= 1 << et : tt ^= 1 << et - 32), 128 & Ke ? Ke = Ke << 1 ^ 113 : Ke <<= 1; Qe[$e] = Xe.create(tt, it) } for (var C = [], nt = 0; nt < 25; nt++)C[nt] = Xe.create(); function _() { return b.create.apply(b, arguments) } g = g.SHA3 = je.extend({ cfg: je.cfg.extend({ outputLength: 512 }), _doReset: function () { for (var e = this._state = [], t = 0; t < 25; t++)e[t] = new Xe.init; this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32 }, _doProcessBlock: function (e, t) { for (var i = this._state, r = this.blockSize / 2, n = 0; n < r; n++) { var a = e[t + 2 * n], o = e[t + 2 * n + 1], a = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8); (w = i[n]).high ^= 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8), w.low ^= a } for (var s = 0; s < 24; s++) { for (var l = 0; l < 5; l++) { for (var c = 0, h = 0, u = 0; u < 5; u++)c ^= (w = i[l + 5 * u]).high, h ^= w.low; var d = C[l]; d.high = c, d.low = h } for (l = 0; l < 5; l++)for (var p = C[(l + 4) % 5], f = (m = C[(l + 1) % 5]).high, m = m.low, c = p.high ^ (f << 1 | m >>> 31), h = p.low ^ (m << 1 | f >>> 31), u = 0; u < 5; u++)(w = i[l + 5 * u]).high ^= c, w.low ^= h; for (var v = 1; v < 25; v++) { var g = (w = i[v]).high, x = w.low, y = qe[v]; h = y < 32 ? (c = g << y | x >>> 32 - y, x << y | g >>> 32 - y) : (c = x << y - 32 | g >>> 64 - y, g << y - 32 | x >>> 64 - y), (g = C[Ye[v]]).high = c, g.low = h } var _ = C[0], b = i[0]; for (_.high = b.high, _.low = b.low, l = 0; l < 5; l++)for (u = 0; u < 5; u++) { var w = i[v = l + 5 * u], E = C[v], T = C[(l + 1) % 5 + 5 * u], S = C[(l + 2) % 5 + 5 * u]; w.high = E.high ^ ~T.high & S.high, w.low = E.low ^ ~T.low & S.low } w = i[0], _ = Qe[s], w.high ^= _.high, w.low ^= _.low } }, _doFinalize: function () { var e = this._data, t = e.words, i = (this._nDataBytes, 8 * e.sigBytes), r = 32 * this.blockSize; t[i >>> 5] |= 1 << 24 - i % 32, t[(Ge.ceil((1 + i) / r) * r >>> 5) - 1] |= 128, e.sigBytes = 4 * t.length, this._process(); for (var n = this._state, a = (i = this.cfg.outputLength / 8) / 8, o = [], s = 0; s < a; s++) { var l = (c = n[s]).high, c = c.low, l = 16711935 & (l << 8 | l >>> 24) | 4278255360 & (l << 24 | l >>> 8); o.push(16711935 & (c << 8 | c >>> 24) | 4278255360 & (c << 24 | c >>> 8)), o.push(l) } return new We.init(o, i) }, clone: function () { for (var e = je.clone.call(this), t = e._state = this._state.slice(0), i = 0; i < 25; i++)t[i] = t[i].clone(); return e } }), m.SHA3 = je._createHelper(g), m.HmacSHA3 = je._createHmacHelper(g); for (var at = (w = p).lib.Hasher, b = (f = w.x64).Word, ot = f.WordArray, f = w.algo, st = [_(1116352408, 3609767458), _(1899447441, 602891725), _(3049323471, 3964484399), _(3921009573, 2173295548), _(961987163, 4081628472), _(1508970993, 3053834265), _(2453635748, 2937671579), _(2870763221, 3664609560), _(3624381080, 2734883394), _(310598401, 1164996542), _(607225278, 1323610764), _(1426881987, 3590304994), _(1925078388, 4068182383), _(2162078206, 991336113), _(2614888103, 633803317), _(3248222580, 3479774868), _(3835390401, 2666613458), _(4022224774, 944711139), _(264347078, 2341262773), _(604807628, 2007800933), _(770255983, 1495990901), _(1249150122, 1856431235), _(1555081692, 3175218132), _(1996064986, 2198950837), _(2554220882, 3999719339), _(2821834349, 766784016), _(2952996808, 2566594879), _(3210313671, 3203337956), _(3336571891, 1034457026), _(3584528711, 2466948901), _(113926993, 3758326383), _(338241895, 168717936), _(666307205, 1188179964), _(773529912, 1546045734), _(1294757372, 1522805485), _(1396182291, 2643833823), _(1695183700, 2343527390), _(1986661051, 1014477480), _(2177026350, 1206759142), _(2456956037, 344077627), _(2730485921, 1290863460), _(2820302411, 3158454273), _(3259730800, 3505952657), _(3345764771, 106217008), _(3516065817, 3606008344), _(3600352804, 1432725776), _(4094571909, 1467031594), _(275423344, 851169720), _(430227734, 3100823752), _(506948616, 1363258195), _(659060556, 3750685593), _(883997877, 3785050280), _(958139571, 3318307427), _(1322822218, 3812723403), _(1537002063, 2003034995), _(1747873779, 3602036899), _(1955562222, 1575990012), _(2024104815, 1125592928), _(2227730452, 2716904306), _(2361852424, 442776044), _(2428436474, 593698344), _(2756734187, 3733110249), _(3204031479, 2999351573), _(3329325298, 3815920427), _(3391569614, 3928383900), _(3515267271, 566280711), _(3940187606, 3454069534), _(4118630271, 4000239992), _(116418474, 1914138554), _(174292421, 2731055270), _(289380356, 3203993006), _(460393269, 320620315), _(685471733, 587496836), _(852142971, 1086792851), _(1017036298, 365543100), _(1126000580, 2618297676), _(1288033470, 3409855158), _(1501505948, 4234509866), _(1607167915, 987167468), _(1816402316, 1246189591)], lt = [], ct = 0; ct < 80; ct++)lt[ct] = _(); f = f.SHA512 = at.extend({ _doReset: function () { this._hash = new ot.init([new b.init(1779033703, 4089235720), new b.init(3144134277, 2227873595), new b.init(1013904242, 4271175723), new b.init(2773480762, 1595750129), new b.init(1359893119, 2917565137), new b.init(2600822924, 725511199), new b.init(528734635, 4215389547), new b.init(1541459225, 327033209)]) }, _doProcessBlock: function (H, B) { for (var e = (s = this._hash.words)[0], t = s[1], i = s[2], r = s[3], n = s[4], a = s[5], o = s[6], s = s[7], U = e.high, l = e.low, z = t.high, c = t.low, O = i.high, h = i.low, V = r.high, u = r.low, k = n.high, d = n.low, G = a.high, p = a.low, W = o.high, f = o.low, j = s.high, m = s.low, v = U, g = l, x = z, y = c, _ = O, b = h, X = V, w = u, E = k, T = d, q = G, S = p, Y = W, Q = f, Z = j, J = m, M = 0; M < 80; M++)var A, R, L = lt[M], P = (M < 16 ? (R = L.high = 0 | H[B + 2 * M], A = L.low = 0 | H[B + 2 * M + 1]) : (F = (I = lt[M - 15]).high, I = I.low, C = (P = lt[M - 2]).high, P = P.low, R = (R = (R = ((F >>> 1 | I << 31) ^ (F >>> 8 | I << 24) ^ F >>> 7) + (D = lt[M - 7]).high + ((A = (I = (I >>> 1 | F << 31) ^ (I >>> 8 | F << 24) ^ (I >>> 7 | F << 25)) + D.low) >>> 0 < I >>> 0 ? 1 : 0)) + ((C >>> 19 | P << 13) ^ (C << 3 | P >>> 29) ^ C >>> 6) + ((A += F = (P >>> 19 | C << 13) ^ (P << 3 | C >>> 29) ^ (P >>> 6 | C << 26)) >>> 0 < F >>> 0 ? 1 : 0)) + (D = lt[M - 16]).high + ((A += I = D.low) >>> 0 < I >>> 0 ? 1 : 0), L.high = R, L.low = A), E & q ^ ~E & Y), C = T & S ^ ~T & Q, F = v & x ^ v & _ ^ x & _, D = (g >>> 28 | v << 4) ^ (g << 30 | v >>> 2) ^ (g << 25 | v >>> 7), I = st[M], L = I.high, K = I.low, N = J + ((T >>> 14 | E << 18) ^ (T >>> 18 | E << 14) ^ (T << 23 | E >>> 9)), $ = Z + ((E >>> 14 | T << 18) ^ (E >>> 18 | T << 14) ^ (E << 23 | T >>> 9)) + (N >>> 0 < J >>> 0 ? 1 : 0), ee = D + (g & y ^ g & b ^ y & b), Z = Y, J = Q, Y = q, Q = S, q = E, S = T, E = X + ($ = $ + P + ((N += C) >>> 0 < C >>> 0 ? 1 : 0) + L + ((N += K) >>> 0 < K >>> 0 ? 1 : 0) + R + ((N += A) >>> 0 < A >>> 0 ? 1 : 0)) + ((T = w + N | 0) >>> 0 < w >>> 0 ? 1 : 0) | 0, X = _, w = b, _ = x, b = y, x = v, y = g, v = $ + (((v >>> 28 | g << 4) ^ (v << 30 | g >>> 2) ^ (v << 25 | g >>> 7)) + F + (ee >>> 0 < D >>> 0 ? 1 : 0)) + ((g = N + ee | 0) >>> 0 < N >>> 0 ? 1 : 0) | 0; l = e.low = l + g, e.high = U + v + (l >>> 0 < g >>> 0 ? 1 : 0), c = t.low = c + y, t.high = z + x + (c >>> 0 < y >>> 0 ? 1 : 0), h = i.low = h + b, i.high = O + _ + (h >>> 0 < b >>> 0 ? 1 : 0), u = r.low = u + w, r.high = V + X + (u >>> 0 < w >>> 0 ? 1 : 0), d = n.low = d + T, n.high = k + E + (d >>> 0 < T >>> 0 ? 1 : 0), p = a.low = p + S, a.high = G + q + (p >>> 0 < S >>> 0 ? 1 : 0), f = o.low = f + Q, o.high = W + Y + (f >>> 0 < Q >>> 0 ? 1 : 0), m = s.low = m + J, s.high = j + Z + (m >>> 0 < J >>> 0 ? 1 : 0) }, _doFinalize: function () { var e = this._data, t = e.words, i = 8 * this._nDataBytes, r = 8 * e.sigBytes; return t[r >>> 5] |= 128 << 24 - r % 32, t[30 + (128 + r >>> 10 << 5)] = Math.floor(i / 4294967296), t[31 + (128 + r >>> 10 << 5)] = i, e.sigBytes = 4 * t.length, this._process(), this._hash.toX32() }, clone: function () { var e = at.clone.call(this); return e._hash = this._hash.clone(), e }, blockSize: 32 }), w.SHA512 = at._createHelper(f), w.HmacSHA512 = at._createHmacHelper(f), g = (m = p).x64, i = g.Word, ae = g.WordArray, g = m.algo, oe = g.SHA512, g = g.SHA384 = oe.extend({ _doReset: function () { this._hash = new ae.init([new i.init(3418070365, 3238371032), new i.init(1654270250, 914150663), new i.init(2438529370, 812702999), new i.init(355462360, 4144912697), new i.init(1731405415, 4290775857), new i.init(2394180231, 1750603025), new i.init(3675008525, 1694076839), new i.init(1203062813, 3204075428)]) }, _doFinalize: function () { var e = oe._doFinalize.call(this); return e.sigBytes -= 16, e } }), m.SHA384 = oe._createHelper(g), m.HmacSHA384 = oe._createHmacHelper(g), p.lib.Cipher || (m = (f = (w = p).lib).Base, J = f.WordArray, K = f.BufferedBlockAlgorithm, (g = w.enc).Utf8, $ = g.Base64, ee = w.algo.EvpKDF, te = f.Cipher = K.extend({ cfg: m.extend(), createEncryptor: function (e, t) { return this.create(this._ENC_XFORM_MODE, e, t) }, createDecryptor: function (e, t) { return this.create(this._DEC_XFORM_MODE, e, t) }, init: function (e, t, i) { this.cfg = this.cfg.extend(i), this._xformMode = e, this._key = t, this.reset() }, reset: function () { K.reset.call(this), this._doReset() }, process: function (e) { return this._append(e), this._process() }, finalize: function (e) { return e && this._append(e), this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function (r) { return { encrypt: function (e, t, i) { return Ct(t).encrypt(r, e, t, i) }, decrypt: function (e, t, i) { return Ct(t).decrypt(r, e, t, i) } } } }), f.StreamCipher = te.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }), g = w.mode = {}, e = f.BlockCipherMode = m.extend({ createEncryptor: function (e, t) { return this.Encryptor.create(e, t) }, createDecryptor: function (e, t) { return this.Decryptor.create(e, t) }, init: function (e, t) { this._cipher = e, this._iv = t } }), e = g.CBC = ((g = e.extend()).Encryptor = g.extend({ processBlock: function (e, t) { var i = this._cipher, r = i.blockSize; Pt.call(this, e, t, r), i.encryptBlock(e, t), this._prevBlock = e.slice(t, t + r) } }), g.Decryptor = g.extend({ processBlock: function (e, t) { var i = this._cipher, r = i.blockSize, n = e.slice(t, t + r); i.decryptBlock(e, t), Pt.call(this, e, t, r), this._prevBlock = n } }), g), g = (w.pad = {}).Pkcs7 = { pad: function (e, t) { for (var i = (t *= 4) - e.sigBytes % t, r = i << 24 | i << 16 | i << 8 | i, n = [], a = 0; a < i; a += 4)n.push(r); t = J.create(n, i), e.concat(t) }, unpad: function (e) { var t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }, f.BlockCipher = te.extend({ cfg: te.cfg.extend({ mode: e, padding: g }), reset: function () { te.reset.call(this); var e, t = (i = this.cfg).iv, i = i.mode; this._xformMode == this._ENC_XFORM_MODE ? e = i.createEncryptor : (e = i.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == e ? this._mode.init(this, t && t.words) : (this._mode = e.call(i, this, t && t.words), this._mode.__creator = e) }, _doProcessBlock: function (e, t) { this._mode.processBlock(e, t) }, _doFinalize: function () { var e, t = this.cfg.padding; return this._xformMode == this._ENC_XFORM_MODE ? (t.pad(this._data, this.blockSize), e = this._process(!0)) : (e = this._process(!0), t.unpad(e)), e }, blockSize: 4 }), ie = f.CipherParams = m.extend({ init: function (e) { this.mixIn(e) }, toString: function (e) { return (e || this.formatter).stringify(this) } }), e = (w.format = {}).OpenSSL = { stringify: function (e) { var t = e.ciphertext; return ((e = e.salt) ? J.create([1398893684, 1701076831]).concat(e).concat(t) : t).toString($) }, parse: function (e) { var t, i = (e = $.parse(e)).words; return 1398893684 == i[0] && 1701076831 == i[1] && (t = J.create(i.slice(2, 4)), i.splice(0, 4), e.sigBytes -= 16), ie.create({ ciphertext: e, salt: t }) } }, re = f.SerializableCipher = m.extend({ cfg: m.extend({ format: e }), encrypt: function (e, t, i, r) { r = this.cfg.extend(r); var t = (n = e.createEncryptor(i, r)).finalize(t), n = n.cfg; return ie.create({ ciphertext: t, key: i, iv: n.iv, algorithm: e, mode: n.mode, padding: n.padding, blockSize: e.blockSize, formatter: r.format }) }, decrypt: function (e, t, i, r) { return r = this.cfg.extend(r), t = this._parse(t, r.format), e.createDecryptor(i, r).finalize(t.ciphertext) }, _parse: function (e, t) { return "string" == typeof e ? t.parse(e, this) : e } }), g = (w.kdf = {}).OpenSSL = { execute: function (e, t, i, r) { return r = r || J.random(8), e = ee.create({ keySize: t + i }).compute(e, r), i = J.create(e.words.slice(t), 4 * i), e.sigBytes = 4 * t, ie.create({ key: e, iv: i, salt: r }) } }, ne = f.PasswordBasedCipher = re.extend({ cfg: re.cfg.extend({ kdf: g }), encrypt: function (e, t, i, r) { return i = (r = this.cfg.extend(r)).kdf.execute(i, e.keySize, e.ivSize), r.iv = i.iv, (e = re.encrypt.call(this, e, t, i.key, r)).mixIn(i), e }, decrypt: function (e, t, i, r) { return r = this.cfg.extend(r), t = this._parse(t, r.format), i = r.kdf.execute(i, e.keySize, e.ivSize, t.salt), r.iv = i.iv, re.decrypt.call(this, e, t, i.key, r) } })), p.mode.CFB = ((m = p.lib.BlockCipherMode.extend()).Encryptor = m.extend({ processBlock: function (e, t) { var i = this._cipher, r = i.blockSize; Lt.call(this, e, t, r, i), this._prevBlock = e.slice(t, t + r) } }), m.Decryptor = m.extend({ processBlock: function (e, t) { var i = this._cipher, r = i.blockSize, n = e.slice(t, t + r); Lt.call(this, e, t, r, i), this._prevBlock = n } }), m), p.mode.ECB = ((e = p.lib.BlockCipherMode.extend()).Encryptor = e.extend({ processBlock: function (e, t) { this._cipher.encryptBlock(e, t) } }), e.Decryptor = e.extend({ processBlock: function (e, t) { this._cipher.decryptBlock(e, t) } }), e), p.pad.AnsiX923 = { pad: function (e, t) { var i = (i = e.sigBytes) + (t = (t *= 4) - i % t) - 1; e.clamp(), e.words[i >>> 2] |= t << 24 - i % 4 * 8, e.sigBytes += t }, unpad: function (e) { var t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }, p.pad.Iso10126 = { pad: function (e, t) { t = (t *= 4) - e.sigBytes % t, e.concat(p.lib.WordArray.random(t - 1)).concat(p.lib.WordArray.create([t << 24], 1)) }, unpad: function (e) { var t = 255 & e.words[e.sigBytes - 1 >>> 2]; e.sigBytes -= t } }, p.pad.Iso97971 = { pad: function (e, t) { e.concat(p.lib.WordArray.create([2147483648], 1)), p.pad.ZeroPadding.pad(e, t) }, unpad: function (e) { p.pad.ZeroPadding.unpad(e), e.sigBytes-- } }, p.mode.OFB = (f = (w = p.lib.BlockCipherMode.extend()).Encryptor = w.extend({ processBlock: function (e, t) { var i = this._cipher, r = i.blockSize, n = this._iv, a = this._keystream; n && (a = this._keystream = n.slice(0), this._iv = void 0), i.encryptBlock(a, 0); for (var o = 0; o < r; o++)e[t + o] ^= a[o] } }), w.Decryptor = f, w), p.pad.NoPadding = { pad: function () { }, unpad: function () { } }, Q = (g = p).lib.CipherParams, Z = g.enc.Hex, g.format.Hex = { stringify: function (e) { return e.ciphertext.toString(Z) }, parse: function (e) { return e = Z.parse(e), Q.create({ ciphertext: e }) } }; for (var f = (m = p).lib.BlockCipher, w = m.algo, E = [], ht = [], ut = [], dt = [], pt = [], ft = [], mt = [], vt = [], gt = [], xt = [], T = [], S = 0; S < 256; S++)T[S] = S < 128 ? S << 1 : S << 1 ^ 283; for (var F = 0, D = 0, S = 0; S < 256; S++) { var I = D ^ D << 1 ^ D << 2 ^ D << 3 ^ D << 4, yt = (E[F] = I = I >>> 8 ^ 255 & I ^ 99, T[ht[I] = F]), _t = T[yt], bt = T[_t], N = 257 * T[I] ^ 16843008 * I; ut[F] = N << 24 | N >>> 8, dt[F] = N << 16 | N >>> 16, pt[F] = N << 8 | N >>> 24, ft[F] = N, mt[I] = (N = 16843009 * bt ^ 65537 * _t ^ 257 * yt ^ 16843008 * F) << 24 | N >>> 8, vt[I] = N << 16 | N >>> 16, gt[I] = N << 8 | N >>> 24, xt[I] = N, F ? (F = yt ^ T[T[T[bt ^ yt]]], D ^= T[T[D]]) : F = D = 1 } var wt = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], w = w.AES = f.extend({ _doReset: function () { if (!this._nRounds || this._keyPriorReset !== this._key) { for (var e = this._keyPriorReset = this._key, t = e.words, i = e.sigBytes / 4, r = 4 * (1 + (this._nRounds = 6 + i)), n = this._keySchedule = [], a = 0; a < r; a++)a < i ? n[a] = t[a] : (l = n[a - 1], a % i ? 6 < i && a % i == 4 && (l = E[l >>> 24] << 24 | E[l >>> 16 & 255] << 16 | E[l >>> 8 & 255] << 8 | E[255 & l]) : (l = E[(l = l << 8 | l >>> 24) >>> 24] << 24 | E[l >>> 16 & 255] << 16 | E[l >>> 8 & 255] << 8 | E[255 & l], l ^= wt[a / i | 0] << 24), n[a] = n[a - i] ^ l); for (var o = this._invKeySchedule = [], s = 0; s < r; s++) { var a = r - s, l = s % 4 ? n[a] : n[a - 4]; o[s] = s < 4 || a <= 4 ? l : mt[E[l >>> 24]] ^ vt[E[l >>> 16 & 255]] ^ gt[E[l >>> 8 & 255]] ^ xt[E[255 & l]] } } }, encryptBlock: function (e, t) { this._doCryptBlock(e, t, this._keySchedule, ut, dt, pt, ft, E) }, decryptBlock: function (e, t) { var i = e[t + 1], i = (e[t + 1] = e[t + 3], e[t + 3] = i, this._doCryptBlock(e, t, this._invKeySchedule, mt, vt, gt, xt, ht), e[t + 1]); e[t + 1] = e[t + 3], e[t + 3] = i }, _doCryptBlock: function (e, t, i, r, n, a, o, s) { for (var l = this._nRounds, c = e[t] ^ i[0], h = e[t + 1] ^ i[1], u = e[t + 2] ^ i[2], d = e[t + 3] ^ i[3], p = 4, f = 1; f < l; f++)var m = r[c >>> 24] ^ n[h >>> 16 & 255] ^ a[u >>> 8 & 255] ^ o[255 & d] ^ i[p++], v = r[h >>> 24] ^ n[u >>> 16 & 255] ^ a[d >>> 8 & 255] ^ o[255 & c] ^ i[p++], g = r[u >>> 24] ^ n[d >>> 16 & 255] ^ a[c >>> 8 & 255] ^ o[255 & h] ^ i[p++], x = r[d >>> 24] ^ n[c >>> 16 & 255] ^ a[h >>> 8 & 255] ^ o[255 & u] ^ i[p++], c = m, h = v, u = g, d = x; m = (s[c >>> 24] << 24 | s[h >>> 16 & 255] << 16 | s[u >>> 8 & 255] << 8 | s[255 & d]) ^ i[p++], v = (s[h >>> 24] << 24 | s[u >>> 16 & 255] << 16 | s[d >>> 8 & 255] << 8 | s[255 & c]) ^ i[p++], g = (s[u >>> 24] << 24 | s[d >>> 16 & 255] << 16 | s[c >>> 8 & 255] << 8 | s[255 & h]) ^ i[p++], x = (s[d >>> 24] << 24 | s[c >>> 16 & 255] << 16 | s[h >>> 8 & 255] << 8 | s[255 & u]) ^ i[p++], e[t] = m, e[t + 1] = v, e[t + 2] = g, e[t + 3] = x }, keySize: 8 }); return m.AES = f._createHelper(w), m = (g = p).lib, k = m.WordArray, m = m.BlockCipher, f = g.algo, G = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4], W = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32], j = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], X = [{ 0: 8421888, 268435456: 32768, 536870912: 8421378, 805306368: 2, 1073741824: 512, 1342177280: 8421890, 1610612736: 8389122, 1879048192: 8388608, 2147483648: 514, 2415919104: 8389120, 2684354560: 33280, 2952790016: 8421376, 3221225472: 32770, 3489660928: 8388610, 3758096384: 0, 4026531840: 33282, 134217728: 0, 402653184: 8421890, 671088640: 33282, 939524096: 32768, 1207959552: 8421888, 1476395008: 512, 1744830464: 8421378, 2013265920: 2, 2281701376: 8389120, 2550136832: 33280, 2818572288: 8421376, 3087007744: 8389122, 3355443200: 8388610, 3623878656: 32770, 3892314112: 514, 4160749568: 8388608, 1: 32768, 268435457: 2, 536870913: 8421888, 805306369: 8388608, 1073741825: 8421378, 1342177281: 33280, 1610612737: 512, 1879048193: 8389122, 2147483649: 8421890, 2415919105: 8421376, 2684354561: 8388610, 2952790017: 33282, 3221225473: 514, 3489660929: 8389120, 3758096385: 32770, 4026531841: 0, 134217729: 8421890, 402653185: 8421376, 671088641: 8388608, 939524097: 512, 1207959553: 32768, 1476395009: 8388610, 1744830465: 2, 2013265921: 33282, 2281701377: 32770, 2550136833: 8389122, 2818572289: 514, 3087007745: 8421888, 3355443201: 8389120, 3623878657: 0, 3892314113: 33280, 4160749569: 8421378 }, { 0: 1074282512, 16777216: 16384, 33554432: 524288, 50331648: 1074266128, 67108864: 1073741840, 83886080: 1074282496, 100663296: 1073758208, 117440512: 16, 134217728: 540672, 150994944: 1073758224, 167772160: 1073741824, 184549376: 540688, 201326592: 524304, 218103808: 0, 234881024: 16400, 251658240: 1074266112, 8388608: 1073758208, 25165824: 540688, 41943040: 16, 58720256: 1073758224, 75497472: 1074282512, 92274688: 1073741824, 109051904: 524288, 125829120: 1074266128, 142606336: 524304, 159383552: 0, 176160768: 16384, 192937984: 1074266112, 209715200: 1073741840, 226492416: 540672, 243269632: 1074282496, 260046848: 16400, 268435456: 0, 285212672: 1074266128, 301989888: 1073758224, 318767104: 1074282496, 335544320: 1074266112, 352321536: 16, 369098752: 540688, 385875968: 16384, 402653184: 16400, 419430400: 524288, 436207616: 524304, 452984832: 1073741840, 469762048: 540672, 486539264: 1073758208, 503316480: 1073741824, 520093696: 1074282512, 276824064: 540688, 293601280: 524288, 310378496: 1074266112, 327155712: 16384, 343932928: 1073758208, 360710144: 1074282512, 377487360: 16, 394264576: 1073741824, 411041792: 1074282496, 427819008: 1073741840, 444596224: 1073758224, 461373440: 524304, 478150656: 0, 494927872: 16400, 511705088: 1074266128, 528482304: 540672 }, { 0: 260, 1048576: 0, 2097152: 67109120, 3145728: 65796, 4194304: 65540, 5242880: 67108868, 6291456: 67174660, 7340032: 67174400, 8388608: 67108864, 9437184: 67174656, 10485760: 65792, 11534336: 67174404, 12582912: 67109124, 13631488: 65536, 14680064: 4, 15728640: 256, 524288: 67174656, 1572864: 67174404, 2621440: 0, 3670016: 67109120, 4718592: 67108868, 5767168: 65536, 6815744: 65540, 7864320: 260, 8912896: 4, 9961472: 256, 11010048: 67174400, 12058624: 65796, 13107200: 65792, 14155776: 67109124, 15204352: 67174660, 16252928: 67108864, 16777216: 67174656, 17825792: 65540, 18874368: 65536, 19922944: 67109120, 20971520: 256, 22020096: 67174660, 23068672: 67108868, 24117248: 0, 25165824: 67109124, 26214400: 67108864, 27262976: 4, 28311552: 65792, 29360128: 67174400, 30408704: 260, 31457280: 65796, 32505856: 67174404, 17301504: 67108864, 18350080: 260, 19398656: 67174656, 20447232: 0, 21495808: 65540, 22544384: 67109120, 23592960: 256, 24641536: 67174404, 25690112: 65536, 26738688: 67174660, 27787264: 65796, 28835840: 67108868, 29884416: 67109124, 30932992: 67174400, 31981568: 4, 33030144: 65792 }, { 0: 2151682048, 65536: 2147487808, 131072: 4198464, 196608: 2151677952, 262144: 0, 327680: 4198400, 393216: 2147483712, 458752: 4194368, 524288: 2147483648, 589824: 4194304, 655360: 64, 720896: 2147487744, 786432: 2151678016, 851968: 4160, 917504: 4096, 983040: 2151682112, 32768: 2147487808, 98304: 64, 163840: 2151678016, 229376: 2147487744, 294912: 4198400, 360448: 2151682112, 425984: 0, 491520: 2151677952, 557056: 4096, 622592: 2151682048, 688128: 4194304, 753664: 4160, 819200: 2147483648, 884736: 4194368, 950272: 4198464, 1015808: 2147483712, 1048576: 4194368, 1114112: 4198400, 1179648: 2147483712, 1245184: 0, 1310720: 4160, 1376256: 2151678016, 1441792: 2151682048, 1507328: 2147487808, 1572864: 2151682112, 1638400: 2147483648, 1703936: 2151677952, 1769472: 4198464, 1835008: 2147487744, 1900544: 4194304, 1966080: 64, 2031616: 4096, 1081344: 2151677952, 1146880: 2151682112, 1212416: 0, 1277952: 4198400, 1343488: 4194368, 1409024: 2147483648, 1474560: 2147487808, 1540096: 64, 1605632: 2147483712, 1671168: 4096, 1736704: 2147487744, 1802240: 2151678016, 1867776: 4160, 1933312: 2151682048, 1998848: 4194304, 2064384: 4198464 }, { 0: 128, 4096: 17039360, 8192: 262144, 12288: 536870912, 16384: 537133184, 20480: 16777344, 24576: 553648256, 28672: 262272, 32768: 16777216, 36864: 537133056, 40960: 536871040, 45056: 553910400, 49152: 553910272, 53248: 0, 57344: 17039488, 61440: 553648128, 2048: 17039488, 6144: 553648256, 10240: 128, 14336: 17039360, 18432: 262144, 22528: 537133184, 26624: 553910272, 30720: 536870912, 34816: 537133056, 38912: 0, 43008: 553910400, 47104: 16777344, 51200: 536871040, 55296: 553648128, 59392: 16777216, 63488: 262272, 65536: 262144, 69632: 128, 73728: 536870912, 77824: 553648256, 81920: 16777344, 86016: 553910272, 90112: 537133184, 94208: 16777216, 98304: 553910400, 102400: 553648128, 106496: 17039360, 110592: 537133056, 114688: 262272, 118784: 536871040, 122880: 0, 126976: 17039488, 67584: 553648256, 71680: 16777216, 75776: 17039360, 79872: 537133184, 83968: 536870912, 88064: 17039488, 92160: 128, 96256: 553910272, 100352: 262272, 104448: 553910400, 108544: 0, 112640: 553648128, 116736: 16777344, 120832: 262144, 124928: 537133056, 129024: 536871040 }, { 0: 268435464, 256: 8192, 512: 270532608, 768: 270540808, 1024: 268443648, 1280: 2097152, 1536: 2097160, 1792: 268435456, 2048: 0, 2304: 268443656, 2560: 2105344, 2816: 8, 3072: 270532616, 3328: 2105352, 3584: 8200, 3840: 270540800, 128: 270532608, 384: 270540808, 640: 8, 896: 2097152, 1152: 2105352, 1408: 268435464, 1664: 268443648, 1920: 8200, 2176: 2097160, 2432: 8192, 2688: 268443656, 2944: 270532616, 3200: 0, 3456: 270540800, 3712: 2105344, 3968: 268435456, 4096: 268443648, 4352: 270532616, 4608: 270540808, 4864: 8200, 5120: 2097152, 5376: 268435456, 5632: 268435464, 5888: 2105344, 6144: 2105352, 6400: 0, 6656: 8, 6912: 270532608, 7168: 8192, 7424: 268443656, 7680: 270540800, 7936: 2097160, 4224: 8, 4480: 2105344, 4736: 2097152, 4992: 268435464, 5248: 268443648, 5504: 8200, 5760: 270540808, 6016: 270532608, 6272: 270540800, 6528: 270532616, 6784: 8192, 7040: 2105352, 7296: 2097160, 7552: 0, 7808: 268435456, 8064: 268443656 }, { 0: 1048576, 16: 33555457, 32: 1024, 48: 1049601, 64: 34604033, 80: 0, 96: 1, 112: 34603009, 128: 33555456, 144: 1048577, 160: 33554433, 176: 34604032, 192: 34603008, 208: 1025, 224: 1049600, 240: 33554432, 8: 34603009, 24: 0, 40: 33555457, 56: 34604032, 72: 1048576, 88: 33554433, 104: 33554432, 120: 1025, 136: 1049601, 152: 33555456, 168: 34603008, 184: 1048577, 200: 1024, 216: 34604033, 232: 1, 248: 1049600, 256: 33554432, 272: 1048576, 288: 33555457, 304: 34603009, 320: 1048577, 336: 33555456, 352: 34604032, 368: 1049601, 384: 1025, 400: 34604033, 416: 1049600, 432: 1, 448: 0, 464: 34603008, 480: 33554433, 496: 1024, 264: 1049600, 280: 33555457, 296: 34603009, 312: 1, 328: 33554432, 344: 1048576, 360: 1025, 376: 34604032, 392: 33554433, 408: 34603008, 424: 0, 440: 34604033, 456: 1049601, 472: 1024, 488: 33555456, 504: 1048577 }, { 0: 134219808, 1: 131072, 2: 134217728, 3: 32, 4: 131104, 5: 134350880, 6: 134350848, 7: 2048, 8: 134348800, 9: 134219776, 10: 133120, 11: 134348832, 12: 2080, 13: 0, 14: 134217760, 15: 133152, 2147483648: 2048, 2147483649: 134350880, 2147483650: 134219808, 2147483651: 134217728, 2147483652: 134348800, 2147483653: 133120, 2147483654: 133152, 2147483655: 32, 2147483656: 134217760, 2147483657: 2080, 2147483658: 131104, 2147483659: 134350848, 2147483660: 0, 2147483661: 134348832, 2147483662: 134219776, 2147483663: 131072, 16: 133152, 17: 134350848, 18: 32, 19: 2048, 20: 134219776, 21: 134217760, 22: 134348832, 23: 131072, 24: 0, 25: 131104, 26: 134348800, 27: 134219808, 28: 134350880, 29: 133120, 30: 2080, 31: 134217728, 2147483664: 131072, 2147483665: 2048, 2147483666: 134348832, 2147483667: 133152, 2147483668: 32, 2147483669: 134348800, 2147483670: 134217728, 2147483671: 134219808, 2147483672: 134350880, 2147483673: 134217760, 2147483674: 134219776, 2147483675: 0, 2147483676: 133120, 2147483677: 2080, 2147483678: 131104, 2147483679: 134350848 }], q = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679], Y = f.DES = m.extend({ _doReset: function () { for (var e = this._key.words, t = [], i = 0; i < 56; i++) { var r = G[i] - 1; t[i] = e[r >>> 5] >>> 31 - r % 32 & 1 } for (var n = this._subKeys = [], a = 0; a < 16; a++) { for (var o = n[a] = [], s = j[a], i = 0; i < 24; i++)o[i / 6 | 0] |= t[(W[i] - 1 + s) % 28] << 31 - i % 6, o[4 + (i / 6 | 0)] |= t[28 + (W[i + 24] - 1 + s) % 28] << 31 - i % 6; for (o[0] = o[0] << 1 | o[0] >>> 31, i = 1; i < 7; i++)o[i] = o[i] >>> 4 * (i - 1) + 3; o[7] = o[7] << 5 | o[7] >>> 27 } for (var l = this._invSubKeys = [], i = 0; i < 16; i++)l[i] = n[15 - i] }, encryptBlock: function (e, t) { this._doCryptBlock(e, t, this._subKeys) }, decryptBlock: function (e, t) { this._doCryptBlock(e, t, this._invSubKeys) }, _doCryptBlock: function (e, t, i) { this._lBlock = e[t], this._rBlock = e[t + 1], At.call(this, 4, 252645135), At.call(this, 16, 65535), Rt.call(this, 2, 858993459), Rt.call(this, 8, 16711935), At.call(this, 1, 1431655765); for (var r = 0; r < 16; r++) { for (var n = i[r], a = this._lBlock, o = this._rBlock, s = 0, l = 0; l < 8; l++)s |= X[l][((o ^ n[l]) & q[l]) >>> 0]; this._lBlock = o, this._rBlock = a ^ s } var c = this._lBlock; this._lBlock = this._rBlock, this._rBlock = c, At.call(this, 1, 1431655765), Rt.call(this, 8, 16711935), Rt.call(this, 2, 858993459), At.call(this, 16, 65535), At.call(this, 4, 252645135), e[t] = this._lBlock, e[t + 1] = this._rBlock }, keySize: 2, ivSize: 2, blockSize: 2 }), g.DES = m._createHelper(Y), f = f.TripleDES = m.extend({ _doReset: function () { var e = this._key.words; this._des1 = Y.createEncryptor(k.create(e.slice(0, 2))), this._des2 = Y.createEncryptor(k.create(e.slice(2, 4))), this._des3 = Y.createEncryptor(k.create(e.slice(4, 6))) }, encryptBlock: function (e, t) { this._des1.encryptBlock(e, t), this._des2.decryptBlock(e, t), this._des3.encryptBlock(e, t) }, decryptBlock: function (e, t) { this._des3.decryptBlock(e, t), this._des2.encryptBlock(e, t), this._des1.decryptBlock(e, t) }, keySize: 6, ivSize: 2, blockSize: 2 }), g.TripleDES = m._createHelper(f), g = (w = p).lib.StreamCipher, m = w.algo, V = m.RC4 = g.extend({ _doReset: function () { for (var e = this._key, t = e.words, i = e.sigBytes, r = this._S = [], n = 0; n < 256; n++)r[n] = n; for (var n = 0, a = 0; n < 256; n++) { var o = t[(o = n % i) >>> 2] >>> 24 - o % 4 * 8 & 255, a = (a + r[n] + o) % 256, o = r[n]; r[n] = r[a], r[a] = o } this._i = this._j = 0 }, _doProcessBlock: function (e, t) { e[t] ^= Mt.call(this) }, keySize: 8, ivSize: 0 }), w.RC4 = g._createHelper(V), m = m.RC4Drop = V.extend({ cfg: V.cfg.extend({ drop: 192 }), _doReset: function () { V._doReset.call(this); for (var e = this.cfg.drop; 0 < e; e--)Mt.call(this) } }), w.RC4Drop = g._createHelper(m), p.mode.CTRGladman = (w = (f = p.lib.BlockCipherMode.extend()).Encryptor = f.extend({ processBlock: function (e, t) { var i = this._cipher, r = i.blockSize, n = this._iv, a = this._counter, o = (n && (a = this._counter = n.slice(0), this._iv = void 0), 0 === ((n = a)[0] = St(n[0])) && (n[1] = St(n[1])), a.slice(0)); i.encryptBlock(o, 0); for (var s = 0; s < r; s++)e[t + s] ^= o[s] } }), f.Decryptor = w, f), m = (g = p).lib.StreamCipher, w = g.algo, a = [], l = [], u = [], w = w.Rabbit = m.extend({ _doReset: function () { for (var e = this._key.words, t = this.cfg.iv, i = 0; i < 4; i++)e[i] = 16711935 & (e[i] << 8 | e[i] >>> 24) | 4278255360 & (e[i] << 24 | e[i] >>> 8); for (var r = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16], n = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]], i = this._b = 0; i < 4; i++)Tt.call(this); for (i = 0; i < 8; i++)n[i] ^= r[i + 4 & 7]; if (t) { var a = (t = t.words)[0], o = (a = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)) >>> 16 | 4294901760 & (t = 16711935 & ((t = t[1]) << 8 | t >>> 24) | 4278255360 & (t << 24 | t >>> 8)), s = t << 16 | 65535 & a; for (n[0] ^= a, n[1] ^= o, n[2] ^= t, n[3] ^= s, n[4] ^= a, n[5] ^= o, n[6] ^= t, n[7] ^= s, i = 0; i < 4; i++)Tt.call(this) } }, _doProcessBlock: function (e, t) { var i = this._X; Tt.call(this), a[0] = i[0] ^ i[5] >>> 16 ^ i[3] << 16, a[1] = i[2] ^ i[7] >>> 16 ^ i[5] << 16, a[2] = i[4] ^ i[1] >>> 16 ^ i[7] << 16, a[3] = i[6] ^ i[3] >>> 16 ^ i[1] << 16; for (var r = 0; r < 4; r++)a[r] = 16711935 & (a[r] << 8 | a[r] >>> 24) | 4278255360 & (a[r] << 24 | a[r] >>> 8), e[t + r] ^= a[r] }, blockSize: 4, ivSize: 2 }), g.Rabbit = m._createHelper(w), p.mode.CTR = (g = (f = p.lib.BlockCipherMode.extend()).Encryptor = f.extend({ processBlock: function (e, t) { var i = this._cipher, r = i.blockSize, n = this._iv, a = this._counter, o = (n && (a = this._counter = n.slice(0), this._iv = void 0), a.slice(0)); i.encryptBlock(o, 0), a[r - 1] = a[r - 1] + 1 | 0; for (var s = 0; s < r; s++)e[t + s] ^= o[s] } }), f.Decryptor = g, f), w = (m = p).lib.StreamCipher, g = m.algo, n = [], o = [], s = [], g = g.RabbitLegacy = w.extend({ _doReset: function () { for (var e = this._key.words, t = this.cfg.iv, i = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16], r = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]], n = this._b = 0; n < 4; n++)Et.call(this); for (n = 0; n < 8; n++)r[n] ^= i[n + 4 & 7]; if (t) { var a = (t = 16711935 & ((t = (e = t.words)[0]) << 8 | t >>> 24) | 4278255360 & (t << 24 | t >>> 8)) >>> 16 | 4294901760 & (e = 16711935 & ((e = e[1]) << 8 | e >>> 24) | 4278255360 & (e << 24 | e >>> 8)), o = e << 16 | 65535 & t; for (r[0] ^= t, r[1] ^= a, r[2] ^= e, r[3] ^= o, r[4] ^= t, r[5] ^= a, r[6] ^= e, r[7] ^= o, n = 0; n < 4; n++)Et.call(this) } }, _doProcessBlock: function (e, t) { var i = this._X; Et.call(this), n[0] = i[0] ^ i[5] >>> 16 ^ i[3] << 16, n[1] = i[2] ^ i[7] >>> 16 ^ i[5] << 16, n[2] = i[4] ^ i[1] >>> 16 ^ i[7] << 16, n[3] = i[6] ^ i[3] >>> 16 ^ i[1] << 16; for (var r = 0; r < 4; r++)n[r] = 16711935 & (n[r] << 8 | n[r] >>> 24) | 4278255360 & (n[r] << 24 | n[r] >>> 8), e[t + r] ^= n[r] }, blockSize: 4, ivSize: 2 }), m.RabbitLegacy = w._createHelper(g), p.pad.ZeroPadding = { pad: function (e, t) { t *= 4, e.clamp(), e.sigBytes += t - (e.sigBytes % t || t) }, unpad: function (e) { for (var t = e.words, i = e.sigBytes - 1; !(t[i >>> 2] >>> 24 - i % 4 * 8 & 255);)i--; e.sigBytes = i + 1 } }, p; function Et() { for (var e = this._X, t = this._C, i = 0; i < 8; i++)o[i] = t[i]; for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < o[7] >>> 0 ? 1 : 0, i = 0; i < 8; i++) { var r = e[i] + t[i], n = 65535 & r, a = r >>> 16; s[i] = ((n * n >>> 17) + n * a >>> 15) + a * a ^ ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0) } e[0] = s[0] + (s[7] << 16 | s[7] >>> 16) + (s[6] << 16 | s[6] >>> 16) | 0, e[1] = s[1] + (s[0] << 8 | s[0] >>> 24) + s[7] | 0, e[2] = s[2] + (s[1] << 16 | s[1] >>> 16) + (s[0] << 16 | s[0] >>> 16) | 0, e[3] = s[3] + (s[2] << 8 | s[2] >>> 24) + s[1] | 0, e[4] = s[4] + (s[3] << 16 | s[3] >>> 16) + (s[2] << 16 | s[2] >>> 16) | 0, e[5] = s[5] + (s[4] << 8 | s[4] >>> 24) + s[3] | 0, e[6] = s[6] + (s[5] << 16 | s[5] >>> 16) + (s[4] << 16 | s[4] >>> 16) | 0, e[7] = s[7] + (s[6] << 8 | s[6] >>> 24) + s[5] | 0 } function Tt() { for (var e = this._X, t = this._C, i = 0; i < 8; i++)l[i] = t[i]; for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < l[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < l[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < l[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < l[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < l[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < l[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < l[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < l[7] >>> 0 ? 1 : 0, i = 0; i < 8; i++) { var r = e[i] + t[i], n = 65535 & r, a = r >>> 16; u[i] = ((n * n >>> 17) + n * a >>> 15) + a * a ^ ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0) } e[0] = u[0] + (u[7] << 16 | u[7] >>> 16) + (u[6] << 16 | u[6] >>> 16) | 0, e[1] = u[1] + (u[0] << 8 | u[0] >>> 24) + u[7] | 0, e[2] = u[2] + (u[1] << 16 | u[1] >>> 16) + (u[0] << 16 | u[0] >>> 16) | 0, e[3] = u[3] + (u[2] << 8 | u[2] >>> 24) + u[1] | 0, e[4] = u[4] + (u[3] << 16 | u[3] >>> 16) + (u[2] << 16 | u[2] >>> 16) | 0, e[5] = u[5] + (u[4] << 8 | u[4] >>> 24) + u[3] | 0, e[6] = u[6] + (u[5] << 16 | u[5] >>> 16) + (u[4] << 16 | u[4] >>> 16) | 0, e[7] = u[7] + (u[6] << 8 | u[6] >>> 24) + u[5] | 0 } function St(e) { var t, i, r; return 255 == (e >> 24 & 255) ? (i = e >> 8 & 255, r = 255 & e, 255 == (t = e >> 16 & 255) ? (t = 0, 255 === i ? (i = 0, 255 === r ? r = 0 : ++r) : ++i) : ++t, e = 0, e = (e += t << 16) + (i << 8) + r) : e += 1 << 24, e } function Mt() { for (var e = this._S, t = this._i, i = this._j, r = 0, n = 0; n < 4; n++) { var i = (i + e[t = (t + 1) % 256]) % 256, a = e[t]; e[t] = e[i], e[i] = a, r |= e[(e[t] + e[i]) % 256] << 24 - 8 * n } return this._i = t, this._j = i, r } function At(e, t) { t = (this._lBlock >>> e ^ this._rBlock) & t, this._rBlock ^= t, this._lBlock ^= t << e } function Rt(e, t) { t = (this._rBlock >>> e ^ this._lBlock) & t, this._lBlock ^= t, this._rBlock ^= t << e } function Lt(e, t, i, r) { var n, a = this._iv; a ? (n = a.slice(0), this._iv = void 0) : n = this._prevBlock, r.encryptBlock(n, 0); for (var o = 0; o < i; o++)e[t + o] ^= n[o] } function Pt(e, t, i) { var r, n = this._iv; n ? (r = n, this._iv = void 0) : r = this._prevBlock; for (var a = 0; a < i; a++)e[t + a] ^= r[a] } function Ct(e) { return "string" == typeof e ? ne : re } function Ft(e, t, i) { return e & t | ~e & i } function Dt(e, t, i) { return e & i | t & ~i } function It(e, t) { return e << t | e >>> 32 - t } function Nt(e) { return e << 8 & 4278255360 | e >>> 8 & 16711935 } }), function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).THREE = {}) }(this, function (e) {
	"use strict"; const X = 100, A = 301, R = 302, L = 303, F = 304, D = 306, I = 307, z = 1e3, Ce = 1001, O = 1002, Ae = 1003, V = 1004, W = 1005, U = 1006, j = 1007, Fe = 1008, De = 1009, q = 1012, Y = 1014, Ie = 1015, Ne = 1016, Q = 1020, Z = 1022, He = 1023, J = 1026, K = 1027, N = 33776, H = 33777, B = 33778, $ = 33779, ee = 35840, te = 35841, ie = 35842, re = 35843, ne = 37492, ae = 37496, Be = 3e3, oe = 35044, se = 35048, le = "300 es"; class ce { addEventListener(e, t) { void 0 === this._listeners && (this._listeners = {}); const i = this._listeners; void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t) } hasEventListener(e, t) { if (void 0 === this._listeners) return !1; const i = this._listeners; return void 0 !== i[e] && -1 !== i[e].indexOf(t) } removeEventListener(e, t) { if (void 0 !== this._listeners) { const i = this._listeners[e]; if (void 0 !== i) { const e = i.indexOf(t); -1 !== e && i.splice(e, 1) } } } dispatchEvent(i) { if (void 0 !== this._listeners) { const e = this._listeners[i.type]; if (void 0 !== e) { i.target = this; const r = e.slice(0); for (let e = 0, t = r.length; e < t; e++)r[e].call(this, i); i.target = null } } } } const n = []; for (let e = 0; e < 256; e++)n[e] = (e < 16 ? "0" : "") + e.toString(16); let he = 1234567; const ue = Math.PI / 180, de = 180 / Math.PI; function pe() { var e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (n[255 & e] + n[e >> 8 & 255] + n[e >> 16 & 255] + n[e >> 24 & 255] + "-" + n[255 & t] + n[t >> 8 & 255] + "-" + n[t >> 16 & 15 | 64] + n[t >> 24 & 255] + "-" + n[63 & i | 128] + n[i >> 8 & 255] + "-" + n[i >> 16 & 255] + n[i >> 24 & 255] + n[255 & r] + n[r >> 8 & 255] + n[r >> 16 & 255] + n[r >> 24 & 255]).toUpperCase() } function f(e, t, i) { return Math.max(t, Math.min(i, e)) } function fe(e, t) { return (e % t + t) % t } function me(e, t, i) { return (1 - i) * e + i * t } function ve(e) { return 0 == (e & e - 1) && 0 !== e } function ge(e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) } function xe(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) } var ye = Object.freeze({ __proto__: null, DEG2RAD: ue, RAD2DEG: de, generateUUID: pe, clamp: f, euclideanModulo: fe, mapLinear: function (e, t, i, r, n) { return r + (e - t) * (n - r) / (i - t) }, inverseLerp: function (e, t, i) { return e !== t ? (i - e) / (t - e) : 0 }, lerp: me, damp: function (e, t, i, r) { return me(e, t, 1 - Math.exp(-i * r)) }, pingpong: function (e, t = 1) { return t - Math.abs(fe(e, 2 * t) - t) }, smoothstep: function (e, t, i) { return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, i) { return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, seededRandom: function (e) { return ((he = 16807 * (he = void 0 !== e ? e % 2147483647 : he) % 2147483647) - 1) / 2147483646 }, degToRad: function (e) { return e * ue }, radToDeg: function (e) { return e * de }, isPowerOfTwo: ve, ceilPowerOfTwo: ge, floorPowerOfTwo: xe, setQuaternionFromProperEuler: function (e, t, i, r, n) { const a = Math.cos, o = Math.sin, s = a(i / 2), l = o(i / 2), c = a((t + r) / 2), h = o((t + r) / 2), u = a((t - r) / 2), d = o((t - r) / 2), p = a((r - t) / 2), f = o((r - t) / 2); switch (n) { case "XYX": e.set(s * h, l * u, l * d, s * c); break; case "YZY": e.set(l * d, s * h, l * u, s * c); break; case "ZXZ": e.set(l * u, l * d, s * h, s * c); break; case "XZX": e.set(s * h, l * f, l * p, s * c); break; case "YXY": e.set(l * p, s * h, l * f, s * c); break; case "ZYZ": e.set(l * f, l * p, s * h, s * c); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n) } } }); class k { constructor(e = 0, t = 0) { this.x = e, this.y = t } get width() { return this.x } set width(e) { this.x = e } get height() { return this.y } set height(e) { this.y = e } set(e, t) { return this.x = e, this.y = t, this } setScalar(e) { return this.x = e, this.y = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y) } copy(e) { return this.x = e.x, this.y = e.y, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) } addScalar(e) { return this.x += e, this.y += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) } subScalar(e) { return this.x -= e, this.y -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this } divide(e) { return this.x /= e.x, this.y /= e.y, this } divideScalar(e) { return this.multiplyScalar(1 / e) } applyMatrix3(e) { var t = this.x, i = this.y, e = e.elements; return this.x = e[0] * t + e[3] * i + e[6], this.y = e[1] * t + e[4] * i + e[7], this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this } clampLength(e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate() { return this.x = -this.x, this.y = -this.y, this } dot(e) { return this.x * e.x + this.y * e.y } cross(e) { return this.x * e.y - this.y * e.x } lengthSq() { return this.x * this.x + this.y * this.y } length() { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) } normalize() { return this.divideScalar(this.length() || 1) } angle() { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { var t = this.x - e.x; return t * t + (e = this.y - e.y) * e } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this } equals(e) { return e.x === this.x && e.y === this.y } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e } fromBufferAttribute(e, t, i) { return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this } rotateAround(e, t) { var i = Math.cos(t), t = Math.sin(t), r = this.x - e.x, n = this.y - e.y; return this.x = r * i - n * t + e.x, this.y = r * t + n * i + e.y, this } random() { return this.x = Math.random(), this.y = Math.random(), this } } k.prototype.isVector2 = !0; class g { constructor() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } set(e, t, i, r, n, a, o, s, l) { const c = this.elements; return c[0] = e, c[1] = r, c[2] = o, c[3] = t, c[4] = n, c[5] = s, c[6] = i, c[7] = a, c[8] = l, this } identity() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this } extractBasis(e, t, i) { return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this } setFromMatrix4(e) { return e = e.elements, this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this } multiply(e) { return this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, t) { const i = e.elements, r = t.elements, n = this.elements, a = i[0], o = i[3], s = i[6], l = i[1], c = i[4], h = i[7], u = i[2], d = i[5], p = i[8], f = r[0], m = r[3], v = r[6], g = r[1], x = r[4], y = r[7], _ = r[2], b = r[5], w = r[8]; return n[0] = a * f + o * g + s * _, n[3] = a * m + o * x + s * b, n[6] = a * v + o * y + s * w, n[1] = l * f + c * g + h * _, n[4] = l * m + c * x + h * b, n[7] = l * v + c * y + h * w, n[2] = u * f + d * g + p * _, n[5] = u * m + d * x + p * b, n[8] = u * v + d * y + p * w, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this } determinant() { var e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], a = e[4], o = e[5], s = e[6], l = e[7]; return t * a * (e = e[8]) - t * o * l - i * n * e + i * o * s + r * n * l - r * a * s } invert() { const e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8], h = c * a - o * l, u = o * s - c * n, d = l * n - a * s, p = t * h + i * u + r * d; if (0 == p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); var f = 1 / p; return e[0] = h * f, e[1] = (r * l - c * i) * f, e[2] = (o * i - r * a) * f, e[3] = u * f, e[4] = (c * t - r * s) * f, e[5] = (r * n - o * t) * f, e[6] = d * f, e[7] = (i * s - l * t) * f, e[8] = (a * t - i * n) * f, this } transpose() { var e; const t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this } getNormalMatrix(e) { return this.setFromMatrix4(e).invert().transpose() } transposeIntoArray(e) { var t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this } setUvTransform(e, t, i, r, n, a, o) { var s = Math.cos(n), n = Math.sin(n); return this.set(i * s, i * n, -i * (s * a + n * o) + a + e, -r * n, r * s, -r * (-n * a + s * o) + o + t, 0, 0, 1), this } scale(e, t) { const i = this.elements; return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this } rotate(e) { const t = Math.cos(e), i = Math.sin(e), r = this.elements, n = r[0], a = r[3], o = r[6], s = r[1], l = r[4], c = r[7]; return r[0] = t * n + i * s, r[3] = t * a + i * l, r[6] = t * o + i * c, r[1] = -i * n + t * s, r[4] = -i * a + t * l, r[7] = -i * o + t * c, this } translate(e, t) { const i = this.elements; return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this } equals(e) { var t = this.elements, i = e.elements; for (let e = 0; e < 9; e++)if (t[e] !== i[e]) return !1; return !0 } fromArray(t, i = 0) { for (let e = 0; e < 9; e++)this.elements[e] = t[e + i]; return this } toArray(e = [], t = 0) { var i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e } clone() { return (new this.constructor).fromArray(this.elements) } } let _e; g.prototype.isMatrix3 = !0; class be { static getDataURL(e) { if (/^data:/i.test(e.src)) return e.src; if ("undefined" == typeof HTMLCanvasElement) return e.src; let t; if (e instanceof HTMLCanvasElement) t = e; else { (_e = void 0 === _e ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : _e).width = e.width, _e.height = e.height; const i = _e.getContext("2d"); e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = _e } return 2048 < t.width || 2048 < t.height ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png") } } let we = 0; class h extends ce { constructor(e = h.DEFAULT_IMAGE, t = h.DEFAULT_MAPPING, i = 1001, r = 1001, n = 1006, a = 1008, o = 1023, s = 1009, l = 1, c = 3e3) { super(), Object.defineProperty(this, "id", { value: we++ }), this.uuid = pe(), this.name = "", this.image = e, this.mipmaps = [], this.mapping = t, this.wrapS = i, this.wrapT = r, this.magFilter = n, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = s, this.offset = new k(0, 0), this.repeat = new k(1, 1), this.center = new k(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new g, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1 } updateMatrix() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this } toJSON(e) { var t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; const i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { const r = this.image; if (void 0 === r.uuid && (r.uuid = pe()), !t && void 0 === e.images[r.uuid]) { let i; if (Array.isArray(r)) { i = []; for (let e = 0, t = r.length; e < t; e++)r[e].isDataTexture ? i.push(Ee(r[e].image)) : i.push(Ee(r[e])) } else i = Ee(r); e.images[r.uuid] = { uuid: r.uuid, url: i } } i.image = r.uuid } return t || (e.textures[this.uuid] = i), i } dispose() { this.dispatchEvent({ type: "dispose" }) } transformUv(e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) { case z: e.x = e.x - Math.floor(e.x); break; case Ce: e.x = e.x < 0 ? 0 : 1; break; case O: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || 1 < e.y) switch (this.wrapT) { case z: e.y = e.y - Math.floor(e.y); break; case Ce: e.y = e.y < 0 ? 0 : 1; break; case O: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } set needsUpdate(e) { !0 === e && this.version++ } } function Ee(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? be.getDataURL(e) : e.data ? { data: Array.prototype.slice.call(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } h.DEFAULT_IMAGE = void 0, h.DEFAULT_MAPPING = 300, h.prototype.isTexture = !0; class Re { constructor(e = 0, t = 0, i = 0, r = 1) { this.x = e, this.y = t, this.z = i, this.w = r } get width() { return this.z } set width(e) { this.z = e } get height() { return this.w } set height(e) { this.w = e } set(e, t, i, r) { return this.x = e, this.y = t, this.z = i, this.w = r, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setW(e) { return this.w = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z, this.w) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this } multiply(e) { return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this } applyMatrix4(e) { var t = this.x, i = this.y, r = this.z, n = this.w, e = e.elements; return this.x = e[0] * t + e[4] * i + e[8] * r + e[12] * n, this.y = e[1] * t + e[5] * i + e[9] * r + e[13] * n, this.z = e[2] * t + e[6] * i + e[10] * r + e[14] * n, this.w = e[3] * t + e[7] * i + e[11] * r + e[15] * n, this } divideScalar(e) { return this.multiplyScalar(1 / e) } setAxisAngleFromQuaternion(e) { this.w = 2 * Math.acos(e.w); var t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this } setAxisAngleFromRotationMatrix(e) { let t, i, r, n; const a = e.elements, o = a[0], s = a[4], l = a[8], c = a[1], h = a[5], u = a[9], d = a[2], p = a[6], f = a[10]; if (Math.abs(s - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) { if (Math.abs(s + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(o + h + f - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; const e = (o + 1) / 2, a = (h + 1) / 2, m = (f + 1) / 2, v = (s + c) / 4, g = (l + d) / 4, x = (u + p) / 4; return e > a && e > m ? n = e < .01 ? (i = 0, r = .707106781) : (i = Math.sqrt(e), r = v / i, g / i) : a > m ? n = a < .01 ? (i = .707106781, r = 0, .707106781) : (r = Math.sqrt(a), i = v / r, x / r) : m < .01 ? (i = .707106781, r = .707106781, n = 0) : (n = Math.sqrt(m), i = g / n, r = x / n), this.set(i, r, n, t), this } let m = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - s) * (c - s)); return Math.abs(m) < .001 && (m = 1), this.x = (p - u) / m, this.y = (l - d) / m, this.z = (c - s) / m, this.w = Math.acos((o + h + f - 1) / 2), this } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this } clampLength(e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e } fromBufferAttribute(e, t, i) { return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } } Re.prototype.isVector4 = !0; class Ue extends ce { constructor(e, t, i = {}) { super(), this.width = e, this.height = t, this.depth = 1, this.scissor = new Re(0, 0, e, t), this.scissorTest = !1, this.viewport = new Re(0, 0, e, t), this.texture = new h(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = { width: e, height: t, depth: 1 }, this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : U, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null } setTexture(e) { e.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = e } setSize(e, t, i = 1) { this.width === e && this.height === t && this.depth === i || (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.image = { ...this.texture.image }, this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } Ue.prototype.isWebGLRenderTarget = !0; class Te extends Ue { constructor(e, t, i) { super(e, t); const r = this.texture; this.texture = []; for (let e = 0; e < i; e++)this.texture[e] = r.clone() } setSize(i, r, n = 1) { if (this.width !== i || this.height !== r || this.depth !== n) { this.width = i, this.height = r, this.depth = n; for (let e = 0, t = this.texture.length; e < t; e++)this.texture[e].image.width = i, this.texture[e].image.height = r, this.texture[e].image.depth = n; this.dispose() } return this.viewport.set(0, 0, i, r), this.scissor.set(0, 0, i, r), this } copy(i) { this.dispose(), this.width = i.width, this.height = i.height, this.depth = i.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.depthTexture = i.depthTexture; for (let e = this.texture.length = 0, t = i.texture.length; e < t; e++)this.texture[e] = i.texture[e].clone(); return this } } Te.prototype.isWebGLMultipleRenderTargets = !0; class ze extends Ue { constructor(e, t, i) { super(e, t, i), this.samples = 4 } copy(e) { return super.copy.call(this, e), this.samples = e.samples, this } } ze.prototype.isWebGLMultisampleRenderTarget = !0; class m { constructor(e = 0, t = 0, i = 0, r = 1) { this._x = e, this._y = t, this._z = i, this._w = r } static slerp(e, t, i, r) { return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), i.slerpQuaternions(e, t, r) } static slerpFlat(t, i, r, n, a, o, s) { let l = r[n + 0], c = r[n + 1], h = r[n + 2], u = r[n + 3]; var d = a[o + 0], p = a[o + 1], f = a[o + 2], o = a[o + 3]; if (0 === s) return t[i + 0] = l, t[i + 1] = c, t[i + 2] = h, void (t[i + 3] = u); if (1 === s) return t[i + 0] = d, t[i + 1] = p, t[i + 2] = f, void (t[i + 3] = o); if (u !== o || l !== d || c !== p || h !== f) { let e = 1 - s; const i = l * d + c * p + h * f + u * o, r = 0 <= i ? 1 : -1, n = 1 - i * i; if (n > Number.EPSILON) { const a = Math.sqrt(n), o = Math.atan2(a, i * r); e = Math.sin(e * o) / a, s = Math.sin(s * o) / a } const a = s * r; if (l = l * e + d * a, c = c * e + p * a, h = h * e + f * a, u = u * e + o * a, e === 1 - s) { const t = 1 / Math.sqrt(l * l + c * c + h * h + u * u); l *= t, c *= t, h *= t, u *= t } } t[i] = l, t[i + 1] = c, t[i + 2] = h, t[i + 3] = u } static multiplyQuaternionsFlat(e, t, i, r, n, a) { var o = i[r], s = i[r + 1], l = i[r + 2], i = i[r + 3], r = n[a], c = n[a + 1], h = n[a + 2], n = n[a + 3]; return e[t] = o * n + i * r + s * h - l * c, e[t + 1] = s * n + i * c + l * r - o * h, e[t + 2] = l * n + i * h + o * c - s * r, e[t + 3] = i * n - o * r - s * c - l * h, e } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get w() { return this._w } set w(e) { this._w = e, this._onChangeCallback() } set(e, t, i, r) { return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._w) } copy(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this } setFromEuler(e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); const i = e._x, r = e._y, n = e._z, a = e._order, o = Math.cos, s = Math.sin, l = o(i / 2), c = o(r / 2), h = o(n / 2), u = s(i / 2), d = s(r / 2), p = s(n / 2); switch (a) { case "XYZ": this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p; break; case "YXZ": this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p; break; case "ZXY": this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p; break; case "ZYX": this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p; break; case "YZX": this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p; break; case "XZY": this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a) }return !1 !== t && this._onChangeCallback(), this } setFromAxisAngle(e, t) { var t = t / 2, i = Math.sin(t); return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(t), this._onChangeCallback(), this } setFromRotationMatrix(e) { var e = e.elements, t = e[0], i = e[4], r = e[8], n = e[1], a = e[5], o = e[9], s = e[2], l = e[6], c = e[10], h = t + a + c; if (0 < h) { const e = .5 / Math.sqrt(h + 1); this._w = .25 / e, this._x = (l - o) * e, this._y = (r - s) * e, this._z = (n - i) * e } else if (a < t && c < t) { const e = 2 * Math.sqrt(1 + t - a - c); this._w = (l - o) / e, this._x = .25 * e, this._y = (i + n) / e, this._z = (r + s) / e } else if (c < a) { const e = 2 * Math.sqrt(1 + a - t - c); this._w = (r - s) / e, this._x = (i + n) / e, this._y = .25 * e, this._z = (o + l) / e } else { const e = 2 * Math.sqrt(1 + c - t - a); this._w = (n - i) / e, this._x = (r + s) / e, this._y = (o + l) / e, this._z = .25 * e } return this._onChangeCallback(), this } setFromUnitVectors(e, t) { let i = e.dot(t) + 1; return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0) : (this._x = 0, this._y = -e.z, this._z = e.y)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x), this._w = i, this.normalize() } angleTo(e) { return 2 * Math.acos(Math.abs(f(this.dot(e), -1, 1))) } rotateTowards(e, t) { var i = this.angleTo(e); return 0 !== i && (t = Math.min(1, t / i), this.slerp(e, t)), this } identity() { return this.set(0, 0, 0, 1) } invert() { return this.conjugate() } conjugate() { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w } lengthSq() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize() { var e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (this._x = this._x * (e = 1 / e), this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) } premultiply(e) { return this.multiplyQuaternions(e, this) } multiplyQuaternions(e, t) { var i = e._x, r = e._y, n = e._z, e = e._w, a = t._x, o = t._y, s = t._z, t = t._w; return this._x = i * t + e * a + r * s - n * o, this._y = r * t + e * o + n * a - i * s, this._z = n * t + e * s + i * o - r * a, this._w = e * t - i * a - r * o - n * s, this._onChangeCallback(), this } slerp(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); var i = this._x, r = this._y, n = this._z, a = this._w; let o = a * e._w + i * e._x + r * e._y + n * e._z; if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), 1 <= o) return this._w = a, this._x = i, this._y = r, this._z = n, this; if ((e = 1 - o * o) <= Number.EPSILON) { const e = 1 - t; return this._w = e * a + t * this._w, this._x = e * i + t * this._x, this._y = e * r + t * this._y, this._z = e * n + t * this._z, this.normalize(), this._onChangeCallback(), this } var e = Math.sqrt(e), s = Math.atan2(e, o), l = Math.sin((1 - t) * s) / e, t = Math.sin(t * s) / e; return this._w = a * l + this._w * t, this._x = i * l + this._x * t, this._y = r * l + this._y * t, this._z = n * l + this._z * t, this._onChangeCallback(), this } slerpQuaternions(e, t, i) { this.copy(e).slerp(t, i) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w } fromArray(e, t = 0) { return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e } fromBufferAttribute(e, t) { return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } m.prototype.isQuaternion = !0; class Le { constructor(e = 0, t = 0, i = 0) { this.x = e, this.y = t, this.z = i } set(e, t, i) { return void 0 === i && (i = this.z), this.x = e, this.y = t, this.z = i, this } setScalar(e) { return this.x = e, this.y = e, this.z = e, this } setX(e) { return this.x = e, this } setY(e) { return this.y = e, this } setZ(e) { return this.z = e, this } setComponent(e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this } getComponent(e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } } clone() { return new this.constructor(this.x, this.y, this.z) } copy(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this } add(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) } addScalar(e) { return this.x += e, this.y += e, this.z += e, this } addVectors(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this } addScaledVector(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this } sub(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) } subScalar(e) { return this.x -= e, this.y -= e, this.z -= e, this } subVectors(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) } multiplyScalar(e) { return this.x *= e, this.y *= e, this.z *= e, this } multiplyVectors(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this } applyEuler(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Me.setFromEuler(e)) } applyAxisAngle(e, t) { return this.applyQuaternion(Me.setFromAxisAngle(e, t)) } applyMatrix3(e) { var t = this.x, i = this.y, r = this.z, e = e.elements; return this.x = e[0] * t + e[3] * i + e[6] * r, this.y = e[1] * t + e[4] * i + e[7] * r, this.z = e[2] * t + e[5] * i + e[8] * r, this } applyNormalMatrix(e) { return this.applyMatrix3(e).normalize() } applyMatrix4(e) { var t = this.x, i = this.y, r = this.z, n = 1 / ((e = e.elements)[3] * t + e[7] * i + e[11] * r + e[15]); return this.x = (e[0] * t + e[4] * i + e[8] * r + e[12]) * n, this.y = (e[1] * t + e[5] * i + e[9] * r + e[13]) * n, this.z = (e[2] * t + e[6] * i + e[10] * r + e[14]) * n, this } applyQuaternion(e) { var t = this.x, i = this.y, r = this.z, n = e.x, a = e.y, o = e.z, s = (e = e.w) * t + a * r - o * i, l = e * i + o * t - n * r, c = e * r + n * i - a * t; return this.x = s * e + (t = -n * t - a * i - o * r) * -n + l * -o - c * -a, this.y = l * e + t * -a + c * -n - s * -o, this.z = c * e + t * -o + s * -a - l * -n, this } project(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) } unproject(e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) } transformDirection(e) { var t = this.x, i = this.y, r = this.z, e = e.elements; return this.x = e[0] * t + e[4] * i + e[8] * r, this.y = e[1] * t + e[5] * i + e[9] * r, this.z = e[2] * t + e[6] * i + e[10] * r, this.normalize() } divide(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this } divideScalar(e) { return this.multiplyScalar(1 / e) } min(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this } max(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this } clamp(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this } clampScalar(e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this } clampLength(e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) } floor() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot(e) { return this.x * e.x + this.y * e.y + this.z * e.z } lengthSq() { return this.x * this.x + this.y * this.y + this.z * this.z } length() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize() { return this.divideScalar(this.length() || 1) } setLength(e) { return this.normalize().multiplyScalar(e) } lerp(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this } lerpVectors(e, t, i) { return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this } cross(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) } crossVectors(e, t) { var i = e.x, r = e.y, e = e.z, n = t.x, a = t.y, t = t.z; return this.x = r * t - e * a, this.y = e * n - i * t, this.z = i * a - r * n, this } projectOnVector(e) { var t = e.lengthSq(); return 0 === t ? this.set(0, 0, 0) : (t = e.dot(this) / t, this.copy(e).multiplyScalar(t)) } projectOnPlane(e) { return Se.copy(this).projectOnVector(e), this.sub(Se) } reflect(e) { return this.sub(Se.copy(e).multiplyScalar(2 * this.dot(e))) } angleTo(e) { var t = Math.sqrt(this.lengthSq() * e.lengthSq()); return 0 === t ? Math.PI / 2 : (e = this.dot(e) / t, Math.acos(f(e, -1, 1))) } distanceTo(e) { return Math.sqrt(this.distanceToSquared(e)) } distanceToSquared(e) { var t = this.x - e.x, i = this.y - e.y; return t * t + i * i + (e = this.z - e.z) * e } manhattanDistanceTo(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) } setFromSpherical(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) } setFromSphericalCoords(e, t, i) { var r = Math.sin(t) * e; return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this } setFromCylindrical(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) } setFromCylindricalCoords(e, t, i) { return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this } setFromMatrixPosition(e) { return e = e.elements, this.x = e[12], this.y = e[13], this.z = e[14], this } setFromMatrixScale(e) { var t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), e = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = i, this.z = e, this } setFromMatrixColumn(e, t) { return this.fromArray(e.elements, 4 * t) } setFromMatrix3Column(e, t) { return this.fromArray(e.elements, 3 * t) } equals(e) { return e.x === this.x && e.y === this.y && e.z === this.z } fromArray(e, t = 0) { return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e } fromBufferAttribute(e, t, i) { return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } random() { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } } Le.prototype.isVector3 = !0; const Se = new Le, Me = new m; class Oe { constructor(e = new Le(1 / 0, 1 / 0, 1 / 0), t = new Le(-1 / 0, -1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromArray(i) { let r = 1 / 0, n = 1 / 0, a = 1 / 0, o = -1 / 0, s = -1 / 0, l = -1 / 0; for (let e = 0, t = i.length; e < t; e += 3) { var c = i[e], h = i[e + 1], u = i[e + 2]; c < r && (r = c), h < n && (n = h), u < a && (a = u), c > o && (o = c), h > s && (s = h), u > l && (l = u) } return this.min.set(r, n, a), this.max.set(o, s, l), this } setFromBufferAttribute(i) { let r = 1 / 0, n = 1 / 0, a = 1 / 0, o = -1 / 0, s = -1 / 0, l = -1 / 0; for (let e = 0, t = i.count; e < t; e++) { var c = i.getX(e), h = i.getY(e), u = i.getZ(e); c < r && (r = c), h < n && (n = h), u < a && (a = u), c > o && (o = c), h > s && (s = h), u > l && (l = u) } return this.min.set(r, n, a), this.max.set(o, s, l), this } setFromPoints(i) { this.makeEmpty(); for (let e = 0, t = i.length; e < t; e++)this.expandByPoint(i[e]); return this } setFromCenterAndSize(e, t) { return t = ke.copy(t).multiplyScalar(.5), this.min.copy(e).sub(t), this.max.copy(e).add(t), this } setFromObject(e) { return this.makeEmpty(), this.expandByObject(e) } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } expandByObject(e) { e.updateWorldMatrix(!1, !1); const t = e.geometry; void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(), Ge.copy(t.boundingBox), Ge.applyMatrix4(e.matrixWorld), this.union(Ge)); var i = e.children; for (let e = 0, t = i.length; e < t; e++)this.expandByObject(i[e]); return this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) } intersectsSphere(e) { return this.clampPoint(e.center, ke), ke.distanceToSquared(e.center) <= e.radius * e.radius } intersectsPlane(e) { let t, i; return i = 0 < e.normal.x ? (t = e.normal.x * this.min.x, e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant } intersectsTriangle(e) { return !this.isEmpty() && (this.getCenter(Ze), Je.subVectors(this.max, Ze), We.subVectors(e.a, Ze), je.subVectors(e.b, Ze), Xe.subVectors(e.c, Ze), qe.subVectors(je, We), Ye.subVectors(Xe, je), Qe.subVectors(We, Xe), !!et([0, -qe.z, qe.y, 0, -Ye.z, Ye.y, 0, -Qe.z, Qe.y, qe.z, 0, -qe.x, Ye.z, 0, -Ye.x, Qe.z, 0, -Qe.x, -qe.y, qe.x, 0, -Ye.y, Ye.x, 0, -Qe.y, Qe.x, 0], We, je, Xe, Je) && !!et([1, 0, 0, 0, 1, 0, 0, 0, 1], We, je, Xe, Je) && (Ke.crossVectors(qe, Ye), et([Ke.x, Ke.y, Ke.z], We, je, Xe, Je))) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return ke.copy(e).clamp(this.min, this.max).sub(e).length() } getBoundingSphere(e) { return this.getCenter(e.center), e.radius = .5 * this.getSize(ke).length(), e } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } applyMatrix4(e) { return this.isEmpty() || (Ve[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ve[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ve[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ve[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ve[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ve[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ve[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ve[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ve)), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } Oe.prototype.isBox3 = !0; const Ve = [new Le, new Le, new Le, new Le, new Le, new Le, new Le, new Le], ke = new Le, Ge = new Oe, We = new Le, je = new Le, Xe = new Le, qe = new Le, Ye = new Le, Qe = new Le, Ze = new Le, Je = new Le, Ke = new Le, $e = new Le; function et(i, r, n, a, o) { for (let e = 0, t = i.length - 3; e <= t; e += 3) { $e.fromArray(i, e); var s = o.x * Math.abs($e.x) + o.y * Math.abs($e.y) + o.z * Math.abs($e.z), l = r.dot($e), c = n.dot($e), h = a.dot($e); if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > s) return !1 } return !0 } const tt = new Oe, it = new Le, rt = new Le, nt = new Le; class at { constructor(e = new Le, t = -1) { this.center = e, this.radius = t } set(e, t) { return this.center.copy(e), this.radius = t, this } setFromPoints(i, e) { const r = this.center; void 0 !== e ? r.copy(e) : tt.setFromPoints(i).getCenter(r); let n = 0; for (let e = 0, t = i.length; e < t; e++)n = Math.max(n, r.distanceToSquared(i[e])); return this.radius = Math.sqrt(n), this } copy(e) { return this.center.copy(e.center), this.radius = e.radius, this } isEmpty() { return this.radius < 0 } makeEmpty() { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint(e) { return e.distanceTo(this.center) - this.radius } intersectsSphere(e) { var t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t } intersectsBox(e) { return e.intersectsSphere(this) } intersectsPlane(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius } clampPoint(e, t) { var i = this.center.distanceToSquared(e); return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t } getBoundingBox(e) { return this.isEmpty() ? e.makeEmpty() : (e.set(this.center, this.center), e.expandByScalar(this.radius)), e } applyMatrix4(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this } translate(e) { return this.center.add(e), this } expandByPoint(e) { nt.subVectors(e, this.center); var t = nt.lengthSq(); if (t > this.radius * this.radius) { const e = Math.sqrt(t), i = .5 * (e - this.radius); this.center.add(nt.multiplyScalar(i / e)), this.radius += i } return this } union(e) { return rt.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(it.copy(e.center).add(rt)), this.expandByPoint(it.copy(e.center).sub(rt)), this } equals(e) { return e.center.equals(this.center) && e.radius === this.radius } clone() { return (new this.constructor).copy(this) } } const ot = new Le, st = new Le, lt = new Le, ct = new Le, ht = new Le, ut = new Le, dt = new Le; class pt { constructor(e = new Le, t = new Le(0, 0, -1)) { this.origin = e, this.direction = t } set(e, t) { return this.origin.copy(e), this.direction.copy(t), this } copy(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this } at(e, t) { return t.copy(this.direction).multiplyScalar(e).add(this.origin) } lookAt(e) { return this.direction.copy(e).sub(this.origin).normalize(), this } recast(e) { return this.origin.copy(this.at(e, ot)), this } closestPointToPoint(e, t) { return t.subVectors(e, this.origin), (e = t.dot(this.direction)) < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin) } distanceToPoint(e) { return Math.sqrt(this.distanceSqToPoint(e)) } distanceSqToPoint(e) { var t = ot.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (ot.copy(this.direction).multiplyScalar(t).add(this.origin), ot.distanceToSquared(e)) } distanceSqToSegment(e, t, i, r) { st.copy(e).add(t).multiplyScalar(.5), lt.copy(t).sub(e).normalize(), ct.copy(this.origin).sub(st); var e = .5 * e.distanceTo(t), t = -this.direction.dot(lt), n = ct.dot(this.direction), a = -ct.dot(lt), o = ct.lengthSq(), s = Math.abs(1 - t * t); let l, c, h, u; if (0 < s) if (l = t * a - n, c = t * n - a, u = e * s, 0 <= l) if (c >= -u) if (c <= u) { const e = 1 / s; l *= e, c *= e, h = l * (l + t * c + 2 * n) + c * (t * l + c + 2 * a) + o } else c = e, l = Math.max(0, -(t * c + n)), h = -l * l + c * (c + 2 * a) + o; else c = -e, l = Math.max(0, -(t * c + n)), h = -l * l + c * (c + 2 * a) + o; else h = c <= -u ? (l = Math.max(0, -(-t * e + n)), c = 0 < l ? -e : Math.min(Math.max(-e, -a), e), -l * l + c * (c + 2 * a) + o) : c <= u ? (l = 0, (c = Math.min(Math.max(-e, -a), e)) * (c + 2 * a) + o) : (l = Math.max(0, -(t * e + n)), c = 0 < l ? e : Math.min(Math.max(-e, -a), e), -l * l + c * (c + 2 * a) + o); else c = 0 < t ? -e : e, l = Math.max(0, -(t * c + n)), h = -l * l + c * (c + 2 * a) + o; return i && i.copy(this.direction).multiplyScalar(l).add(this.origin), r && r.copy(lt).multiplyScalar(c).add(st), h } intersectSphere(e, t) { ot.subVectors(e.center, this.origin); var i = ot.dot(this.direction), r = ot.dot(ot) - i * i; return (e = e.radius * e.radius) < r ? null : (r = i - (e = Math.sqrt(e - r)), i += e, r < 0 && i < 0 ? null : r < 0 ? this.at(i, t) : this.at(r, t)) } intersectsSphere(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius } distanceToPlane(e) { var t = e.normal.dot(this.direction); return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null } intersectPlane(e, t) { return null === (e = this.distanceToPlane(e)) ? null : this.at(e, t) } intersectsPlane(e) { var t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 } intersectBox(e, t) { let i, r, n, a, o, s; var l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return r = 0 <= l ? (i = (e.min.x - u.x) * l, (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l, (e.min.x - u.x) * l), a = 0 <= c ? (n = (e.min.y - u.y) * c, (e.max.y - u.y) * c) : (n = (e.max.y - u.y) * c, (e.min.y - u.y) * c), i > a || n > r ? null : ((n > i || i != i) && (i = n), (a < r || r != r) && (r = a), s = 0 <= h ? (o = (e.min.z - u.z) * h, (e.max.z - u.z) * h) : (o = (e.max.z - u.z) * h, (e.min.z - u.z) * h), i > s || o > r ? null : ((o > i || i != i) && (i = o), (r = s < r || r != r ? s : r) < 0 ? null : this.at(0 <= i ? i : r, t))) } intersectsBox(e) { return null !== this.intersectBox(e, ot) } intersectTriangle(e, t, i, r, n) { ht.subVectors(t, e), ut.subVectors(i, e), dt.crossVectors(ht, ut); let a, o = this.direction.dot(dt); if (0 < o) { if (r) return null; a = 1 } else { if (!(o < 0)) return null; a = -1, o = -o } return ct.subVectors(this.origin, e), (t = a * this.direction.dot(ut.crossVectors(ct, ut))) < 0 || (i = a * this.direction.dot(ht.cross(ct))) < 0 || t + i > o || (r = -a * ct.dot(dt)) < 0 ? null : this.at(r / o, n) } applyMatrix4(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this } equals(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } clone() { return (new this.constructor).copy(this) } } class Pe { constructor() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } set(e, t, i, r, n, a, o, s, l, c, h, u, d, p, f, m) { const v = this.elements; return v[0] = e, v[4] = t, v[8] = i, v[12] = r, v[1] = n, v[5] = a, v[9] = o, v[13] = s, v[2] = l, v[6] = c, v[10] = h, v[14] = u, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this } identity() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone() { return (new Pe).fromArray(this.elements) } copy(e) { const t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this } copyPosition(e) { const t = this.elements, i = e.elements; return t[12] = i[12], t[13] = i[13], t[14] = i[14], this } setFromMatrix3(e) { return e = e.elements, this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this } extractBasis(e, t, i) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this } makeBasis(e, t, i) { return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this } extractRotation(e) { const t = this.elements, i = e.elements, r = 1 / ft.setFromMatrixColumn(e, 0).length(), n = 1 / ft.setFromMatrixColumn(e, 1).length(), a = 1 / ft.setFromMatrixColumn(e, 2).length(); return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * n, t[5] = i[5] * n, t[6] = i[6] * n, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromEuler(e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); const t = this.elements, i = e.x, r = e.y, n = e.z, a = Math.cos(i), o = Math.sin(i), s = Math.cos(r), l = Math.sin(r), c = Math.cos(n), h = Math.sin(n); if ("XYZ" === e.order) { const e = a * c, i = a * h, r = o * c, n = o * h; t[0] = s * c, t[4] = -s * h, t[8] = l, t[1] = i + r * l, t[5] = e - n * l, t[9] = -o * s, t[2] = n - e * l, t[6] = r + i * l, t[10] = a * s } else if ("YXZ" === e.order) { const e = s * c, i = s * h, r = l * c, n = l * h; t[0] = e + n * o, t[4] = r * o - i, t[8] = a * l, t[1] = a * h, t[5] = a * c, t[9] = -o, t[2] = i * o - r, t[6] = n + e * o, t[10] = a * s } else if ("ZXY" === e.order) { const e = s * c, i = s * h, r = l * c, n = l * h; t[0] = e - n * o, t[4] = -a * h, t[8] = r + i * o, t[1] = i + r * o, t[5] = a * c, t[9] = n - e * o, t[2] = -a * l, t[6] = o, t[10] = a * s } else if ("ZYX" === e.order) { const e = a * c, i = a * h, r = o * c, n = o * h; t[0] = s * c, t[4] = r * l - i, t[8] = e * l + n, t[1] = s * h, t[5] = n * l + e, t[9] = i * l - r, t[2] = -l, t[6] = o * s, t[10] = a * s } else if ("YZX" === e.order) { const e = a * s, i = a * l, r = o * s, n = o * l; t[0] = s * c, t[4] = n - e * h, t[8] = r * h + i, t[1] = h, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = i * h + r, t[10] = e - n * h } else if ("XZY" === e.order) { const e = a * s, i = a * l, r = o * s, n = o * l; t[0] = s * c, t[4] = -h, t[8] = l * c, t[1] = e * h + n, t[5] = a * c, t[9] = i * h - r, t[2] = r * h - i, t[6] = o * c, t[10] = n * h + e } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this } makeRotationFromQuaternion(e) { return this.compose(vt, e, gt) } lookAt(e, t, i) { const r = this.elements; return _t.subVectors(e, t), 0 === _t.lengthSq() && (_t.z = 1), _t.normalize(), xt.crossVectors(i, _t), 0 === xt.lengthSq() && (1 === Math.abs(i.z) ? _t.x += 1e-4 : _t.z += 1e-4, _t.normalize(), xt.crossVectors(i, _t)), xt.normalize(), yt.crossVectors(_t, xt), r[0] = xt.x, r[4] = yt.x, r[8] = _t.x, r[1] = xt.y, r[5] = yt.y, r[9] = _t.y, r[2] = xt.z, r[6] = yt.z, r[10] = _t.z, this } multiply(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) } premultiply(e) { return this.multiplyMatrices(e, this) } multiplyMatrices(e, H) { const t = e.elements, i = H.elements, r = this.elements, n = t[0], a = t[4], o = t[8], s = t[12], l = t[1], c = t[5], h = t[9], u = t[13], d = t[2], p = t[6], f = t[10], m = t[14], v = t[3], g = t[7], x = t[11], y = t[15], _ = i[0], b = i[4], w = i[8], E = i[12], T = i[1], S = i[5], M = i[9], A = i[13], R = i[2], L = i[6], P = i[10], C = i[14], F = i[3], D = i[7], I = i[11], N = i[15]; return r[0] = n * _ + a * T + o * R + s * F, r[4] = n * b + a * S + o * L + s * D, r[8] = n * w + a * M + o * P + s * I, r[12] = n * E + a * A + o * C + s * N, r[1] = l * _ + c * T + h * R + u * F, r[5] = l * b + c * S + h * L + u * D, r[9] = l * w + c * M + h * P + u * I, r[13] = l * E + c * A + h * C + u * N, r[2] = d * _ + p * T + f * R + m * F, r[6] = d * b + p * S + f * L + m * D, r[10] = d * w + p * M + f * P + m * I, r[14] = d * E + p * A + f * C + m * N, r[3] = v * _ + g * T + x * R + y * F, r[7] = v * b + g * S + x * L + y * D, r[11] = v * w + g * M + x * P + y * I, r[15] = v * E + g * A + x * C + y * N, this } multiplyScalar(e) { const t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this } determinant() { var e = this.elements, t = e[0], i = e[4], r = e[8], n = e[12], a = e[1], o = e[5], s = e[9], l = e[13], c = e[2], h = e[6], u = e[10], d = e[14]; return e[3] * (+n * s * h - r * l * h - n * o * u + i * l * u + r * o * d - i * s * d) + e[7] * (+t * s * d - t * l * u + n * a * u - r * a * d + r * l * c - n * s * c) + e[11] * (+t * l * h - t * o * d - n * a * h + i * a * d + n * o * c - i * l * c) + e[15] * (-r * o * c - t * s * h + t * o * u + r * a * h - i * a * u + i * s * c) } transpose() { const e = this.elements; var t = e[1]; return e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this } setPosition(e, t, i) { const r = this.elements; return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this } invert() { const e = this.elements, t = e[0], i = e[1], r = e[2], n = e[3], a = e[4], o = e[5], s = e[6], l = e[7], c = e[8], h = e[9], u = e[10], d = e[11], p = e[12], f = e[13], m = e[14], v = e[15], g = h * m * l - f * u * l + f * s * d - o * m * d - h * s * v + o * u * v, x = p * u * l - c * m * l - p * s * d + a * m * d + c * s * v - a * u * v, y = c * f * l - p * h * l + p * o * d - a * f * d - c * o * v + a * h * v, _ = p * h * s - c * f * s - p * o * u + a * f * u + c * o * m - a * h * m, b = t * g + i * x + r * y + n * _; if (0 == b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); var w = 1 / b; return e[0] = g * w, e[1] = (f * u * n - h * m * n - f * r * d + i * m * d + h * r * v - i * u * v) * w, e[2] = (o * m * n - f * s * n + f * r * l - i * m * l - o * r * v + i * s * v) * w, e[3] = (h * s * n - o * u * n - h * r * l + i * u * l + o * r * d - i * s * d) * w, e[4] = x * w, e[5] = (c * m * n - p * u * n + p * r * d - t * m * d - c * r * v + t * u * v) * w, e[6] = (p * s * n - a * m * n - p * r * l + t * m * l + a * r * v - t * s * v) * w, e[7] = (a * u * n - c * s * n + c * r * l - t * u * l - a * r * d + t * s * d) * w, e[8] = y * w, e[9] = (p * h * n - c * f * n - p * i * d + t * f * d + c * i * v - t * h * v) * w, e[10] = (a * f * n - p * o * n + p * i * l - t * f * l - a * i * v + t * o * v) * w, e[11] = (c * o * n - a * h * n - c * i * l + t * h * l + a * i * d - t * o * d) * w, e[12] = _ * w, e[13] = (c * f * r - p * h * r + p * i * u - t * f * u - c * i * m + t * h * m) * w, e[14] = (p * o * r - a * f * r - p * i * s + t * f * s + a * i * m - t * o * m) * w, e[15] = (a * h * r - c * o * r + c * i * s - t * h * s - a * i * u + t * o * u) * w, this } scale(e) { const t = this.elements, i = e.x, r = e.y, n = e.z; return t[0] *= i, t[4] *= r, t[8] *= n, t[1] *= i, t[5] *= r, t[9] *= n, t[2] *= i, t[6] *= r, t[10] *= n, t[3] *= i, t[7] *= r, t[11] *= n, this } getMaxScaleOnAxis() { var e = (i = this.elements)[0] * i[0] + i[1] * i[1] + i[2] * i[2], t = i[4] * i[4] + i[5] * i[5] + i[6] * i[6], i = i[8] * i[8] + i[9] * i[9] + i[10] * i[10]; return Math.sqrt(Math.max(e, t, i)) } makeTranslation(e, t, i) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this } makeRotationX(e) { var t = Math.cos(e), e = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1), this } makeRotationY(e) { var t = Math.cos(e), e = Math.sin(e); return this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1), this } makeRotationZ(e) { var t = Math.cos(e), e = Math.sin(e); return this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis(e, t) { var i = Math.cos(t), t = Math.sin(t), r = 1 - i, n = e.x, a = e.y, e = e.z, o = r * n, s = r * a; return this.set(o * n + i, o * a - t * e, o * e + t * a, 0, o * a + t * e, s * a + i, s * e - t * n, 0, o * e - t * a, s * e + t * n, r * e * e + i, 0, 0, 0, 0, 1), this } makeScale(e, t, i) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this } makeShear(e, t, i, r, n, a) { return this.set(1, i, n, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this } compose(e, t, i) { const r = this.elements, n = t._x, a = t._y, o = t._z, s = t._w, l = n + n, c = a + a, h = o + o, u = n * l, d = n * c, p = n * h, f = a * c, m = a * h, v = o * h, g = s * l, x = s * c, y = s * h, _ = i.x, b = i.y, w = i.z; return r[0] = (1 - (f + v)) * _, r[1] = (d + y) * _, r[2] = (p - x) * _, r[3] = 0, r[4] = (d - y) * b, r[5] = (1 - (u + v)) * b, r[6] = (m + g) * b, r[7] = 0, r[8] = (p + x) * w, r[9] = (m - g) * w, r[10] = (1 - (u + f)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this } decompose(e, t, i) { var r = this.elements; let n = ft.set(r[0], r[1], r[2]).length(); var a = ft.set(r[4], r[5], r[6]).length(), o = ft.set(r[8], r[9], r[10]).length(), e = (this.determinant() < 0 && (n = -n), e.x = r[12], e.y = r[13], e.z = r[14], mt.copy(this), 1 / n), r = 1 / a, s = 1 / o; return mt.elements[0] *= e, mt.elements[1] *= e, mt.elements[2] *= e, mt.elements[4] *= r, mt.elements[5] *= r, mt.elements[6] *= r, mt.elements[8] *= s, mt.elements[9] *= s, mt.elements[10] *= s, t.setFromRotationMatrix(mt), i.x = n, i.y = a, i.z = o, this } makePerspective(e, t, i, r, n, a) { void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); const o = this.elements, s = 2 * n / (t - e), l = 2 * n / (i - r), c = (t + e) / (t - e), h = (i + r) / (i - r), u = -(a + n) / (a - n), d = -2 * a * n / (a - n); return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this } makeOrthographic(e, t, i, r, n, a) { const o = this.elements, s = 1 / (t - e), l = 1 / (i - r), c = 1 / (a - n), h = (t + e) * s, u = (i + r) * l, d = (a + n) * c; return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this } equals(e) { var t = this.elements, i = e.elements; for (let e = 0; e < 16; e++)if (t[e] !== i[e]) return !1; return !0 } fromArray(t, i = 0) { for (let e = 0; e < 16; e++)this.elements[e] = t[e + i]; return this } toArray(e = [], t = 0) { var i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e } } Pe.prototype.isMatrix4 = !0; const ft = new Le, mt = new Pe, vt = new Le(0, 0, 0), gt = new Le(1, 1, 1), xt = new Le, yt = new Le, _t = new Le, bt = new Pe, wt = new m; class Et { constructor(e = 0, t = 0, i = 0, r = Et.DefaultOrder) { this._x = e, this._y = t, this._z = i, this._order = r } get x() { return this._x } set x(e) { this._x = e, this._onChangeCallback() } get y() { return this._y } set y(e) { this._y = e, this._onChangeCallback() } get z() { return this._z } set z(e) { this._z = e, this._onChangeCallback() } get order() { return this._order } set order(e) { this._order = e, this._onChangeCallback() } set(e, t, i, r = this._order) { return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this } clone() { return new this.constructor(this._x, this._y, this._z, this._order) } copy(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this } setFromRotationMatrix(e, t = this._order, i = !0) { var r = (e = e.elements)[0], n = e[4], a = e[8], o = e[1], s = e[5], l = e[9], c = e[2], h = e[6], u = e[10]; switch (t) { case "XYZ": this._y = Math.asin(f(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-l, u), this._z = Math.atan2(-n, r)) : (this._x = Math.atan2(h, s), this._z = 0); break; case "YXZ": this._x = Math.asin(-f(l, -1, 1)), Math.abs(l) < .9999999 ? (this._y = Math.atan2(a, u), this._z = Math.atan2(o, s)) : (this._y = Math.atan2(-c, r), this._z = 0); break; case "ZXY": this._x = Math.asin(f(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-c, u), this._z = Math.atan2(-n, s)) : (this._y = 0, this._z = Math.atan2(o, r)); break; case "ZYX": this._y = Math.asin(-f(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(h, u), this._z = Math.atan2(o, r)) : (this._x = 0, this._z = Math.atan2(-n, s)); break; case "YZX": this._z = Math.asin(f(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-l, s), this._y = Math.atan2(-c, r)) : (this._x = 0, this._y = Math.atan2(a, u)); break; case "XZY": this._z = Math.asin(-f(n, -1, 1)), Math.abs(n) < .9999999 ? (this._x = Math.atan2(h, s), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-l, u), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t) }return this._order = t, !0 === i && this._onChangeCallback(), this } setFromQuaternion(e, t, i) { return bt.makeRotationFromQuaternion(e), this.setFromRotationMatrix(bt, t, i) } setFromVector3(e, t = this._order) { return this.set(e.x, e.y, e.z, t) } reorder(e) { return wt.setFromEuler(this), this.setFromQuaternion(wt, e) } equals(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order } fromArray(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this } toArray(e = [], t = 0) { return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e } toVector3(e) { return e ? e.set(this._x, this._y, this._z) : new Le(this._x, this._y, this._z) } _onChange(e) { return this._onChangeCallback = e, this } _onChangeCallback() { } } Et.prototype.isEuler = !0, Et.DefaultOrder = "XYZ", Et.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]; class Tt { constructor() { this.mask = 1 } set(e) { this.mask = 1 << e | 0 } enable(e) { this.mask |= 1 << e | 0 } enableAll() { this.mask = -1 } toggle(e) { this.mask ^= 1 << e | 0 } disable(e) { this.mask &= ~(1 << e | 0) } disableAll() { this.mask = 0 } test(e) { return 0 != (this.mask & e.mask) } } let St = 0; const Mt = new Le, At = new m, Rt = new Pe, Lt = new Le, Pt = new Le, Ct = new Le, Ft = new m, Dt = new Le(1, 0, 0), It = new Le(0, 1, 0), Nt = new Le(0, 0, 1), Ht = { type: "added" }, Bt = { type: "removed" }; class u extends ce { constructor() { super(), Object.defineProperty(this, "id", { value: St++ }), this.uuid = pe(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = u.DefaultUp.clone(); const e = new Le, t = new Et, i = new m, r = new Le(1, 1, 1); t._onChange(function () { i.setFromEuler(t, !1) }), i._onChange(function () { t.setFromQuaternion(i, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new Pe }, normalMatrix: { value: new g } }), this.matrix = new Pe, this.matrixWorld = new Pe, this.matrixAutoUpdate = u.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Tt, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender() { } onAfterRender() { } applyMatrix4(e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion(e) { return this.quaternion.premultiply(e), this } setRotationFromAxisAngle(e, t) { this.quaternion.setFromAxisAngle(e, t) } setRotationFromEuler(e) { this.quaternion.setFromEuler(e, !0) } setRotationFromMatrix(e) { this.quaternion.setFromRotationMatrix(e) } setRotationFromQuaternion(e) { this.quaternion.copy(e) } rotateOnAxis(e, t) { return At.setFromAxisAngle(e, t), this.quaternion.multiply(At), this } rotateOnWorldAxis(e, t) { return At.setFromAxisAngle(e, t), this.quaternion.premultiply(At), this } rotateX(e) { return this.rotateOnAxis(Dt, e) } rotateY(e) { return this.rotateOnAxis(It, e) } rotateZ(e) { return this.rotateOnAxis(Nt, e) } translateOnAxis(e, t) { return Mt.copy(e).applyQuaternion(this.quaternion), this.position.add(Mt.multiplyScalar(t)), this } translateX(e) { return this.translateOnAxis(Dt, e) } translateY(e) { return this.translateOnAxis(It, e) } translateZ(e) { return this.translateOnAxis(Nt, e) } localToWorld(e) { return e.applyMatrix4(this.matrixWorld) } worldToLocal(e) { return e.applyMatrix4(Rt.copy(this.matrixWorld).invert()) } lookAt(e, t, i) { e.isVector3 ? Lt.copy(e) : Lt.set(e, t, i), e = this.parent, this.updateWorldMatrix(!0, !1), Pt.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Rt.lookAt(Pt, Lt, this.up) : Rt.lookAt(Lt, Pt, this.up), this.quaternion.setFromRotationMatrix(Rt), e && (Rt.extractRotation(e.matrixWorld), At.setFromRotationMatrix(Rt), this.quaternion.premultiply(At.invert())) } add(e) { if (1 < arguments.length) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), (e.parent = this).children.push(e), e.dispatchEvent(Ht)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this } remove(e) { if (1 < arguments.length) { for (let e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } var t = this.children.indexOf(e); return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Bt)), this } removeFromParent() { const e = this.parent; return null !== e && e.remove(this), this } clear() { for (let e = 0; e < this.children.length; e++) { const t = this.children[e]; t.parent = null, t.dispatchEvent(Bt) } return this.children.length = 0, this } attach(e) { return this.updateWorldMatrix(!0, !1), Rt.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Rt.multiply(e.parent.matrixWorld)), e.applyMatrix4(Rt), this.add(e), e.updateWorldMatrix(!1, !0), this } getObjectById(e) { return this.getObjectByProperty("id", e) } getObjectByName(e) { return this.getObjectByProperty("name", e) } getObjectByProperty(i, r) { if (this[i] === r) return this; for (let e = 0, t = this.children.length; e < t; e++) { var n = this.children[e].getObjectByProperty(i, r); if (void 0 !== n) return n } } getWorldPosition(e) { return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Pt, e, Ct), e } getWorldScale(e) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Pt, Ft, e), e } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); var t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() } raycast() { } traverse(i) { i(this); const r = this.children; for (let e = 0, t = r.length; e < t; e++)r[e].traverse(i) } traverseVisible(i) { if (!1 !== this.visible) { i(this); const r = this.children; for (let e = 0, t = r.length; e < t; e++)r[e].traverseVisible(i) } } traverseAncestors(e) { const t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) } updateMatrix() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld(i) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || i) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), i = !(this.matrixWorldNeedsUpdate = !1)); const r = this.children; for (let e = 0, t = r.length; e < t; e++)r[e].updateMatrixWorld(i) } updateWorldMatrix(i, e) { const t = this.parent; if (!0 === i && null !== t && t.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) { const i = this.children; for (let e = 0, t = i.length; e < t; e++)i[e].updateWorldMatrix(!1, !0) } } toJSON(i) { const r = void 0 === i || "string" == typeof i, n = {}, a = (r && (i = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }), {}); function o(e, t) { return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(i)), t.uuid } if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), !0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), !1 === this.visible && (a.visible = !1), !1 === this.frustumCulled && (a.frustumCulled = !1), 0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1), this.isInstancedMesh && (a.type = "InstancedMesh", a.count = this.count, a.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (a.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? a.background = this.background.toJSON() : this.background.isTexture && (a.background = this.background.toJSON(i).uuid)), this.environment && this.environment.isTexture && (a.environment = this.environment.toJSON(i).uuid); else if (this.isMesh || this.isLine || this.isPoints) { a.geometry = o(i.geometries, this.geometry); const r = this.geometry.parameters; if (void 0 !== r && void 0 !== r.shapes) { const n = r.shapes; if (Array.isArray(n)) for (let e = 0, t = n.length; e < t; e++) { const a = n[e]; o(i.shapes, a) } else o(i.shapes, n) } } if (this.isSkinnedMesh && (a.bindMode = this.bindMode, a.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (o(i.skeletons, this.skeleton), a.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) { const r = []; for (let e = 0, t = this.material.length; e < t; e++)r.push(o(i.materials, this.material[e])); a.material = r } else a.material = o(i.materials, this.material); if (0 < this.children.length) { a.children = []; for (let e = 0; e < this.children.length; e++)a.children.push(this.children[e].toJSON(i).object) } if (0 < this.animations.length) { a.animations = []; for (let e = 0; e < this.animations.length; e++) { const n = this.animations[e]; a.animations.push(o(i.animations, n)) } } if (r) { const r = e(i.geometries), a = e(i.materials), o = e(i.textures), t = e(i.images), s = e(i.shapes), l = e(i.skeletons), c = e(i.animations); 0 < r.length && (n.geometries = r), 0 < a.length && (n.materials = a), 0 < o.length && (n.textures = o), 0 < t.length && (n.images = t), 0 < s.length && (n.shapes = s), 0 < l.length && (n.skeletons = l), 0 < c.length && (n.animations = c) } return n.object = a, n; function e(e) { const t = []; for (const i in e) { const r = e[i]; delete r.metadata, t.push(r) } return t } } clone(e) { return (new this.constructor).copy(this, e) } copy(t, e = !0) { if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (let e = 0; e < t.children.length; e++) { const i = t.children[e]; this.add(i.clone()) } return this } } u.DefaultUp = new Le(0, 1, 0), u.DefaultMatrixAutoUpdate = !0, u.prototype.isObject3D = !0; const Ut = new Le, zt = new Le, Ot = new Le, Vt = new Le, kt = new Le, Gt = new Le, Wt = new Le, jt = new Le, Xt = new Le, qt = new Le; class x { constructor(e = new Le, t = new Le, i = new Le) { this.a = e, this.b = t, this.c = i } static getNormal(e, t, i, r) { return r.subVectors(i, t), Ut.subVectors(e, t), r.cross(Ut), 0 < (i = r.lengthSq()) ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0) } static getBarycoord(e, t, i, r, n) { Ut.subVectors(r, t), zt.subVectors(i, t), Ot.subVectors(e, t); var r = Ut.dot(Ut), i = Ut.dot(zt), e = Ut.dot(Ot), t = zt.dot(zt), a = zt.dot(Ot), o = r * t - i * i; return 0 == o ? n.set(-2, -1, -1) : n.set(1 - (t = (t * e - i * a) * (o = 1 / o)) - (r = (r * a - i * e) * o), r, t) } static containsPoint(e, t, i, r) { return this.getBarycoord(e, t, i, r, Vt), 0 <= Vt.x && 0 <= Vt.y && Vt.x + Vt.y <= 1 } static getUV(e, t, i, r, n, a, o, s) { return this.getBarycoord(e, t, i, r, Vt), s.set(0, 0), s.addScaledVector(n, Vt.x), s.addScaledVector(a, Vt.y), s.addScaledVector(o, Vt.z), s } static isFrontFacing(e, t, i, r) { return Ut.subVectors(i, t), zt.subVectors(e, t), Ut.cross(zt).dot(r) < 0 } set(e, t, i) { return this.a.copy(e), this.b.copy(t), this.c.copy(i), this } setFromPointsAndIndices(e, t, i, r) { return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this } getArea() { return Ut.subVectors(this.c, this.b), zt.subVectors(this.a, this.b), .5 * Ut.cross(zt).length() } getMidpoint(e) { return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal(e) { return x.getNormal(this.a, this.b, this.c, e) } getPlane(e) { return e.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord(e, t) { return x.getBarycoord(e, this.a, this.b, this.c, t) } getUV(e, t, i, r, n) { return x.getUV(e, this.a, this.b, this.c, t, i, r, n) } containsPoint(e) { return x.containsPoint(e, this.a, this.b, this.c) } isFrontFacing(e) { return x.isFrontFacing(this.a, this.b, this.c, e) } intersectsBox(e) { return e.intersectsTriangle(this) } closestPointToPoint(e, t) { var i = this.a, r = this.b, n = this.c; let a, o; kt.subVectors(r, i), Gt.subVectors(n, i), jt.subVectors(e, i); var s = kt.dot(jt), l = Gt.dot(jt); if (s <= 0 && l <= 0) return t.copy(i); Xt.subVectors(e, r); var c = kt.dot(Xt), h = Gt.dot(Xt); if (0 <= c && h <= c) return t.copy(r); var u = s * h - c * l; if (u <= 0 && 0 <= s && c <= 0) return a = s / (s - c), t.copy(i).addScaledVector(kt, a); qt.subVectors(e, n); var e = kt.dot(qt), d = Gt.dot(qt); return 0 <= d && e <= d ? t.copy(n) : (s = e * l - s * d) <= 0 && 0 <= l && d <= 0 ? (o = l / (l - d), t.copy(i).addScaledVector(Gt, o)) : (l = c * d - e * h) <= 0 && 0 <= h - c && 0 <= e - d ? (Wt.subVectors(n, r), o = (h - c) / (h - c + (e - d)), t.copy(r).addScaledVector(Wt, o)) : (n = 1 / (l + s + u), a = s * n, o = u * n, t.copy(i).addScaledVector(kt, a).addScaledVector(Gt, o)) } equals(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } } let Yt = 0; class t extends ce { constructor() { super(), Object.defineProperty(this, "id", { value: Yt++ }), this.uuid = pe(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = X, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } onBuild() { } onBeforeCompile() { } customProgramCacheKey() { return this.onBeforeCompile.toString() } setValues(e) { if (void 0 !== e) for (const i in e) { var t = e[i]; if (void 0 === t) console.warn("THREE.Material: '" + i + "' parameter is undefined."); else if ("shading" === i) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t; else { const r = this[i]; void 0 !== r ? r && r.isColor ? r.set(t) : r && r.isVector3 && t && t.isVector3 ? r.copy(t) : this[i] = t : console.warn("THREE." + this.type + ": '" + i + "' is not a property of this material.") } } } toJSON(e) { const t = void 0 === e || "string" == typeof e, i = (t && (e = { textures: {}, images: {} }), { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }); function r(e) { const t = []; for (const i in e) { const r = e[i]; delete r.metadata, t.push(r) } return t } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity), this.specularTint && this.specularTint.isColor && (i.specularTint = this.specularTint.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularTintMap && this.specularTintMap.isTexture && (i.specularTintMap = this.specularTintMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (i.combine = this.combine)), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationTint && (i.attenuationTint = this.attenuationTint.getHex()), void 0 !== this.size && (i.size = this.size), null !== this.shadowSide && (i.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), 0 !== this.side && (i.side = this.side), this.vertexColors && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), 0 < this.alphaTest && (i.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (i.flatShading = this.flatShading), !1 === this.visible && (i.visible = !1), !1 === this.toneMapped && (i.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), t) { const t = r(e.textures), n = r(e.images); 0 < t.length && (i.textures = t), 0 < n.length && (i.images = n) } return i } clone() { return (new this.constructor).copy(this) } copy(t) { this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; const i = t.clippingPlanes; let r = null; if (null !== i) { const t = i.length; r = new Array(t); for (let e = 0; e !== t; ++e)r[e] = i[e].clone() } return this.clippingPlanes = r, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this } dispose() { this.dispatchEvent({ type: "dispose" }) } set needsUpdate(e) { !0 === e && this.version++ } } t.prototype.isMaterial = !0; const Qt = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Zt = { h: 0, s: 0, l: 0 }, Jt = { h: 0, s: 0, l: 0 }; function Kt(e, t, i) { return i < 0 && (i += 1), 1 < i && --i, i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e } function $t(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function ei(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } class y { constructor(e, t, i) { return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i) } set(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this } setScalar(e) { return this.r = e, this.g = e, this.b = e, this } setHex(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this } setRGB(e, t, i) { return this.r = e, this.g = t, this.b = i, this } setHSL(e, t, i) { return e = fe(e, 1), t = f(t, 0, 1), i = f(i, 0, 1), 0 === t ? this.r = this.g = this.b = i : (this.r = Kt(t = 2 * i - (i = i <= .5 ? i * (1 + t) : i + t - i * t), i, e + 1 / 3), this.g = Kt(t, i, e), this.b = Kt(t, i, e - 1 / 3)), this } setStyle(t) { function i(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let r; if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) { let e; var n = r[1], a = r[2]; switch (n) { case "rgb": case "rgba": if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(e[1], 10)) / 255, this.g = Math.min(255, parseInt(e[2], 10)) / 255, this.b = Math.min(255, parseInt(e[3], 10)) / 255, i(e[4]), this; if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(e[1], 10)) / 100, this.g = Math.min(100, parseInt(e[2], 10)) / 100, this.b = Math.min(100, parseInt(e[3], 10)) / 100, i(e[4]), this; break; case "hsl": case "hsla": if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) { const r = parseFloat(e[1]) / 360, o = parseInt(e[2], 10) / 100, s = parseInt(e[3], 10) / 100; return i(e[4]), this.setHSL(r, o, s) } } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) { const t = r[1], i = t.length; if (3 === i) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this; if (6 === i) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this } return t && 0 < t.length ? this.setColorName(t) : this } setColorName(e) { var t = Qt[e.toLowerCase()]; return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e), this } clone() { return new this.constructor(this.r, this.g, this.b) } copy(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this } copyGammaToLinear(e, t = 2) { return this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this } copyLinearToGamma(e, t = 2) { return t = 0 < t ? 1 / t : 1, this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this } convertGammaToLinear(e) { return this.copyGammaToLinear(this, e), this } convertLinearToGamma(e) { return this.copyLinearToGamma(this, e), this } copySRGBToLinear(e) { return this.r = $t(e.r), this.g = $t(e.g), this.b = $t(e.b), this } copyLinearToSRGB(e) { return this.r = ei(e.r), this.g = ei(e.g), this.b = ei(e.b), this } convertSRGBToLinear() { return this.copySRGBToLinear(this), this } convertLinearToSRGB() { return this.copyLinearToSRGB(this), this } getHex() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 } getHexString() { return ("000000" + this.getHex().toString(16)).slice(-6) } getHSL(e) { var t = this.r, i = this.g, r = this.b, n = Math.max(t, i, r), a = Math.min(t, i, r); let o, s; var l = (a + n) / 2; if (a === n) o = 0, s = 0; else { const e = n - a; switch (s = l <= .5 ? e / (n + a) : e / (2 - n - a), n) { case t: o = (i - r) / e + (i < r ? 6 : 0); break; case i: o = (r - t) / e + 2; break; case r: o = (t - i) / e + 4 }o /= 6 } return e.h = o, e.s = s, e.l = l, e } getStyle() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" } offsetHSL(e, t, i) { return this.getHSL(Zt), Zt.h += e, Zt.s += t, Zt.l += i, this.setHSL(Zt.h, Zt.s, Zt.l), this } add(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this } addColors(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this } addScalar(e) { return this.r += e, this.g += e, this.b += e, this } sub(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this } multiply(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this } multiplyScalar(e) { return this.r *= e, this.g *= e, this.b *= e, this } lerp(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this } lerpColors(e, t, i) { return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this } lerpHSL(e, t) { this.getHSL(Zt), e.getHSL(Jt); var e = me(Zt.h, Jt.h, t), i = me(Zt.s, Jt.s, t), t = me(Zt.l, Jt.l, t); return this.setHSL(e, i, t), this } equals(e) { return e.r === this.r && e.g === this.g && e.b === this.b } fromArray(e, t = 0) { return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this } toArray(e = [], t = 0) { return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e } fromBufferAttribute(e, t) { return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), !0 === e.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this } toJSON() { return this.getHex() } } y.NAMES = Qt, y.prototype.isColor = !0, y.prototype.r = 1, y.prototype.g = 1, y.prototype.b = 1; class ti extends t { constructor(e) { super(), this.type = "MeshBasicMaterial", this.color = new y(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } ti.prototype.isMeshBasicMaterial = !0; const r = new Le, ii = new k; class P { constructor(e, t, i) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.usage = oe, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this } copyAt(i, r, n) { i *= this.itemSize, n *= r.itemSize; for (let e = 0, t = this.itemSize; e < t; e++)this.array[i + e] = r.array[n + e]; return this } copyArray(e) { return this.array.set(e), this } copyColorsArray(i) { const r = this.array; let n = 0; for (let t = 0, e = i.length; t < e; t++) { let e = i[t]; void 0 === e && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", t), e = new y), r[n++] = e.r, r[n++] = e.g, r[n++] = e.b } return this } copyVector2sArray(i) { const r = this.array; let n = 0; for (let t = 0, e = i.length; t < e; t++) { let e = i[t]; void 0 === e && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", t), e = new k), r[n++] = e.x, r[n++] = e.y } return this } copyVector3sArray(i) { const r = this.array; let n = 0; for (let t = 0, e = i.length; t < e; t++) { let e = i[t]; void 0 === e && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", t), e = new Le), r[n++] = e.x, r[n++] = e.y, r[n++] = e.z } return this } copyVector4sArray(i) { const r = this.array; let n = 0; for (let t = 0, e = i.length; t < e; t++) { let e = i[t]; void 0 === e && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", t), e = new Re), r[n++] = e.x, r[n++] = e.y, r[n++] = e.z, r[n++] = e.w } return this } applyMatrix3(i) { if (2 === this.itemSize) for (let e = 0, t = this.count; e < t; e++)ii.fromBufferAttribute(this, e), ii.applyMatrix3(i), this.setXY(e, ii.x, ii.y); else if (3 === this.itemSize) for (let e = 0, t = this.count; e < t; e++)r.fromBufferAttribute(this, e), r.applyMatrix3(i), this.setXYZ(e, r.x, r.y, r.z); return this } applyMatrix4(i) { for (let e = 0, t = this.count; e < t; e++)r.x = this.getX(e), r.y = this.getY(e), r.z = this.getZ(e), r.applyMatrix4(i), this.setXYZ(e, r.x, r.y, r.z); return this } applyNormalMatrix(i) { for (let e = 0, t = this.count; e < t; e++)r.x = this.getX(e), r.y = this.getY(e), r.z = this.getZ(e), r.applyNormalMatrix(i), this.setXYZ(e, r.x, r.y, r.z); return this } transformDirection(i) { for (let e = 0, t = this.count; e < t; e++)r.x = this.getX(e), r.y = this.getY(e), r.z = this.getZ(e), r.transformDirection(i), this.setXYZ(e, r.x, r.y, r.z); return this } set(e, t = 0) { return this.array.set(e, t), this } getX(e) { return this.array[e * this.itemSize] } setX(e, t) { return this.array[e * this.itemSize] = t, this } getY(e) { return this.array[e * this.itemSize + 1] } setY(e, t) { return this.array[e * this.itemSize + 1] = t, this } getZ(e) { return this.array[e * this.itemSize + 2] } setZ(e, t) { return this.array[e * this.itemSize + 2] = t, this } getW(e) { return this.array[e * this.itemSize + 3] } setW(e, t) { return this.array[e * this.itemSize + 3] = t, this } setXY(e, t, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this } setXYZ(e, t, i, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this } setXYZW(e, t, i, r, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = n, this } onUpload(e) { return this.onUploadCallback = e, this } clone() { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON() { const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized }; return "" !== this.name && (e.name = this.name), this.usage !== oe && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e } } P.prototype.isBufferAttribute = !0; class ri extends P { constructor(e, t, i) { super(new Int8Array(e), t, i) } } class ni extends P { constructor(e, t, i) { super(new Uint8Array(e), t, i) } } class ai extends P { constructor(e, t, i) { super(new Uint8ClampedArray(e), t, i) } } class oi extends P { constructor(e, t, i) { super(new Int16Array(e), t, i) } } class si extends P { constructor(e, t, i) { super(new Uint16Array(e), t, i) } } class li extends P { constructor(e, t, i) { super(new Int32Array(e), t, i) } } class ci extends P { constructor(e, t, i) { super(new Uint32Array(e), t, i) } } class hi extends P { constructor(e, t, i) { super(new Uint16Array(e), t, i) } } hi.prototype.isFloat16BufferAttribute = !0; class G extends P { constructor(e, t, i) { super(new Float32Array(e), t, i) } } class ui extends P { constructor(e, t, i) { super(new Float64Array(e), t, i) } } function di(i) { if (0 === i.length) return -1 / 0; let r = i[0]; for (let e = 1, t = i.length; e < t; ++e)i[e] > r && (r = i[e]); return r } const pi = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: Uint8ClampedArray, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function fi(e, t) { return new pi[e](t) } let mi = 0; const vi = new Pe, gi = new u, xi = new Le, yi = new Oe, _i = new Oe, c = new Le; class S extends ce { constructor() { super(), Object.defineProperty(this, "id", { value: mi++ }), this.uuid = pe(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex() { return this.index } setIndex(e) { return Array.isArray(e) ? this.index = new (65535 < di(e) ? ci : si)(e, 1) : this.index = e, this } getAttribute(e) { return this.attributes[e] } setAttribute(e, t) { return this.attributes[e] = t, this } deleteAttribute(e) { return delete this.attributes[e], this } hasAttribute(e) { return void 0 !== this.attributes[e] } addGroup(e, t, i = 0) { this.groups.push({ start: e, count: t, materialIndex: i }) } clearGroups() { this.groups = [] } setDrawRange(e, t) { this.drawRange.start = e, this.drawRange.count = t } applyMatrix4(e) { const t = this.attributes.position, i = (void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0), this.attributes.normal); if (void 0 !== i) { const t = (new g).getNormalMatrix(e); i.applyNormalMatrix(t), i.needsUpdate = !0 } const r = this.attributes.tangent; return void 0 !== r && (r.transformDirection(e), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } applyQuaternion(e) { return vi.makeRotationFromQuaternion(e), this.applyMatrix4(vi), this } rotateX(e) { return vi.makeRotationX(e), this.applyMatrix4(vi), this } rotateY(e) { return vi.makeRotationY(e), this.applyMatrix4(vi), this } rotateZ(e) { return vi.makeRotationZ(e), this.applyMatrix4(vi), this } translate(e, t, i) { return vi.makeTranslation(e, t, i), this.applyMatrix4(vi), this } scale(e, t, i) { return vi.makeScale(e, t, i), this.applyMatrix4(vi), this } lookAt(e) { return gi.lookAt(e), gi.updateMatrix(), this.applyMatrix4(gi.matrix), this } center() { return this.computeBoundingBox(), this.boundingBox.getCenter(xi).negate(), this.translate(xi.x, xi.y, xi.z), this } setFromPoints(i) { const r = []; for (let e = 0, t = i.length; e < t; e++) { var n = i[e]; r.push(n.x, n.y, n.z || 0) } return this.setAttribute("position", new G(r, 3)), this } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new Oe); var e = this.attributes.position, i = this.morphAttributes.position; if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Le(-1 / 0, -1 / 0, -1 / 0), new Le(1 / 0, 1 / 0, 1 / 0)); if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), i) for (let e = 0, t = i.length; e < t; e++) { var r = i[e]; yi.setFromBufferAttribute(r), this.morphTargetsRelative ? (c.addVectors(this.boundingBox.min, yi.min), this.boundingBox.expandByPoint(c), c.addVectors(this.boundingBox.max, yi.max), this.boundingBox.expandByPoint(c)) : (this.boundingBox.expandByPoint(yi.min), this.boundingBox.expandByPoint(yi.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new at); var r = this.attributes.position, n = this.morphAttributes.position; if (r && r.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Le, 1 / 0); if (r) { const l = this.boundingSphere.center; if (yi.setFromBufferAttribute(r), n) for (let e = 0, t = n.length; e < t; e++) { var a = n[e]; _i.setFromBufferAttribute(a), this.morphTargetsRelative ? (c.addVectors(yi.min, _i.min), yi.expandByPoint(c), c.addVectors(yi.max, _i.max), yi.expandByPoint(c)) : (yi.expandByPoint(_i.min), yi.expandByPoint(_i.max)) } yi.getCenter(l); let i = 0; for (let e = 0, t = r.count; e < t; e++)c.fromBufferAttribute(r, e), i = Math.max(i, l.distanceToSquared(c)); if (n) for (let e = 0, t = n.length; e < t; e++) { var o = n[e], s = this.morphTargetsRelative; for (let e = 0, t = o.count; e < t; e++)c.fromBufferAttribute(o, e), s && (xi.fromBufferAttribute(r, e), c.add(xi)), i = Math.max(i, l.distanceToSquared(c)) } this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeFaceNormals() { } computeTangents() { const e = this.index, r = this.attributes; if (null === e || void 0 === r.position || void 0 === r.normal || void 0 === r.uv) console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); else { const c = e.array, h = r.position.array, u = r.normal.array, d = r.uv.array, t = h.length / 3, p = (void 0 === r.tangent && this.setAttribute("tangent", new P(new Float32Array(4 * t), 4)), r.tangent.array), f = [], m = []; for (let e = 0; e < t; e++)f[e] = new Le, m[e] = new Le; const v = new Le, g = new Le, x = new Le, y = new k, _ = new k, b = new k, w = new Le, E = new Le; let i = this.groups; for (let e = 0, t = (i = 0 === i.length ? [{ start: 0, count: c.length }] : i).length; e < t; ++e) { const r = i[e], R = r.start; for (let e = R, t = R + r.count; e < t; e += 3)a = c[e + 0], o = c[e + 1], s = c[e + 2], v.fromArray(h, 3 * a), g.fromArray(h, 3 * o), x.fromArray(h, 3 * s), y.fromArray(d, 2 * a), _.fromArray(d, 2 * o), b.fromArray(d, 2 * s), g.sub(v), x.sub(v), _.sub(y), b.sub(y), l = 1 / (_.x * b.y - b.x * _.y), isFinite(l) && (w.copy(g).multiplyScalar(b.y).addScaledVector(x, -_.y).multiplyScalar(l), E.copy(x).multiplyScalar(_.x).addScaledVector(g, -b.x).multiplyScalar(l), f[a].add(w), f[o].add(w), f[s].add(w), m[a].add(E), m[o].add(E), m[s].add(E)) } const T = new Le, S = new Le, M = new Le, A = new Le; for (let e = 0, t = i.length; e < t; ++e) { const r = i[e], L = r.start; for (let e = L, t = L + r.count; e < t; e += 3)n(c[e + 0]), n(c[e + 1]), n(c[e + 2]) } function n(e) { M.fromArray(u, 3 * e), A.copy(M); var t = f[e], t = (T.copy(t), T.sub(M.multiplyScalar(M.dot(t))).normalize(), S.crossVectors(A, t), S.dot(m[e]) < 0 ? -1 : 1); p[4 * e] = T.x, p[4 * e + 1] = T.y, p[4 * e + 2] = T.z, p[4 * e + 3] = t } } var a, o, s, l } computeVertexNormals() { const r = this.index, n = this.getAttribute("position"); if (void 0 !== n) { let i = this.getAttribute("normal"); if (void 0 === i) i = new P(new Float32Array(3 * n.count), 3), this.setAttribute("normal", i); else for (let e = 0, t = i.count; e < t; e++)i.setXYZ(e, 0, 0, 0); const l = new Le, c = new Le, h = new Le, u = new Le, d = new Le, p = new Le, f = new Le, m = new Le; if (r) for (let e = 0, t = r.count; e < t; e += 3) { var a = r.getX(e + 0), o = r.getX(e + 1), s = r.getX(e + 2); l.fromBufferAttribute(n, a), c.fromBufferAttribute(n, o), h.fromBufferAttribute(n, s), f.subVectors(h, c), m.subVectors(l, c), f.cross(m), u.fromBufferAttribute(i, a), d.fromBufferAttribute(i, o), p.fromBufferAttribute(i, s), u.add(f), d.add(f), p.add(f), i.setXYZ(a, u.x, u.y, u.z), i.setXYZ(o, d.x, d.y, d.z), i.setXYZ(s, p.x, p.y, p.z) } else for (let e = 0, t = n.count; e < t; e += 3)l.fromBufferAttribute(n, e + 0), c.fromBufferAttribute(n, e + 1), h.fromBufferAttribute(n, e + 2), f.subVectors(h, c), m.subVectors(l, c), f.cross(m), i.setXYZ(e + 0, f.x, f.y, f.z), i.setXYZ(e + 1, f.x, f.y, f.z), i.setXYZ(e + 2, f.x, f.y, f.z); this.normalizeNormals(), i.needsUpdate = !0 } } merge(e, t) { if (e && e.isBufferGeometry) { void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var i = this.attributes; for (const r in i) if (void 0 !== e.attributes[r]) { const n = i[r].array, a = e.attributes[r], o = a.array, s = a.itemSize * t, l = Math.min(o.length, n.length - s); for (let e = 0, t = s; e < l; e++, t++)n[t] = o[e] } return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e) } normalizeNormals() { const i = this.attributes.normal; for (let e = 0, t = i.count; e < t; e++)c.fromBufferAttribute(i, e), c.normalize(), i.setXYZ(e, c.x, c.y, c.z) } toNonIndexed() { function i(i, r) { const n = i.array, a = i.itemSize, e = i.normalized, o = new n.constructor(r.length * a); let s = 0, l = 0; for (let e = 0, t = r.length; e < t; e++) { s = i.isInterleavedBufferAttribute ? r[e] * i.data.stride + i.offset : r[e] * a; for (let e = 0; e < a; e++)o[l++] = n[s++] } return new P(o, a, e) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; const r = new S, n = this.index.array, a = this.attributes; for (const e in a) { const o = i(a[e], n); r.setAttribute(e, o) } const e = this.morphAttributes; for (const a in e) { const o = [], s = e[a]; for (let e = 0, t = s.length; e < t; e++) { const a = i(s[e], n); o.push(a) } r.morphAttributes[a] = o } r.morphTargetsRelative = this.morphTargetsRelative; const o = this.groups; for (let e = 0, t = o.length; e < t; e++) { const n = o[e]; r.addGroup(n.start, n.count, n.materialIndex) } return r } toJSON() { const i = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), 0 < Object.keys(this.userData).length && (i.userData = this.userData), void 0 !== this.parameters) { const e = this.parameters; for (const r in e) void 0 !== e[r] && (i[r] = e[r]); return i } i.data = { attributes: {} }; const e = this.index, r = (null !== e && (i.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }), this.attributes); for (const e in r) { const n = r[e]; i.data.attributes[e] = n.toJSON(i.data) } const n = {}; let t = !1; for (const e in this.morphAttributes) { const r = this.morphAttributes[e], a = []; for (let e = 0, t = r.length; e < t; e++) { const n = r[e]; a.push(n.toJSON(i.data)) } 0 < a.length && (n[e] = a, t = !0) } t && (i.data.morphAttributes = n, i.data.morphTargetsRelative = this.morphTargetsRelative); const a = this.groups, o = (0 < a.length && (i.data.groups = JSON.parse(JSON.stringify(a))), this.boundingSphere); return null !== o && (i.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), i } clone() { return (new S).copy(this) } copy(e) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; const i = {}, r = (this.name = e.name, e.index), n = (null !== r && this.setIndex(r.clone(i)), e.attributes); for (const e in n) { const r = n[e]; this.setAttribute(e, r.clone(i)) } var t = e.morphAttributes; for (const e in t) { const r = [], n = t[e]; for (let e = 0, t = n.length; e < t; e++)r.push(n[e].clone(i)); this.morphAttributes[e] = r } this.morphTargetsRelative = e.morphTargetsRelative; var a = e.groups; for (let e = 0, t = a.length; e < t; e++) { const i = a[e]; this.addGroup(i.start, i.count, i.materialIndex) } const o = e.boundingBox, s = (null !== o && (this.boundingBox = o.clone()), e.boundingSphere); return null !== s && (this.boundingSphere = s.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this } dispose() { this.dispatchEvent({ type: "dispose" }) } } S.prototype.isBufferGeometry = !0; const bi = new Pe, wi = new pt, Ei = new at, Ti = new Le, Si = new Le, Mi = new Le, Ai = new Le, Ri = new Le, Li = new Le, Pi = new Le, Ci = new Le, Fi = new Le, Di = new k, Ii = new k, Ni = new k, Hi = new Le, Bi = new Le; class M extends u { constructor(e = new S, t = new ti) { super(), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this } updateMorphTargets() { const i = this.geometry; if (i.isBufferGeometry) { var e = i.morphAttributes, t = Object.keys(e); if (0 < t.length) { const i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { var r = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else void 0 !== (e = i.morphTargets) && 0 < e.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } raycast(r, n) { const e = this.geometry, a = this.material, o = this.matrixWorld; if (void 0 !== a && (null === e.boundingSphere && e.computeBoundingSphere(), Ei.copy(e.boundingSphere), Ei.applyMatrix4(o), !1 !== r.ray.intersectsSphere(Ei) && (bi.copy(o).invert(), wi.copy(r.ray).applyMatrix4(bi), null === e.boundingBox || !1 !== wi.intersectsBox(e.boundingBox)))) { let i; if (e.isBufferGeometry) { const o = e.index, d = e.attributes.position, p = e.morphAttributes.position, f = e.morphTargetsRelative, m = e.attributes.uv, v = e.attributes.uv2, g = e.groups, x = e.drawRange; if (null !== o) if (Array.isArray(a)) for (let e = 0, t = g.length; e < t; e++) { var s = g[e], l = a[s.materialIndex]; for (let e = Math.max(s.start, x.start), t = Math.min(s.start + s.count, x.start + x.count); e < t; e += 3) { const a = o.getX(e), y = o.getX(e + 1), _ = o.getX(e + 2); (i = Ui(this, l, r, wi, d, p, f, m, v, a, y, _)) && (i.faceIndex = Math.floor(e / 3), i.face.materialIndex = s.materialIndex, n.push(i)) } } else for (let e = Math.max(0, x.start), t = Math.min(o.count, x.start + x.count); e < t; e += 3) { var c = o.getX(e), h = o.getX(e + 1), u = o.getX(e + 2); (i = Ui(this, a, r, wi, d, p, f, m, v, c, h, u)) && (i.faceIndex = Math.floor(e / 3), n.push(i)) } else if (void 0 !== d) if (Array.isArray(a)) for (let e = 0, t = g.length; e < t; e++) { const o = g[e], b = a[o.materialIndex]; for (let e = Math.max(o.start, x.start), t = Math.min(o.start + o.count, x.start + x.count); e < t; e += 3)(i = Ui(this, b, r, wi, d, p, f, m, v, e, e + 1, e + 2)) && (i.faceIndex = Math.floor(e / 3), i.face.materialIndex = o.materialIndex, n.push(i)) } else for (let e = Math.max(0, x.start), t = Math.min(d.count, x.start + x.count); e < t; e += 3)(i = Ui(this, a, r, wi, d, p, f, m, v, e, e + 1, e + 2)) && (i.faceIndex = Math.floor(e / 3), n.push(i)) } else e.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } } function Ui(e, i, r, t, n, a, o, s, l, c, h, u) { Ti.fromBufferAttribute(n, c), Si.fromBufferAttribute(n, h), Mi.fromBufferAttribute(n, u); var d, p, f, m = e.morphTargetInfluences; if (a && m) { Pi.set(0, 0, 0), Ci.set(0, 0, 0), Fi.set(0, 0, 0); for (let e = 0, t = a.length; e < t; e++) { const i = m[e], r = a[e]; 0 !== i && (Ai.fromBufferAttribute(r, c), Ri.fromBufferAttribute(r, h), Li.fromBufferAttribute(r, u), o ? (Pi.addScaledVector(Ai, i), Ci.addScaledVector(Ri, i), Fi.addScaledVector(Li, i)) : (Pi.addScaledVector(Ai.sub(Ti), i), Ci.addScaledVector(Ri.sub(Si), i), Fi.addScaledVector(Li.sub(Mi), i))) } Ti.add(Pi), Si.add(Ci), Mi.add(Fi) } e.isSkinnedMesh && (e.boneTransform(c, Ti), e.boneTransform(h, Si), e.boneTransform(u, Mi)), n = e, e = i, i = r, r = t, t = Ti, d = Si, p = Mi, f = Hi; const v = null === (1 === e.side ? r.intersectTriangle(p, d, t, !0, f) : r.intersectTriangle(t, d, p, 2 !== e.side, f)) ? null : (Bi.copy(f), Bi.applyMatrix4(n.matrixWorld), (r = i.ray.origin.distanceTo(Bi)) < i.near || r > i.far ? null : { distance: r, point: Bi.clone(), object: n }); if (v) { s && (Di.fromBufferAttribute(s, c), Ii.fromBufferAttribute(s, h), Ni.fromBufferAttribute(s, u), v.uv = x.getUV(Hi, Ti, Si, Mi, Di, Ii, Ni, new k)), l && (Di.fromBufferAttribute(l, c), Ii.fromBufferAttribute(l, h), Ni.fromBufferAttribute(l, u), v.uv2 = x.getUV(Hi, Ti, Si, Mi, Di, Ii, Ni, new k)); const e = { a: c, b: h, c: u, normal: new Le, materialIndex: 0 }; x.getNormal(Ti, Si, Mi, e.normal), v.face = e } return v } M.prototype.isMesh = !0; class zi extends S { constructor(e = 1, t = 1, i = 1, r = 1, n = 1, a = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: n, depthSegments: a }; const b = this, w = (r = Math.floor(r), n = Math.floor(n), a = Math.floor(a), []), E = [], T = [], S = []; let M = 0, A = 0; function o(i, r, n, a, o, s, e, l, c, h, t) { var u = s / c, d = e / h, p = s / 2, f = e / 2, m = l / 2, v = c + 1, g = h + 1; let x = 0, y = 0; const _ = new Le; for (let t = 0; t < g; t++) { const b = t * d - f; for (let e = 0; e < v; e++) { const M = e * u - p; _[i] = M * a, _[r] = b * o, _[n] = m, E.push(_.x, _.y, _.z), _[i] = 0, _[r] = 0, _[n] = 0 < l ? 1 : -1, T.push(_.x, _.y, _.z), S.push(e / c), S.push(1 - t / h), x += 1 } } for (let t = 0; t < h; t++)for (let e = 0; e < c; e++) { const n = M + e + v * t, a = M + e + v * (t + 1), o = M + (e + 1) + v * (t + 1), s = M + (e + 1) + v * t; w.push(n, a, s), w.push(a, o, s), y += 6 } b.addGroup(A, y, t), A += y, M += x } o("z", "y", "x", -1, -1, i, t, e, a, n, 0), o("z", "y", "x", 1, -1, i, t, -e, a, n, 1), o("x", "z", "y", 1, 1, e, i, t, r, a, 2), o("x", "z", "y", 1, -1, e, i, -t, r, a, 3), o("x", "y", "z", 1, -1, e, t, i, r, n, 4), o("x", "y", "z", -1, -1, e, t, -i, r, n, 5), this.setIndex(w), this.setAttribute("position", new G(E, 3)), this.setAttribute("normal", new G(T, 3)), this.setAttribute("uv", new G(S, 2)) } static fromJSON(e) { return new zi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments) } } function Oi(e) { const t = {}; for (const i in e) { t[i] = {}; for (const r in e[i]) { const n = e[i][r]; n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? t[i][r] = n.clone() : Array.isArray(n) ? t[i][r] = n.slice() : t[i][r] = n } } return t } function i(t) { const i = {}; for (let e = 0; e < t.length; e++) { var r = Oi(t[e]); for (const t in r) i[t] = r[t] } return i } const Vi = { clone: Oi, merge: i }; class ki extends t { constructor(e) { super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } copy(e) { return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Oi(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this } toJSON(e) { const t = super.toJSON(e); t.glslVersion = this.glslVersion, t.uniforms = {}; for (const i in this.uniforms) { const r = this.uniforms[i].value; r && r.isTexture ? t.uniforms[i] = { type: "t", value: r.toJSON(e).uuid } : r && r.isColor ? t.uniforms[i] = { type: "c", value: r.getHex() } : r && r.isVector2 ? t.uniforms[i] = { type: "v2", value: r.toArray() } : r && r.isVector3 ? t.uniforms[i] = { type: "v3", value: r.toArray() } : r && r.isVector4 ? t.uniforms[i] = { type: "v4", value: r.toArray() } : r && r.isMatrix3 ? t.uniforms[i] = { type: "m3", value: r.toArray() } : r && r.isMatrix4 ? t.uniforms[i] = { type: "m4", value: r.toArray() } : t.uniforms[i] = { value: r } } 0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; const i = {}; for (const e in this.extensions) !0 === this.extensions[e] && (i[e] = !0); return 0 < Object.keys(i).length && (t.extensions = i), t } } ki.prototype.isShaderMaterial = !0; class Gi extends u { constructor() { super(), this.type = "Camera", this.matrixWorldInverse = new Pe, this.projectionMatrix = new Pe, this.projectionMatrixInverse = new Pe } copy(e, t) { return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this } getWorldDirection(e) { this.updateWorldMatrix(!0, !1); var t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() } updateMatrixWorld(e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix(e, t) { super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone() { return (new this.constructor).copy(this) } } Gi.prototype.isCamera = !0; class C extends Gi { constructor(e = 50, t = 1, i = .1, r = 2e3) { super(), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this } setFocalLength(e) { e = .5 * this.getFilmHeight() / e, this.fov = 2 * de * Math.atan(e), this.updateProjectionMatrix() } getFocalLength() { var e = Math.tan(.5 * ue * this.fov); return .5 * this.getFilmHeight() / e } getEffectiveFOV() { return 2 * de * Math.atan(Math.tan(.5 * ue * this.fov) / this.zoom) } getFilmWidth() { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight() { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset(e, t, i, r, n, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = this.near; let t = e * Math.tan(.5 * ue * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, n = -.5 * r; var a = this.view; if (null !== this.view && this.view.enabled) { const e = a.fullWidth, o = a.fullHeight; n += a.offsetX * r / e, t -= a.offsetY * i / o, r *= a.width / e, i *= a.height / o } const o = this.filmOffset; 0 !== o && (n += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(n, n + r, t, t - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } } C.prototype.isPerspectiveCamera = !0; class Wi extends u { constructor(e, t, i) { if (super(), this.type = "CubeCamera", !0 !== i.isWebGLCubeRenderTarget) console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."); else { this.renderTarget = i; const r = new C(90, 1, e, t), n = (r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Le(1, 0, 0)), this.add(r), new C(90, 1, e, t)), a = (n.layers = this.layers, n.up.set(0, -1, 0), n.lookAt(new Le(-1, 0, 0)), this.add(n), new C(90, 1, e, t)), o = (a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(new Le(0, 1, 0)), this.add(a), new C(90, 1, e, t)), s = (o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new Le(0, -1, 0)), this.add(o), new C(90, 1, e, t)), l = (s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new Le(0, 0, 1)), this.add(s), new C(90, 1, e, t)); l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Le(0, 0, -1)), this.add(l) } } update(e, t) { null === this.parent && this.updateMatrixWorld(); const i = this.renderTarget, [r, n, a, o, s, l] = this.children, c = e.xr.enabled, h = e.getRenderTarget(); e.xr.enabled = !1; var u = i.texture.generateMipmaps; i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, r), e.setRenderTarget(i, 1), e.render(t, n), e.setRenderTarget(i, 2), e.render(t, a), e.setRenderTarget(i, 3), e.render(t, o), e.setRenderTarget(i, 4), e.render(t, s), i.texture.generateMipmaps = u, e.setRenderTarget(i, 5), e.render(t, l), e.setRenderTarget(h), e.xr.enabled = c } } class ji extends h { constructor(e, t, i, r, n, a, o, s, l, c) { super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : A, i, r, n, a, o = void 0 !== o ? o : Z, s, l, c), this.flipY = !1 } get images() { return this.image } set images(e) { this.image = e } } ji.prototype.isCubeTexture = !0; class Xi extends Ue { constructor(e, t, i) { Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t = i), super(e, e, t), t = t || {}, this.texture = new ji(void 0, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : U, this.texture._needsFlipEnvMap = !1 } fromEquirectangularTexture(e, t) { this.texture.type = t.type, this.texture.format = He, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter; const i = new zi(5, 5, 5), r = new ki({ name: "CubemapFromEquirect", uniforms: Oi({ tEquirect: { value: null } }), vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t", fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t", side: 1, blending: 0 }), n = (r.uniforms.tEquirect.value = t, new M(i, r)), a = t.minFilter; return t.minFilter === Fe && (t.minFilter = U), new Wi(1, 10, this).update(e, n), t.minFilter = a, n.geometry.dispose(), n.material.dispose(), this } clear(t, i, r, n) { var e = t.getRenderTarget(); for (let e = 0; e < 6; e++)t.setRenderTarget(this, e), t.clear(i, r, n); t.setRenderTarget(e) } } Xi.prototype.isWebGLCubeRenderTarget = !0; const qi = new Le, Yi = new Le, Qi = new g; class Zi { constructor(e = new Le(1, 0, 0), t = 0) { this.normal = e, this.constant = t } set(e, t) { return this.normal.copy(e), this.constant = t, this } setComponents(e, t, i, r) { return this.normal.set(e, t, i), this.constant = r, this } setFromNormalAndCoplanarPoint(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this } setFromCoplanarPoints(e, t, i) { return i = qi.subVectors(i, t).cross(Yi.subVectors(e, t)).normalize(), this.setFromNormalAndCoplanarPoint(i, e), this } copy(e) { return this.normal.copy(e.normal), this.constant = e.constant, this } normalize() { var e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this } negate() { return this.constant *= -1, this.normal.negate(), this } distanceToPoint(e) { return this.normal.dot(e) + this.constant } distanceToSphere(e) { return this.distanceToPoint(e.center) - e.radius } projectPoint(e, t) { return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) } intersectLine(e, t) { var i = e.delta(qi), r = this.normal.dot(i); return 0 === r ? 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null : (r = -(e.start.dot(this.normal) + this.constant) / r) < 0 || 1 < r ? null : t.copy(i).multiplyScalar(r).add(e.start) } intersectsLine(e) { var t = this.distanceToPoint(e.start), e = this.distanceToPoint(e.end); return t < 0 && 0 < e || e < 0 && 0 < t } intersectsBox(e) { return e.intersectsPlane(this) } intersectsSphere(e) { return e.intersectsPlane(this) } coplanarPoint(e) { return e.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4(e, t) { const i = t || Qi.getNormalMatrix(e), r = this.coplanarPoint(qi).applyMatrix4(e), n = this.normal.applyMatrix3(i).normalize(); return this.constant = -r.dot(n), this } translate(e) { return this.constant -= e.dot(this.normal), this } equals(e) { return e.normal.equals(this.normal) && e.constant === this.constant } clone() { return (new this.constructor).copy(this) } } Zi.prototype.isPlane = !0; const Ji = new at, Ki = new Le; class $i { constructor(e = new Zi, t = new Zi, i = new Zi, r = new Zi, n = new Zi, a = new Zi) { this.planes = [e, t, i, r, n, a] } set(e, t, i, r, n, a) { const o = this.planes; return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(r), o[4].copy(n), o[5].copy(a), this } copy(t) { const i = this.planes; for (let e = 0; e < 6; e++)i[e].copy(t.planes[e]); return this } setFromProjectionMatrix(e) { const t = this.planes, i = e.elements, r = i[0], n = i[1], a = i[2], o = i[3], s = i[4], l = i[5], c = i[6], h = i[7], u = i[8], d = i[9], p = i[10], f = i[11], m = i[12], v = i[13], g = i[14], x = i[15]; return t[0].setComponents(o - r, h - s, f - u, x - m).normalize(), t[1].setComponents(o + r, h + s, f + u, x + m).normalize(), t[2].setComponents(o + n, h + l, f + d, x + v).normalize(), t[3].setComponents(o - n, h - l, f - d, x - v).normalize(), t[4].setComponents(o - a, h - c, f - p, x - g).normalize(), t[5].setComponents(o + a, h + c, f + p, x + g).normalize(), this } intersectsObject(e) { const t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), Ji.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Ji) } intersectsSprite(e) { return Ji.center.set(0, 0, 0), Ji.radius = .7071067811865476, Ji.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ji) } intersectsSphere(e) { const t = this.planes, i = e.center, r = -e.radius; for (let e = 0; e < 6; e++)if (t[e].distanceToPoint(i) < r) return !1; return !0 } intersectsBox(t) { var i = this.planes; for (let e = 0; e < 6; e++) { const r = i[e]; if (Ki.x = (0 < r.normal.x ? t.max : t.min).x, Ki.y = (0 < r.normal.y ? t.max : t.min).y, Ki.z = (0 < r.normal.z ? t.max : t.min).z, r.distanceToPoint(Ki) < 0) return !1 } return !0 } containsPoint(t) { const i = this.planes; for (let e = 0; e < 6; e++)if (i[e].distanceToPoint(t) < 0) return !1; return !0 } clone() { return (new this.constructor).copy(this) } } function er() { let i = null, e = !1, r = null, n = null; function a(e, t) { r(e, t), n = i.requestAnimationFrame(a) } return { start: function () { !0 !== e && null !== r && (n = i.requestAnimationFrame(a), e = !0) }, stop: function () { i.cancelAnimationFrame(n), e = !1 }, setAnimationLoop: function (e) { r = e }, setContext: function (e) { i = e } } } function tr(s, e) { const l = e.isWebGL2, c = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), c.get(e) }, remove: function (e) { e.isInterleavedBufferAttribute && (e = e.data); var t = c.get(e); t && (s.deleteBuffer(t.buffer), c.delete(e)) }, update: function (e, t) { if (e.isGLBufferAttribute) { const s = c.get(e); (!s || s.version < e.version) && c.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version }) } else { e.isInterleavedBufferAttribute && (e = e.data); const n = c.get(e); if (void 0 === n) c.set(e, function (e, t) { var i = e.array, r = e.usage, n = s.createBuffer(); s.bindBuffer(t, n), s.bufferData(t, i, r), e.onUploadCallback(); let a = 5126; return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? e.isFloat16BufferAttribute ? l ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : (i instanceof Uint8Array || i instanceof Uint8ClampedArray) && (a = 5121), { buffer: n, type: a, bytesPerElement: i.BYTES_PER_ELEMENT, version: e.version } }(e, t)); else if (n.version < e.version) { { var i = n.buffer, r = e; const a = r.array, o = r.updateRange; s.bindBuffer(t, i), -1 === o.count ? s.bufferSubData(t, 0, a) : (l ? s.bufferSubData(t, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : s.bufferSubData(t, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1) } n.version = e.version } } } } } class ir extends S { constructor(e = 1, i = 1, r = 1, n = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: i, widthSegments: r, heightSegments: n }; const a = e / 2, o = i / 2, s = Math.floor(r), l = Math.floor(n), c = s + 1, h = l + 1, u = e / s, d = i / l, p = [], f = [], m = [], v = []; for (let t = 0; t < h; t++) { const i = t * d - o; for (let e = 0; e < c; e++) { const n = e * u - a; f.push(n, -i, 0), m.push(0, 0, 1), v.push(e / s), v.push(1 - t / l) } } for (let t = 0; t < l; t++)for (let e = 0; e < s; e++) { const r = e + c * t, n = e + c * (t + 1), a = e + 1 + c * (t + 1), o = e + 1 + c * t; p.push(r, n, o), p.push(n, a, o) } this.setIndex(p), this.setAttribute("position", new G(f, 3)), this.setAttribute("normal", new G(m, 3)), this.setAttribute("uv", new G(v, 2)) } static fromJSON(e) { return new ir(e.width, e.height, e.widthSegments, e.heightSegments) } } const E = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif", transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, T = { common: { diffuse: { value: new y(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new g }, uv2Transform: { value: new g }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new k(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new y(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new y(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new g } }, sprite: { diffuse: { value: new y(16777215) }, opacity: { value: 1 }, center: { value: new k(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new g } } }, rr = { basic: { uniforms: i([T.common, T.specularmap, T.envmap, T.aomap, T.lightmap, T.fog]), vertexShader: E.meshbasic_vert, fragmentShader: E.meshbasic_frag }, lambert: { uniforms: i([T.common, T.specularmap, T.envmap, T.aomap, T.lightmap, T.emissivemap, T.fog, T.lights, { emissive: { value: new y(0) } }]), vertexShader: E.meshlambert_vert, fragmentShader: E.meshlambert_frag }, phong: { uniforms: i([T.common, T.specularmap, T.envmap, T.aomap, T.lightmap, T.emissivemap, T.bumpmap, T.normalmap, T.displacementmap, T.fog, T.lights, { emissive: { value: new y(0) }, specular: { value: new y(1118481) }, shininess: { value: 30 } }]), vertexShader: E.meshphong_vert, fragmentShader: E.meshphong_frag }, standard: { uniforms: i([T.common, T.envmap, T.aomap, T.lightmap, T.emissivemap, T.bumpmap, T.normalmap, T.displacementmap, T.roughnessmap, T.metalnessmap, T.fog, T.lights, { emissive: { value: new y(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: E.meshphysical_vert, fragmentShader: E.meshphysical_frag }, toon: { uniforms: i([T.common, T.aomap, T.lightmap, T.emissivemap, T.bumpmap, T.normalmap, T.displacementmap, T.gradientmap, T.fog, T.lights, { emissive: { value: new y(0) } }]), vertexShader: E.meshtoon_vert, fragmentShader: E.meshtoon_frag }, matcap: { uniforms: i([T.common, T.bumpmap, T.normalmap, T.displacementmap, T.fog, { matcap: { value: null } }]), vertexShader: E.meshmatcap_vert, fragmentShader: E.meshmatcap_frag }, points: { uniforms: i([T.points, T.fog]), vertexShader: E.points_vert, fragmentShader: E.points_frag }, dashed: { uniforms: i([T.common, T.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: E.linedashed_vert, fragmentShader: E.linedashed_frag }, depth: { uniforms: i([T.common, T.displacementmap]), vertexShader: E.depth_vert, fragmentShader: E.depth_frag }, normal: { uniforms: i([T.common, T.bumpmap, T.normalmap, T.displacementmap, { opacity: { value: 1 } }]), vertexShader: E.normal_vert, fragmentShader: E.normal_frag }, sprite: { uniforms: i([T.sprite, T.fog]), vertexShader: E.sprite_vert, fragmentShader: E.sprite_frag }, background: { uniforms: { uvTransform: { value: new g }, t2D: { value: null } }, vertexShader: E.background_vert, fragmentShader: E.background_frag }, cube: { uniforms: i([T.envmap, { opacity: { value: 1 } }]), vertexShader: E.cube_vert, fragmentShader: E.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: E.equirect_vert, fragmentShader: E.equirect_frag }, distanceRGBA: { uniforms: i([T.common, T.displacementmap, { referencePosition: { value: new Le }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: E.distanceRGBA_vert, fragmentShader: E.distanceRGBA_frag }, shadow: { uniforms: i([T.lights, T.fog, { color: { value: new y(0) }, opacity: { value: 1 } }]), vertexShader: E.shadow_vert, fragmentShader: E.shadow_frag } }; function nr(o, s, i, l, r) { const c = new y(0); let h, u, d = 0, p = null, f = 0, m = null; function v(e, t) { i.buffers.color.setClear(e.r, e.g, e.b, t, r) } return { getClearColor: function () { return c }, setClearColor: function (e, t = 1) { c.set(e), d = t, v(c, d) }, getClearAlpha: function () { return d }, setClearAlpha: function (e) { d = e, v(c, d) }, render: function (e, t) { let i = !1, r = !0 === t.isScene ? t.background : null; r && r.isTexture && (r = s.get(r)); const n = o.xr, a = n.getSession && n.getSession(); null === (r = a && "additive" === a.environmentBlendMode ? null : r) ? v(c, d) : r && r.isColor && (v(r, 1), i = !0), (o.autoClear || i) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil), r && (r.isCubeTexture || r.mapping === D) ? (void 0 === u && ((u = new M(new zi(1, 1, 1), new ki({ name: "BackgroundCubeMaterial", uniforms: Oi(rr.cube.uniforms), vertexShader: rr.cube.vertexShader, fragmentShader: rr.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function (e, t, i) { this.matrixWorld.copyPosition(i.matrixWorld) }, Object.defineProperty(u.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), l.update(u)), u.material.uniforms.envMap.value = r, u.material.uniforms.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, p === r && f === r.version && m === o.toneMapping || (u.material.needsUpdate = !0, p = r, f = r.version, m = o.toneMapping), e.unshift(u, u.geometry, u.material, 0, 0, null)) : r && r.isTexture && (void 0 === h && ((h = new M(new ir(2, 2), new ki({ name: "BackgroundMaterial", uniforms: Oi(rr.background.uniforms), vertexShader: rr.background.vertexShader, fragmentShader: rr.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", { get: function () { return this.uniforms.t2D.value } }), l.update(h)), !0 === (h.material.uniforms.t2D.value = r).matrixAutoUpdate && r.updateMatrix(), h.material.uniforms.uvTransform.value.copy(r.matrix), p === r && f === r.version && m === o.toneMapping || (h.material.needsUpdate = !0, p = r, f = r.version, m = o.toneMapping), e.unshift(h, h.geometry, h.material, 0, 0, null)) } } } function ar(w, E, T, S) { const n = w.getParameter(34921), M = S.isWebGL2 ? null : E.get("OES_vertex_array_object"), A = S.isWebGL2 || null !== M, R = {}, e = C(null); let L = e; function P(e) { S.isWebGL2 ? w.bindVertexArray(e) : M.bindVertexArrayOES(e) } function a(e) { S.isWebGL2 ? w.deleteVertexArray(e) : M.deleteVertexArrayOES(e) } function C(e) { const t = [], i = [], r = []; for (let e = 0; e < n; e++)t[e] = 0, i[e] = 0, r[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: i, attributeDivisors: r, object: e, attributes: {}, index: null } } function F() { const i = L.newAttributes; for (let e = 0, t = i.length; e < t; e++)i[e] = 0 } function D(e) { I(e, 0) } function I(e, t) { const i = L.newAttributes, r = L.enabledAttributes, n = L.attributeDivisors; i[e] = 1, 0 === r[e] && (w.enableVertexAttribArray(e), r[e] = 1), n[e] !== t && ((S.isWebGL2 ? w : E.get("ANGLE_instanced_arrays"))[S.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t), n[e] = t) } function N() { const i = L.newAttributes, r = L.enabledAttributes; for (let e = 0, t = r.length; e < t; e++)r[e] !== i[e] && (w.disableVertexAttribArray(e), r[e] = 0) } function H(e, t, i, r, n, a) { !0 !== S.isWebGL2 || 5124 !== i && 5125 !== i ? w.vertexAttribPointer(e, t, i, r, n, a) : w.vertexAttribIPointer(e, t, i, n, a) } function o() { t(), L !== e && P((L = e).object) } function t() { e.geometry = null, e.program = null, e.wireframe = !1 } return { setup: function (e, o, t, i, r) { let n = !1; if (A) { const E = function (e, t) { var i = !0 === o.wireframe; let r = R[e.id], n = (void 0 === r && (r = {}, R[e.id] = r), r[t.id]), a = (void 0 === n && (n = {}, r[t.id] = n), n[i]); return void 0 === a && (a = C(S.isWebGL2 ? w.createVertexArray() : M.createVertexArrayOES()), n[i] = a), a }(i, t); if (L !== E && P((L = E).object), n = function (e, t) { var i = L.attributes, r = e.attributes; let n = 0; for (const e in r) { const t = i[e], a = r[e]; if (void 0 === t) return !0; if (t.attribute !== a) return !0; if (t.data !== a.data) return !0; n++ } return L.attributesNum !== n || L.index !== t }(i, r)) { var a = i, s = r; const x = {}, y = a.attributes; let e = 0; for (const a in y) { const s = y[a], _ = {}; (_.attribute = s).data && (_.data = s.data), x[a] = _, e++ } L.attributes = x, L.attributesNum = e, L.index = s } } else { const w = !0 === o.wireframe; L.geometry === i.id && L.program === t.id && L.wireframe === w || (L.geometry = i.id, L.program = t.id, L.wireframe = w, n = !0) } if (!0 === e.isInstancedMesh && (n = !0), null !== r && T.update(r, 34963), n) { var l = e, c = o, h = t, u = i; if (!1 !== S.isWebGL2 || !l.isInstancedMesh && !u.isInstancedBufferGeometry || null !== E.get("ANGLE_instanced_arrays")) { F(); var d = u.attributes, p = h.getAttributes(), f = c.defaultAttributeValues; for (const E in p) { const S = p[E]; if (0 <= S) { const c = d[E]; if (void 0 !== c) { const E = c.normalized, l = c.itemSize, h = T.get(c); if (void 0 !== h) { var m = h.buffer, v = h.type, g = h.bytesPerElement; if (c.isInterleavedBufferAttribute) { const T = c.data, h = T.stride, b = c.offset; T && T.isInstancedInterleavedBuffer ? (I(S, T.meshPerAttribute), void 0 === u._maxInstanceCount && (u._maxInstanceCount = T.meshPerAttribute * T.count)) : D(S), w.bindBuffer(34962, m), H(S, l, v, E, h * g, b * g) } else c.isInstancedBufferAttribute ? (I(S, c.meshPerAttribute), void 0 === u._maxInstanceCount && (u._maxInstanceCount = c.meshPerAttribute * c.count)) : D(S), w.bindBuffer(34962, m), H(S, l, v, E, 0, 0) } } else if ("instanceMatrix" === E) { const E = T.get(l.instanceMatrix); if (void 0 !== E) { const c = E.buffer, h = E.type; I(S + 0, 1), I(S + 1, 1), I(S + 2, 1), I(S + 3, 1), w.bindBuffer(34962, c), w.vertexAttribPointer(S + 0, 4, h, !1, 64, 0), w.vertexAttribPointer(S + 1, 4, h, !1, 64, 16), w.vertexAttribPointer(S + 2, 4, h, !1, 64, 32), w.vertexAttribPointer(S + 3, 4, h, !1, 64, 48) } } else if ("instanceColor" === E) { const E = T.get(l.instanceColor); if (void 0 !== E) { const c = E.buffer, h = E.type; I(S, 1), w.bindBuffer(34962, c), w.vertexAttribPointer(S, 3, h, !1, 12, 0) } } else if (void 0 !== f) { const T = f[E]; if (void 0 !== T) switch (T.length) { case 2: w.vertexAttrib2fv(S, T); break; case 3: w.vertexAttrib3fv(S, T); break; case 4: w.vertexAttrib4fv(S, T); break; default: w.vertexAttrib1fv(S, T) } } } } N() } null !== r && w.bindBuffer(34963, T.get(r).buffer) } }, reset: o, resetDefaultState: t, dispose: function () { o(); for (const e in R) { const t = R[e]; for (const i in t) { const r = t[i]; for (const n in r) a(r[n].object), delete r[n]; delete t[i] } delete R[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 !== R[e.id]) { const t = R[e.id]; for (const e in t) { const i = t[e]; for (const e in i) a(i[e].object), delete i[e]; delete t[e] } delete R[e.id] } }, releaseStatesOfProgram: function (e) { for (const t in R) { const i = R[t]; if (void 0 !== i[e.id]) { const r = i[e.id]; for (const e in r) a(r[e].object), delete r[e]; delete i[e.id] } } }, initAttributes: F, enableAttribute: D, disableUnusedAttributes: N } } function or(a, o, s, e) { const l = e.isWebGL2; let c; this.setMode = function (e) { c = e }, this.render = function (e, t) { a.drawArrays(c, e, t), s.update(t, c, 1) }, this.renderInstances = function (i, r, n) { if (0 !== n) { let e, t; if (l) e = a, t = "drawArraysInstanced"; else if (e = o.get("ANGLE_instanced_arrays"), t = "drawArraysInstancedANGLE", null === e) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); e[t](c, i, r, n), s.update(r, c, n) } } } function sr(t, i, e) { let r; function n(e) { if ("highp" === e) { if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp"; e = "mediump" } return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp" } var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext; let o = void 0 !== e.precision ? e.precision : "highp"; (s = n(o)) !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s); var s = a || i.has("WEBGL_draw_buffers"), e = !0 === e.logarithmicDepthBuffer, l = t.getParameter(34930), c = t.getParameter(35660), h = t.getParameter(3379), u = t.getParameter(34076), d = t.getParameter(34921), p = t.getParameter(36347), f = t.getParameter(36348), m = t.getParameter(36349), v = 0 < c, g = a || i.has("OES_texture_float"); return { isWebGL2: a, drawBuffers: s, getMaxAnisotropy: function () { return void 0 !== r ? r : r = !0 === i.has("EXT_texture_filter_anisotropic") ? (e = i.get("EXT_texture_filter_anisotropic"), t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT)) : 0; var e }, getMaxPrecision: n, precision: o, logarithmicDepthBuffer: e, maxTextures: l, maxVertexTextures: c, maxTextureSize: h, maxCubemapSize: u, maxAttributes: d, maxVertexUniforms: p, maxVaryings: f, maxFragmentUniforms: m, vertexTextures: v, floatFragmentTextures: g, floatVertexTextures: v && g, maxSamples: a ? t.getParameter(36183) : 0 } } function lr(s) { const t = this; let l = null, c = 0, h = !1, u = !1; const d = new Zi, p = new g, f = { value: null, needsUpdate: !1 }; function m() { f.value !== l && (f.value = l, f.needsUpdate = 0 < c), t.numPlanes = c, t.numIntersection = 0 } function v(i, e, r, n) { var a = null !== i ? i.length : 0; let o = null; if (0 !== a) { if (o = f.value, !0 !== n || null === o) { const t = r + 4 * a, n = e.matrixWorldInverse; p.getNormalMatrix(n), (null === o || o.length < t) && (o = new Float32Array(t)); for (let e = 0, t = r; e !== a; ++e, t += 4)d.copy(i[e]).applyMatrix4(n, p), d.normal.toArray(o, t), o[t + 3] = d.constant } f.value = o, f.needsUpdate = !0 } return t.numPlanes = a, t.numIntersection = 0, o } this.uniform = f, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, i) { var r = 0 !== e.length || t || 0 !== c || h; return h = t, l = v(e, i, 0), c = e.length, r }, this.beginShadows = function () { u = !0, v(null) }, this.endShadows = function () { u = !1, m() }, this.setState = function (i, e, r) { const n = i.clippingPlanes, a = i.clipIntersection, t = i.clipShadows, o = s.get(i); if (!h || null === n || 0 === n.length || u && !t) u ? v(null) : m(); else { const s = u ? 0 : c, i = 4 * s; let t = o.clippingState || null; f.value = t, t = v(n, e, i, r); for (let e = 0; e !== i; ++e)t[e] = l[e]; o.clippingState = t, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += s } } } function cr(i) { let r = new WeakMap; function n(e, t) { return t === L ? e.mapping = A : t === F && (e.mapping = R), e } function a(e) { const t = e.target, i = (t.removeEventListener("dispose", a), r.get(t)); void 0 !== i && (r.delete(t), i.dispose()) } return { get: function (e) { if (e && e.isTexture && !1 === e.isRenderTargetTexture) { var t = e.mapping; if (t === L || t === F) { if (r.has(e)) return n(r.get(e).texture, e.mapping); if ((t = e.image) && 0 < t.height) { const L = i.getRenderTarget(), F = new Xi(t.height / 2); return F.fromEquirectangularTexture(i, e), r.set(e, F), i.setRenderTarget(L), e.addEventListener("dispose", a), n(F.texture, e.mapping) } return null } } return e }, dispose: function () { r = new WeakMap } } } rr.physical = { uniforms: i([rr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new k(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new y(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new k }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationTint: { value: new y(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularTint: { value: new y(1, 1, 1) }, specularTintMap: { value: null } }]), vertexShader: E.meshphysical_vert, fragmentShader: E.meshphysical_frag }; class hr extends Gi { constructor(e = -1, t = 1, i = 1, r = -1, n = .1, a = 2e3) { super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = n, this.far = a, this.updateProjectionMatrix() } copy(e, t) { return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this } setViewOffset(e, t, i, r, n, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = n, this.view.height = a, this.updateProjectionMatrix() } clearViewOffset() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix() { const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2; let n = i - e, a = i + e, o = r + t, s = r - t; if (null !== this.view && this.view.enabled) { const e = (this.right - this.left) / this.view.fullWidth / this.zoom, t = (this.top - this.bottom) / this.view.fullHeight / this.zoom; n += e * this.view.offsetX, a = n + e * this.view.width, o -= t * this.view.offsetY, s = o - t * this.view.height } this.projectionMatrix.makeOrthographic(n, a, o, s, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON(e) { const t = super.toJSON(e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } } hr.prototype.isOrthographicCamera = !0; class ur extends ki { constructor(e) { super(e), this.type = "RawShaderMaterial" } } ur.prototype.isRawShaderMaterial = !0; const dr = Math.pow(2, 8), pr = [.125, .215, .35, .446, .526, .582], fr = 5 + pr.length, mr = { [Be]: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 }, vr = new ti({ side: 1, depthWrite: !1, depthTest: !1 }), gr = new M(new zi, vr), xr = new hr, { _lodPlanes: yr, _sizeLods: _r, _sigmas: br } = function () { const i = [], r = [], n = []; let a = 8; for (let t = 0; t < fr; t++) { var o = Math.pow(2, a); r.push(o); let e = 1 / o; 4 < t ? e = pr[t - 8 + 4 - 1] : 0 == t && (e = 0), n.push(e); const l = 1 / (o - 1), c = -l / 2, h = 1 + l / 2, u = [c, c, h, c, h, h, c, c, h, h, c, h], d = new Float32Array(108), p = new Float32Array(72), f = new Float32Array(36); for (let e = 0; e < 6; e++) { const r = e % 3 * 2 / 3 - 1, n = 2 < e ? 0 : -1, a = [r, n, 0, r + 2 / 3, n, 0, r + 2 / 3, 1 + n, 0, r, n, 0, r + 2 / 3, 1 + n, 0, r, 1 + n, 0]; d.set(a, 18 * e), p.set(u, 12 * e); var s = [e, e, e, e, e, e]; f.set(s, 6 * e) } const m = new S; m.setAttribute("position", new P(d, 3)), m.setAttribute("uv", new P(p, 2)), m.setAttribute("faceIndex", new P(f, 1)), i.push(m), 4 < a && a-- } return { _lodPlanes: i, _sizeLods: r, _sigmas: n } }(), wr = new y; let Er = null; const Tr = (1 + Math.sqrt(5)) / 2, Sr = 1 / Tr, Mr = [new Le(1, 1, 1), new Le(-1, 1, 1), new Le(1, 1, -1), new Le(-1, 1, -1), new Le(0, Tr, Sr), new Le(0, Tr, -Sr), new Le(Sr, 0, Tr), new Le(-Sr, 0, Tr), new Le(Tr, Sr, 0), new Le(-Tr, Sr, 0)]; function Ar(e) { var t = Math.max(e.r, e.g, e.b), t = Math.min(Math.max(Math.ceil(Math.log2(t)), -128), 127); return e.multiplyScalar(Math.pow(2, -t)), (t + 128) / 255 } class Rr {
		constructor(e) {
			var t; this._renderer = e, this._pingPongRenderTarget = null, this._blurMaterial = (e = new Float32Array(20), t = new Le(0, 1, 0), new ur({
				name: "SphericalGaussianBlur", defines: { n: 20 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: e }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: t }, inputEncoding: { value: mr[3e3] }, outputEncoding: { value: mr[3e3] } }, vertexShader: Dr(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Ir()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1
			})), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
		} fromScene(e, t = 0, i = .1, r = 100) { Er = this._renderer.getRenderTarget(); var n = this._allocateTargets(); return this._sceneToCubeUV(e, i, r, n), 0 < t && this._blur(n, 0, 0, t), this._applyPMREM(n), this._cleanup(n), n } fromEquirectangular(e) { return this._fromTexture(e) } fromCubemap(e) { return this._fromTexture(e) } compileCubemapShader() { null === this._cubemapShader && (this._cubemapShader = Fr(), this._compileMaterial(this._cubemapShader)) } compileEquirectangularShader() { null === this._equirectShader && (this._equirectShader = Cr(), this._compileMaterial(this._equirectShader)) } dispose() { this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose(); for (let e = 0; e < yr.length; e++)yr[e].dispose() } _cleanup(e) { this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(Er), e.scissorTest = !1, Pr(e, 0, 0, e.width, e.height) } _fromTexture(e) { Er = this._renderer.getRenderTarget(); var t = this._allocateTargets(e); return this._textureToCubeUV(e, t), this._applyPMREM(t), this._cleanup(t), t } _allocateTargets(e) { const t = { magFilter: Ae, minFilter: Ae, generateMipmaps: !1, type: De, format: 1023, encoding: void 0 === (r = e) || r.type !== De || r.encoding !== Be && 3001 !== r.encoding && 3007 !== r.encoding ? 3002 : e.encoding, depthBuffer: !1 }, i = Lr(t); var r; return i.depthBuffer = !e, this._pingPongRenderTarget = Lr(t), i } _compileMaterial(e) { e = new M(yr[0], e), this._renderer.compile(e, xr) } _sceneToCubeUV(t, e, i, r) { const n = new C(90, 1, e, i), a = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], s = this._renderer, l = s.autoClear, c = s.outputEncoding, h = s.toneMapping; s.getClearColor(wr), s.toneMapping = 0, s.outputEncoding = Be; let u = s.autoClear = !1; if (i = t.background) { if (i.isColor) { vr.color.copy(i).convertSRGBToLinear(), t.background = null; const e = Ar(vr.color); vr.opacity = e, u = !0 } } else { vr.color.copy(wr).convertSRGBToLinear(); const t = Ar(vr.color); vr.opacity = t, u = !0 } for (let e = 0; e < 6; e++) { const i = e % 3; 0 == i ? (n.up.set(0, a[e], 0), n.lookAt(o[e], 0, 0)) : 1 == i ? (n.up.set(0, 0, a[e]), n.lookAt(0, o[e], 0)) : (n.up.set(0, a[e], 0), n.lookAt(0, 0, o[e])), Pr(r, i * dr, 2 < e ? dr : 0, dr, dr), s.setRenderTarget(r), u && s.render(gr, n), s.render(t, n) } s.toneMapping = h, s.outputEncoding = c, s.autoClear = l } _textureToCubeUV(e, t) { const i = this._renderer, r = (e.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Fr()) : null == this._equirectShader && (this._equirectShader = Cr()), e.isCubeTexture ? this._cubemapShader : this._equirectShader), n = new M(yr[0], r), a = r.uniforms; (a.envMap.value = e).isCubeTexture || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height), a.inputEncoding.value = mr[e.encoding], a.outputEncoding.value = mr[t.texture.encoding], Pr(t, 0, 0, 3 * dr, 2 * dr), i.setRenderTarget(t), i.render(n, xr) } _applyPMREM(t) { const e = this._renderer, i = e.autoClear; e.autoClear = !1; for (let e = 1; e < fr; e++) { const i = Math.sqrt(br[e] * br[e] - br[e - 1] * br[e - 1]), r = Mr[(e - 1) % Mr.length]; this._blur(t, e - 1, e, i, r) } e.autoClear = i } _blur(e, t, i, r, n) { var a = this._pingPongRenderTarget; this._halfBlur(e, a, t, i, r, "latitudinal", n), this._halfBlur(a, e, i, i, r, "longitudinal", n) } _halfBlur(e, t, i, r, n, a, o) { const s = this._renderer, l = this._blurMaterial, c = ("latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!"), new M(yr[r], l)), h = l.uniforms, u = _r[i] - 1, d = isFinite(n) ? Math.PI / (2 * u) : 2 * Math.PI / 39, p = n / d, f = isFinite(n) ? 1 + Math.floor(3 * p) : 20, m = (20 < f && console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`), []); let v = 0; for (let e = 0; e < 20; ++e) { const t = e / p, i = Math.exp(-t * t / 2); m.push(i), 0 == e ? v += i : e < f && (v += 2 * i) } for (let e = 0; e < m.length; e++)m[e] = m[e] / v; h.envMap.value = e.texture, h.samples.value = f, h.weights.value = m, h.latitudinal.value = "latitudinal" === a, o && (h.poleAxis.value = o), h.dTheta.value = d, h.mipInt.value = 8 - i, h.inputEncoding.value = mr[e.texture.encoding], h.outputEncoding.value = mr[e.texture.encoding], n = _r[r], Pr(t, 3 * Math.max(0, dr - 2 * n), (0 === r ? 0 : 2 * dr) + 2 * n * (4 < r ? r - 8 + 4 : 0), 3 * n, 2 * n), s.setRenderTarget(t), s.render(c, xr) }
	} function Lr(e) { const t = new Ue(3 * dr, 3 * dr, e); return t.texture.mapping = D, t.texture.name = "PMREM.cubeUv", t.scissorTest = !0, t } function Pr(e, t, i, r, n) { e.viewport.set(t, i, r, n), e.scissor.set(t, i, r, n) } function Cr() {
		var e = new k(1, 1); return new ur({
			name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: e }, inputEncoding: { value: mr[3e3] }, outputEncoding: { value: mr[3e3] } }, vertexShader: Dr(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Ir()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1
		})
	} function Fr() {
		return new ur({
			name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: mr[3e3] }, outputEncoding: { value: mr[3e3] } }, vertexShader: Dr(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Ir()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: 0, depthTest: !1, depthWrite: !1
		})
	} function Dr() { return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t" } function Ir() { return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t" } function Nr(r) { let n = new WeakMap, a = null; function o(e) { const t = e.target, i = (t.removeEventListener("dispose", o), n.get(t)); void 0 !== i && (i.delete(t), i.dispose()) } return { get: function (e) { if (e && e.isTexture && !1 === e.isRenderTargetTexture) { var t = (i = e.mapping) === L || i === F, i = i === A || i === R; if (t || i) { if (n.has(e)) return n.get(e).texture; { const A = e.image; if (t && A && 0 < A.height || i && A && function (t) { let i = 0; for (let e = 0; e < 6; e++)void 0 !== t[e] && i++; return 6 === i }(A)) { const A = r.getRenderTarget(), R = (null === a && (a = new Rr(r)), t ? a.fromEquirectangular(e) : a.fromCubemap(e)); return n.set(e, R), r.setRenderTarget(A), e.addEventListener("dispose", o), R.texture } return null } } } return e }, dispose: function () { n = new WeakMap, null !== a && (a.dispose(), a = null) } } } function Hr(i) { const r = {}; function n(e) { if (void 0 !== r[e]) return r[e]; let t; switch (e) { case "WEBGL_depth_texture": t = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": t = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": t = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": t = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: t = i.getExtension(e) }return r[e] = t } return { has: function (e) { return null !== n(e) }, init: function (e) { e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float") }, get: function (e) { var t = n(e); return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t } } } function Br(e, d, i, r) { const n = {}, p = new WeakMap; function a(e) { const t = e.target; null !== t.index && d.remove(t.index); for (const e in t.attributes) d.remove(t.attributes[e]); t.removeEventListener("dispose", a), delete n[t.id], (e = p.get(t)) && (d.remove(e), p.delete(t)), r.releaseStatesOfGeometry(t), !0 === t.isInstancedBufferGeometry && delete t._maxInstanceCount, i.memory.geometries-- } return { get: function (e, t) { return !0 !== n[t.id] && (t.addEventListener("dispose", a), n[t.id] = !0, i.memory.geometries++), t }, update: function (e) { const i = e.attributes; for (const e in i) d.update(i[e], 34962); var t = e.morphAttributes; for (const e in t) { const i = t[e]; for (let e = 0, t = i.length; e < t; e++)d.update(i[e], 34962) } }, getWireframeAttribute: function (t) { var e, i = p.get(t); if (!i || null !== (e = t.index) && i.version < e.version) { var r = t; const n = [], a = r.index, o = r.attributes.position; let e = 0; if (null !== a) { const r = a.array; e = a.version; for (let e = 0, t = r.length; e < t; e += 3) { const l = r[e + 0], c = r[e + 1], p = r[e + 2]; n.push(l, c, c, p, p, l) } } else { const r = o.array; e = o.version; for (let e = 0, t = r.length / 3 - 1; e < t; e += 3) { const r = e + 0, h = e + 1, u = e + 2; n.push(r, h, h, u, u, r) } } const s = new (65535 < di(n) ? ci : si)(n, 1); s.version = e, (i = p.get(r)) && d.remove(i), p.set(r, s) } return p.get(t) } } } function Ur(a, o, s, e) { const l = e.isWebGL2; let c, h, u; this.setMode = function (e) { c = e }, this.setIndex = function (e) { h = e.type, u = e.bytesPerElement }, this.render = function (e, t) { a.drawElements(c, t, h, e * u), s.update(t, c, 1) }, this.renderInstances = function (i, r, n) { if (0 !== n) { let e, t; if (l) e = a, t = "drawElementsInstanced"; else if (e = o.get("ANGLE_instanced_arrays"), t = "drawElementsInstancedANGLE", null === e) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); e[t](c, r, h, i * u, n), s.update(r, c, n) } } } function zr(e) { const r = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: r, programs: null, autoReset: !0, reset: function () { r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0 }, update: function (e, t, i) { switch (r.calls++, t) { case 4: r.triangles += i * (e / 3); break; case 1: r.lines += i * (e / 2); break; case 3: r.lines += i * (e - 1); break; case 2: r.lines += i * e; break; case 0: r.points += i * e; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", t) } } } } function Or(e, t) { return e[0] - t[0] } function Vr(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function kr(h) { const u = {}, d = new Float32Array(8), p = []; for (let e = 0; e < 8; e++)p[e] = [e, 0]; return { update: function (t, i, r, e) { var n = t.morphTargetInfluences, a = void 0 === n ? 0 : n.length; let o = u[i.id]; if (void 0 === o || o.length !== a) { o = []; for (let e = 0; e < a; e++)o[e] = [e, 0]; u[i.id] = o } for (let e = 0; e < a; e++) { const u = o[e]; u[0] = e, u[1] = n[e] } o.sort(Vr); for (let e = 0; e < 8; e++)e < a && o[e][1] ? (p[e][0] = o[e][0], p[e][1] = o[e][1]) : (p[e][0] = Number.MAX_SAFE_INTEGER, p[e][1] = 0); p.sort(Or); var s = i.morphAttributes.position, l = i.morphAttributes.normal; let c = 0; for (let e = 0; e < 8; e++) { const u = p[e], t = u[0], r = u[1]; t !== Number.MAX_SAFE_INTEGER && r ? (s && i.getAttribute("morphTarget" + e) !== s[t] && i.setAttribute("morphTarget" + e, s[t]), l && i.getAttribute("morphNormal" + e) !== l[t] && i.setAttribute("morphNormal" + e, l[t]), d[e] = r, c += r) : (s && !0 === i.hasAttribute("morphTarget" + e) && i.deleteAttribute("morphTarget" + e), l && !0 === i.hasAttribute("morphNormal" + e) && i.deleteAttribute("morphNormal" + e), d[e] = 0) } t = i.morphTargetsRelative ? 1 : 1 - c, e.getUniforms().setValue(h, "morphTargetBaseInfluence", t), e.getUniforms().setValue(h, "morphTargetInfluences", d) } } } function Gr(e, r, n, a) { let o = new WeakMap; function s(e) { const t = e.target; t.removeEventListener("dispose", s), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor) } return { update: function (e) { var t = a.render.frame, i = e.geometry, i = r.get(e, i); return o.get(i) !== t && (r.update(i), o.set(i, t)), e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s), n.update(e.instanceMatrix, 34962), null !== e.instanceColor && n.update(e.instanceColor, 34962)), i }, dispose: function () { o = new WeakMap } } } class Wr extends h { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = Ae, this.minFilter = Ae, this.wrapR = Ce, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } class jr extends h { constructor(e = null, t = 1, i = 1, r = 1) { super(null), this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = Ae, this.minFilter = Ae, this.wrapR = Ce, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } jr.prototype.isDataTexture3D = Wr.prototype.isDataTexture2DArray = !0; const Xr = new h, qr = new Wr, Yr = new jr, Qr = new ji, Zr = [], Jr = [], Kr = new Float32Array(16), $r = new Float32Array(9), en = new Float32Array(4); function tn(i, r, n) { const e = i[0]; if (e <= 0 || 0 < e) return i; var t = r * n; let a = Zr[t]; if (void 0 === a && (a = new Float32Array(t), Zr[t] = a), 0 !== r) { e.toArray(a, 0); for (let e = 1, t = 0; e !== r; ++e)t += n, i[e].toArray(a, t) } return a } function rn(i, r) { if (i.length === r.length) { for (let e = 0, t = i.length; e < t; e++)if (i[e] !== r[e]) return; return 1 } } function a(i, r) { for (let e = 0, t = r.length; e < t; e++)i[e] = r[e] } function nn(t, i) { let r = Jr[i]; void 0 === r && (r = new Int32Array(i), Jr[i] = r); for (let e = 0; e !== i; ++e)r[e] = t.allocateTextureUnit(); return r } function an(e, t) { const i = this.cache; i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t) } function on(e, t) { const i = this.cache; void 0 !== t.x ? i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y) : rn(i, t) || (e.uniform2fv(this.addr, t), a(i, t)) } function sn(e, t) { const i = this.cache; void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z) : void 0 !== t.r ? i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b) : rn(i, t) || (e.uniform3fv(this.addr, t), a(i, t)) } function ln(e, t) { const i = this.cache; void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w) : rn(i, t) || (e.uniform4fv(this.addr, t), a(i, t)) } function cn(e, t) { var i = this.cache, r = t.elements; void 0 === r ? rn(i, t) || (e.uniformMatrix2fv(this.addr, !1, t), a(i, t)) : rn(i, r) || (en.set(r), e.uniformMatrix2fv(this.addr, !1, en), a(i, r)) } function hn(e, t) { var i = this.cache, r = t.elements; void 0 === r ? rn(i, t) || (e.uniformMatrix3fv(this.addr, !1, t), a(i, t)) : rn(i, r) || ($r.set(r), e.uniformMatrix3fv(this.addr, !1, $r), a(i, r)) } function un(e, t) { var i = this.cache, r = t.elements; void 0 === r ? rn(i, t) || (e.uniformMatrix4fv(this.addr, !1, t), a(i, t)) : rn(i, r) || (Kr.set(r), e.uniformMatrix4fv(this.addr, !1, Kr), a(i, r)) } function dn(e, t) { const i = this.cache; i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t) } function pn(e, t) { var i = this.cache; rn(i, t) || (e.uniform2iv(this.addr, t), a(i, t)) } function fn(e, t) { var i = this.cache; rn(i, t) || (e.uniform3iv(this.addr, t), a(i, t)) } function mn(e, t) { var i = this.cache; rn(i, t) || (e.uniform4iv(this.addr, t), a(i, t)) } function vn(e, t) { const i = this.cache; i[0] !== t && (e.uniform1ui(this.addr, t), i[0] = t) } function gn(e, t) { var i = this.cache; rn(i, t) || (e.uniform2uiv(this.addr, t), a(i, t)) } function xn(e, t) { var i = this.cache; rn(i, t) || (e.uniform3uiv(this.addr, t), a(i, t)) } function yn(e, t) { var i = this.cache; rn(i, t) || (e.uniform4uiv(this.addr, t), a(i, t)) } function _n(e, t, i) { const r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.safeSetTexture2D(t || Xr, n) } function bn(e, t, i) { const r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.setTexture3D(t || Yr, n) } function wn(e, t, i) { const r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.safeSetTextureCube(t || Qr, n) } function En(e, t, i) { const r = this.cache, n = i.allocateTextureUnit(); r[0] !== n && (e.uniform1i(this.addr, n), r[0] = n), i.setTexture2DArray(t || qr, n) } function Tn(e, t) { e.uniform1fv(this.addr, t) } function Sn(e, t) { t = tn(t, this.size, 2), e.uniform2fv(this.addr, t) } function Mn(e, t) { t = tn(t, this.size, 3), e.uniform3fv(this.addr, t) } function An(e, t) { t = tn(t, this.size, 4), e.uniform4fv(this.addr, t) } function Rn(e, t) { t = tn(t, this.size, 4), e.uniformMatrix2fv(this.addr, !1, t) } function Ln(e, t) { t = tn(t, this.size, 9), e.uniformMatrix3fv(this.addr, !1, t) } function Pn(e, t) { t = tn(t, this.size, 16), e.uniformMatrix4fv(this.addr, !1, t) } function Cn(e, t) { e.uniform1iv(this.addr, t) } function Fn(e, t) { e.uniform2iv(this.addr, t) } function Dn(e, t) { e.uniform3iv(this.addr, t) } function In(e, t) { e.uniform4iv(this.addr, t) } function Nn(e, t) { e.uniform1uiv(this.addr, t) } function Hn(e, t) { e.uniform2uiv(this.addr, t) } function Bn(e, t) { e.uniform3uiv(this.addr, t) } function Un(e, t) { e.uniform4uiv(this.addr, t) } function zn(e, t, i) { var r = t.length, n = nn(i, r); e.uniform1iv(this.addr, n); for (let e = 0; e !== r; ++e)i.safeSetTexture2D(t[e] || Xr, n[e]) } function On(e, t, i) { var r = t.length, n = nn(i, r); e.uniform1iv(this.addr, n); for (let e = 0; e !== r; ++e)i.safeSetTextureCube(t[e] || Qr, n[e]) } function Vn(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.setValue = function () { switch (t.type) { case 5126: return an; case 35664: return on; case 35665: return sn; case 35666: return ln; case 35674: return cn; case 35675: return hn; case 35676: return un; case 5124: case 35670: return dn; case 35667: case 35671: return pn; case 35668: case 35672: return fn; case 35669: case 35673: return mn; case 5125: return vn; case 36294: return gn; case 36295: return xn; case 36296: return yn; case 35678: case 36198: case 36298: case 36306: case 35682: return _n; case 35679: case 36299: case 36307: return bn; case 35680: case 36300: case 36308: case 36293: return wn; case 36289: case 36303: case 36311: case 36292: return En } }() } function kn(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function () { switch (t.type) { case 5126: return Tn; case 35664: return Sn; case 35665: return Mn; case 35666: return An; case 35674: return Rn; case 35675: return Ln; case 35676: return Pn; case 5124: case 35670: return Cn; case 35667: case 35671: return Fn; case 35668: case 35672: return Dn; case 35669: case 35673: return In; case 5125: return Nn; case 36294: return Hn; case 36295: return Bn; case 36296: return Un; case 35678: case 36198: case 36298: case 36306: case 35682: return zn; case 35680: case 36300: case 36308: case 36293: return On } }() } function Gn(e) { this.id = e, this.seq = [], this.map = {} } kn.prototype.updateCache = function (e) { var t = this.cache; e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), a(t, e) }, Gn.prototype.setValue = function (i, r, n) { var a = this.seq; for (let e = 0, t = a.length; e !== t; ++e) { const o = a[e]; o.setValue(i, r[o.id], n) } }; const Wn = /(\w+)(\])?(\[|\.)?/g; function jn(e, t) { e.seq.push(t), e.map[t.id] = t } function Xn(t, i) { this.seq = [], this.map = {}; const r = t.getProgramParameter(i, 35718); for (let e = 0; e < r; ++e) { const r = t.getActiveUniform(i, e); o = void 0; var n = r, a = t.getUniformLocation(i, r.name), o = this, s = n.name, l = s.length; for (Wn.lastIndex = 0; ;) { var c = Wn.exec(s), h = Wn.lastIndex; let t = c[1]; var u = "]" === c[2], c = c[3]; if (u && (t |= 0), void 0 === c || "[" === c && h + 2 === l) { jn(o, new (void 0 === c ? Vn : kn)(t, n, a)); break } { let e = o.map[t]; void 0 === e && jn(o, e = new Gn(t)), o = e } } } } function qn(e, t, i) { return t = e.createShader(t), e.shaderSource(t, i), e.compileShader(t), t } Xn.prototype.setValue = function (e, t, i, r) { const n = this.map[t]; void 0 !== n && n.setValue(e, i, r) }, Xn.prototype.setOptional = function (e, t, i) { void 0 !== (t = t[i]) && this.setValue(e, i, t) }, Xn.upload = function (i, r, n, a) { for (let e = 0, t = r.length; e !== t; ++e) { const o = r[e], s = n[o.id]; !1 !== s.needsUpdate && o.setValue(i, s.value, a) } }, Xn.seqWithValue = function (i, r) { const n = []; for (let e = 0, t = i.length; e !== t; ++e) { var a = i[e]; a.id in r && n.push(a) } return n }; let Yn = 0; function Qn(e) { switch (e) { case Be: return ["Linear", "( value )"]; case 3001: return ["sRGB", "( value )"]; case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case 3003: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"] } } function Zn(e, i, t) { var r = e.getShaderParameter(i, 35713), n = e.getShaderInfoLog(i).trim(); return r && "" === n ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + t + "\n" + n + function () { const t = e.getShaderSource(i).split("\n"); for (let e = 0; e < t.length; e++)t[e] = e + 1 + ": " + t[e]; return t.join("\n") }() } function Jn(e, t) { return "vec4 " + e + "( vec4 value ) { return " + (t = Qn(t))[0] + "ToLinear" + t[1] + "; }" } function Kn(e) { return "" !== e } function $n(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function ea(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } const ta = /^[ \t]*#include +<([\w\d./]+)>/gm; function ia(e) { return e.replace(ta, ra) } function ra(e, t) { var i = E[t]; if (void 0 === i) throw new Error("Can not resolve #include <" + t + ">"); return ia(i) } const na = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, aa = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function oa(e) { return e.replace(aa, la).replace(na, sa) } function sa(e, t, i, r) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), la(0, t, i, r) } function la(e, t, i, r) { let n = ""; for (let e = parseInt(t); e < parseInt(i); e++)n += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return n } function ca(e) { let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function ha(i, r, n, e) { const a = i.getContext(), t = n.defines; var o = n.vertexShader, s = n.fragmentShader; const l = function () { let e = "SHADOWMAP_TYPE_BASIC"; return 1 === n.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === n.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === n.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e }(), c = function () { let e = "ENVMAP_TYPE_CUBE"; if (n.envMap) switch (n.envMapMode) { case A: case R: e = "ENVMAP_TYPE_CUBE"; break; case D: case I: e = "ENVMAP_TYPE_CUBE_UV" }return e }(), h = function () { let e = "ENVMAP_MODE_REFLECTION"; if (n.envMap) switch (n.envMapMode) { case R: case I: e = "ENVMAP_MODE_REFRACTION" }return e }(), u = function () { let e = "ENVMAP_BLENDING_NONE"; if (n.envMap) switch (n.combine) { case 0: e = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: e = "ENVMAP_BLENDING_MIX"; break; case 2: e = "ENVMAP_BLENDING_ADD" }return e }(), d = 0 < i.gammaFactor ? i.gammaFactor : 1, p = n.isWebGL2 ? "" : [n.extensionDerivatives || n.envMapCubeUV || n.bumpMap || n.tangentSpaceNormalMap || n.clearcoatNormalMap || n.flatShading || "physical" === n.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (n.extensionFragDepth || n.logarithmicDepthBuffer) && n.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n.extensionDrawBuffers && n.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n.extensionShaderTextureLOD || n.envMap || 0 < n.transmission) && n.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Kn).join("\n"), f = function (e) { const t = []; for (const r in e) { var i = e[r]; !1 !== i && t.push("#define " + r + " " + i) } return t.join("\n") }(t), m = a.createProgram(); let v, g, x = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? (0 < (v = [f].filter(Kn).join("\n")).length && (v += "\n"), 0 < (g = [p, f].filter(Kn).join("\n")).length && (g += "\n")) : (v = [ca(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Kn).join("\n"), g = [p, ca(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularTintMap ? "#define USE_SPECULARTINTMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? E.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? function (e) { let t; switch (e) { case 1: t = "Linear"; break; case 2: t = "Reinhard"; break; case 3: t = "OptimizedCineon"; break; case 4: t = "ACESFilmic"; break; case 5: t = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear" }return "vec3 toneMapping( vec3 color ) { return " + t + "ToneMapping( color ); }" }(n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", E.encodings_pars_fragment, n.map ? Jn("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Jn("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Jn("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Jn("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.specularTintMap ? Jn("specularTintMapTexelToLinear", n.specularTintMapEncoding) : "", n.lightMap ? Jn("lightMapTexelToLinear", n.lightMapEncoding) : "", "vec4 " + (y = "linearToOutputTexel") + "( vec4 value ) { return LinearTo" + (_ = Qn(_ = n.outputEncoding))[0] + _[1] + "; }", n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Kn).join("\n")), o = ea($n(ia(o), n), n), s = ea($n(ia(s), n), n), o = oa(o), s = oa(s), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (x = "#version 300 es\n", v = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v, g = ["#define varying in", n.glslVersion === le ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === le ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + g); var y = x + g + s, _ = qn(a, 35633, x + v + o), s = qn(a, 35632, y); if (a.attachShader(m, _), a.attachShader(m, s), void 0 !== n.index0AttributeName ? a.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && a.bindAttribLocation(m, 0, "position"), a.linkProgram(m), i.debug.checkShaderErrors) { const i = a.getProgramInfoLog(m).trim(), r = a.getShaderInfoLog(_).trim(), n = a.getShaderInfoLog(s).trim(); let e = !0, t = !0; if (!1 === a.getProgramParameter(m, 35714)) { e = !1; const r = Zn(a, _, "vertex"), n = Zn(a, s, "fragment"); console.error("THREE.WebGLProgram: shader error: ", a.getError(), "35715", a.getProgramParameter(m, 35715), "gl.getProgramInfoLog", i, r, n) } else "" !== i ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", i) : "" !== r && "" !== n || (t = !1); t && (this.diagnostics = { runnable: e, programLog: i, vertexShader: { log: r, prefix: v }, fragmentShader: { log: n, prefix: g } }) } let b, w; return a.deleteShader(_), a.deleteShader(s), this.getUniforms = function () { return b = void 0 === b ? new Xn(a, m) : b }, this.getAttributes = function () { return w = void 0 === w ? function (t, i) { const r = {}, n = t.getProgramParameter(i, 35721); for (let e = 0; e < n; e++) { const n = t.getActiveAttrib(i, e).name; r[n] = t.getAttribLocation(i, n) } return r }(a, m) : w }, this.destroy = function () { e.releaseStatesOfProgram(this), a.deleteProgram(m), this.program = void 0 }, this.name = n.shaderName, this.id = Yn++, this.cacheKey = r, this.usedTimes = 1, this.program = m, this.vertexShader = _, this.fragmentShader = s, this } function ua(u, d, p, f, m, e, v) { const a = [], g = m.isWebGL2, x = m.logarithmicDepthBuffer, y = m.floatVertexTextures, _ = m.maxVertexUniforms, b = m.vertexTextures; let w = m.precision; const E = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, r = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"]; function T(e) { return e && e.isTexture ? e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e.texture.encoding) : Be } return { getParameters: function (e, t, i, r, n) { var a = r.fog, r = e.isMeshStandardMaterial ? r.environment : null, r = (e.isMeshStandardMaterial ? p : d).get(e.envMap || r), o = E[e.type], s = n.isSkinnedMesh ? function (e) { var t = e.skeleton.bones; if (y) return 1024; { const e = _, i = Math.floor((e - 20) / 4), r = Math.min(i, t.length); return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r } }(n) : 0; let l, c; if (null !== e.precision && (w = m.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", w, "instead."), o) { const u = rr[o]; l = u.vertexShader, c = u.fragmentShader } else l = e.vertexShader, c = e.fragmentShader; var h = u.getRenderTarget(); return { isWebGL2: g, shaderID: o, shaderName: e.type, vertexShader: l, fragmentShader: c, defines: e.defines, isRawShaderMaterial: !0 === e.isRawShaderMaterial, glslVersion: e.glslVersion, precision: w, instancing: !0 === n.isInstancedMesh, instancingColor: !0 === n.isInstancedMesh && null !== n.instanceColor, supportsVertexTextures: b, outputEncoding: null !== h ? T(h.texture) : u.outputEncoding, map: !!e.map, mapEncoding: T(e.map), matcap: !!e.matcap, matcapEncoding: T(e.matcap), envMap: !!r, envMapMode: r && r.mapping, envMapEncoding: T(r), envMapCubeUV: !!r && (r.mapping === D || r.mapping === I), lightMap: !!e.lightMap, lightMapEncoding: T(e.lightMap), aoMap: !!e.aoMap, emissiveMap: !!e.emissiveMap, emissiveMapEncoding: T(e.emissiveMap), bumpMap: !!e.bumpMap, normalMap: !!e.normalMap, objectSpaceNormalMap: 1 === e.normalMapType, tangentSpaceNormalMap: 0 === e.normalMapType, clearcoatMap: !!e.clearcoatMap, clearcoatRoughnessMap: !!e.clearcoatRoughnessMap, clearcoatNormalMap: !!e.clearcoatNormalMap, displacementMap: !!e.displacementMap, roughnessMap: !!e.roughnessMap, metalnessMap: !!e.metalnessMap, specularMap: !!e.specularMap, specularIntensityMap: !!e.specularIntensityMap, specularTintMap: !!e.specularTintMap, specularTintMapEncoding: T(e.specularTintMap), alphaMap: !!e.alphaMap, gradientMap: !!e.gradientMap, sheen: !!e.sheen, transmission: !!e.transmission, transmissionMap: !!e.transmissionMap, thicknessMap: !!e.thicknessMap, combine: e.combine, vertexTangents: !!e.normalMap && !!n.geometry && !!n.geometry.attributes.tangent, vertexColors: e.vertexColors, vertexAlphas: !0 === e.vertexColors && !!n.geometry && !!n.geometry.attributes.color && 4 === n.geometry.attributes.color.itemSize, vertexUvs: !!(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatMap || e.clearcoatRoughnessMap || e.clearcoatNormalMap || e.displacementMap || e.transmissionMap || e.thicknessMap || e.specularIntensityMap || e.specularTintMap), uvsVertexOnly: !(e.map || e.bumpMap || e.normalMap || e.specularMap || e.alphaMap || e.emissiveMap || e.roughnessMap || e.metalnessMap || e.clearcoatNormalMap || e.transmission || e.transmissionMap || e.thicknessMap || e.specularIntensityMap || e.specularTintMap || !e.displacementMap), fog: !!a, useFog: e.fog, fogExp2: a && a.isFogExp2, flatShading: !!e.flatShading, sizeAttenuation: e.sizeAttenuation, logarithmicDepthBuffer: x, skinning: !0 === n.isSkinnedMesh && 0 < s, maxBones: s, useVertexTexture: y, morphTargets: !!n.geometry && !!n.geometry.morphAttributes.position, morphNormals: !!n.geometry && !!n.geometry.morphAttributes.normal, numDirLights: t.directional.length, numPointLights: t.point.length, numSpotLights: t.spot.length, numRectAreaLights: t.rectArea.length, numHemiLights: t.hemi.length, numDirLightShadows: t.directionalShadowMap.length, numPointLightShadows: t.pointShadowMap.length, numSpotLightShadows: t.spotShadowMap.length, numClippingPlanes: v.numPlanes, numClipIntersection: v.numIntersection, dithering: e.dithering, shadowMapEnabled: u.shadowMap.enabled && 0 < i.length, shadowMapType: u.shadowMap.type, toneMapping: e.toneMapped ? u.toneMapping : 0, physicallyCorrectLights: u.physicallyCorrectLights, premultipliedAlpha: e.premultipliedAlpha, alphaTest: e.alphaTest, doubleSided: 2 === e.side, flipSided: 1 === e.side, depthPacking: void 0 !== e.depthPacking && e.depthPacking, index0AttributeName: e.index0AttributeName, extensionDerivatives: e.extensions && e.extensions.derivatives, extensionFragDepth: e.extensions && e.extensions.fragDepth, extensionDrawBuffers: e.extensions && e.extensions.drawBuffers, extensionShaderTextureLOD: e.extensions && e.extensions.shaderTextureLOD, rendererExtensionFragDepth: g || f.has("EXT_frag_depth"), rendererExtensionDrawBuffers: g || f.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: g || f.has("EXT_shader_texture_lod"), customProgramCacheKey: e.customProgramCacheKey() } }, getProgramCacheKey: function (t) { const i = []; if (t.shaderID ? i.push(t.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines) for (const u in t.defines) i.push(u), i.push(t.defines[u]); if (!1 === t.isRawShaderMaterial) { for (let e = 0; e < r.length; e++)i.push(t[r[e]]); i.push(u.outputEncoding), i.push(u.gammaFactor) } return i.push(t.customProgramCacheKey), i.join() }, getUniforms: function (e) { var t = E[e.type]; let i; if (t) { const e = rr[t]; i = Vi.clone(e.uniforms) } else i = e.uniforms; return i }, acquireProgram: function (i, r) { let n; for (let e = 0, t = a.length; e < t; e++) { const i = a[e]; if (i.cacheKey === r) { ++(n = i).usedTimes; break } } return void 0 === n && (n = new ha(u, r, i, e), a.push(n)), n }, releaseProgram: function (e) { var t; 0 == --e.usedTimes && (t = a.indexOf(e), a[t] = a[a.length - 1], a.pop(), e.destroy()) }, programs: a } } function da() { let r = new WeakMap; return { get: function (e) { let t = r.get(e); return void 0 === t && (t = {}, r.set(e, t)), t }, remove: function (e) { r.delete(e) }, update: function (e, t, i) { r.get(e)[t] = i }, dispose: function () { r = new WeakMap } } } function pa(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function fa(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function ma(l) { const c = []; let h = 0; const o = [], s = [], u = [], d = { id: -1 }; function p(e, t, i, r, n, a) { let o = c[h]; var s = l.get(i); return void 0 === o ? (o = { id: e.id, object: e, geometry: t, material: i, program: s.program || d, groupOrder: r, renderOrder: e.renderOrder, z: n, group: a }, c[h] = o) : (o.id = e.id, o.object = e, o.geometry = t, o.material = i, o.program = s.program || d, o.groupOrder = r, o.renderOrder = e.renderOrder, o.z = n, o.group = a), h++, o } return { opaque: o, transmissive: s, transparent: u, init: function () { h = 0, o.length = 0, s.length = 0, u.length = 0 }, push: function (e, t, i, r, n, a) { e = p(e, t, i, r, n, a), (0 < i.transmission ? s : !0 === i.transparent ? u : o).push(e) }, unshift: function (e, t, i, r, n, a) { e = p(e, t, i, r, n, a), (0 < i.transmission ? s : !0 === i.transparent ? u : o).unshift(e) }, finish: function () { for (let e = h, t = c.length; e < t; e++) { const h = c[e]; if (null === h.id) break; h.id = null, h.object = null, h.geometry = null, h.material = null, h.program = null, h.group = null } }, sort: function (e, t) { 1 < o.length && o.sort(e || pa), 1 < s.length && s.sort(t || fa), 1 < u.length && u.sort(t || fa) } } } function va(r) { let n = new WeakMap; return { get: function (e, t) { let i; return !1 === n.has(e) ? (i = new ma(r), n.set(e, [i])) : t >= n.get(e).length ? (i = new ma(r), n.get(e).push(i)) : i = n.get(e)[t], i }, dispose: function () { n = new WeakMap } } } function ga() { const i = {}; return { get: function (e) { if (void 0 !== i[e.id]) return i[e.id]; let t; switch (e.type) { case "DirectionalLight": t = { direction: new Le, color: new y }; break; case "SpotLight": t = { position: new Le, direction: new Le, color: new y, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": t = { position: new Le, color: new y, distance: 0, decay: 0 }; break; case "HemisphereLight": t = { direction: new Le, skyColor: new y, groundColor: new y }; break; case "RectAreaLight": t = { color: new y, position: new Le, halfWidth: new Le, halfHeight: new Le } }return i[e.id] = t } } } let xa = 0; function ya(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) } function _a(x, y) { const _ = new ga, b = function () { const i = {}; return { get: function (e) { if (void 0 !== i[e.id]) return i[e.id]; let t; switch (e.type) { case "DirectionalLight": case "SpotLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new k }; break; case "PointLight": t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new k, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return i[e.id] = t } } }(), w = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let e = 0; e < 9; e++)w.probe.push(new Le); const h = new Le, u = new Pe, d = new Pe; return { setup: function (i) { let r = 0, n = 0, a = 0; for (let e = 0; e < 9; e++)w.probe[e].set(0, 0, 0); let o = 0, s = 0, l = 0, c = 0, h = 0, u = 0, d = 0, p = 0; i.sort(ya); for (let e = 0, t = i.length; e < t; e++) { const y = i[e], f = y.color, m = y.intensity, v = y.distance, g = y.shadow && y.shadow.map ? y.shadow.map.texture : null; if (y.isAmbientLight) r += f.r * m, n += f.g * m, a += f.b * m; else if (y.isLightProbe) for (let e = 0; e < 9; e++)w.probe[e].addScaledVector(y.sh.coefficients[e], m); else if (y.isDirectionalLight) { const x = _.get(y); if (x.color.copy(y.color).multiplyScalar(y.intensity), y.castShadow) { const x = y.shadow, _ = b.get(y); _.shadowBias = x.bias, _.shadowNormalBias = x.normalBias, _.shadowRadius = x.radius, _.shadowMapSize = x.mapSize, w.directionalShadow[o] = _, w.directionalShadowMap[o] = g, w.directionalShadowMatrix[o] = y.shadow.matrix, u++ } w.directional[o] = x, o++ } else if (y.isSpotLight) { const x = _.get(y); if (x.position.setFromMatrixPosition(y.matrixWorld), x.color.copy(f).multiplyScalar(m), x.distance = v, x.coneCos = Math.cos(y.angle), x.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), x.decay = y.decay, y.castShadow) { const x = y.shadow, _ = b.get(y); _.shadowBias = x.bias, _.shadowNormalBias = x.normalBias, _.shadowRadius = x.radius, _.shadowMapSize = x.mapSize, w.spotShadow[l] = _, w.spotShadowMap[l] = g, w.spotShadowMatrix[l] = y.shadow.matrix, p++ } w.spot[l] = x, l++ } else if (y.isRectAreaLight) { const x = _.get(y); x.color.copy(f).multiplyScalar(m), x.halfWidth.set(.5 * y.width, 0, 0), x.halfHeight.set(0, .5 * y.height, 0), w.rectArea[c] = x, c++ } else if (y.isPointLight) { const x = _.get(y); if (x.color.copy(y.color).multiplyScalar(y.intensity), x.distance = y.distance, x.decay = y.decay, y.castShadow) { const x = y.shadow, _ = b.get(y); _.shadowBias = x.bias, _.shadowNormalBias = x.normalBias, _.shadowRadius = x.radius, _.shadowMapSize = x.mapSize, _.shadowCameraNear = x.camera.near, _.shadowCameraFar = x.camera.far, w.pointShadow[s] = _, w.pointShadowMap[s] = g, w.pointShadowMatrix[s] = y.shadow.matrix, d++ } w.point[s] = x, s++ } else if (y.isHemisphereLight) { const x = _.get(y); x.skyColor.copy(y.color).multiplyScalar(m), x.groundColor.copy(y.groundColor).multiplyScalar(m), w.hemi[h] = x, h++ } } 0 < c && (y.isWebGL2 || !0 === x.has("OES_texture_float_linear") ? (w.rectAreaLTC1 = T.LTC_FLOAT_1, w.rectAreaLTC2 = T.LTC_FLOAT_2) : !0 === x.has("OES_texture_half_float_linear") ? (w.rectAreaLTC1 = T.LTC_HALF_1, w.rectAreaLTC2 = T.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), w.ambient[0] = r, w.ambient[1] = n, w.ambient[2] = a; const f = w.hash; f.directionalLength === o && f.pointLength === s && f.spotLength === l && f.rectAreaLength === c && f.hemiLength === h && f.numDirectionalShadows === u && f.numPointShadows === d && f.numSpotShadows === p || (w.directional.length = o, w.spot.length = l, w.rectArea.length = c, w.point.length = s, w.hemi.length = h, w.directionalShadow.length = u, w.directionalShadowMap.length = u, w.pointShadow.length = d, w.pointShadowMap.length = d, w.spotShadow.length = p, w.spotShadowMap.length = p, w.directionalShadowMatrix.length = u, w.pointShadowMatrix.length = d, w.spotShadowMatrix.length = p, f.directionalLength = o, f.pointLength = s, f.spotLength = l, f.rectAreaLength = c, f.hemiLength = h, f.numDirectionalShadows = u, f.numPointShadows = d, f.numSpotShadows = p, w.version = xa++) }, setupView: function (i, e) { let r = 0, n = 0, a = 0, o = 0, s = 0; var l = e.matrixWorldInverse; for (let e = 0, t = i.length; e < t; e++) { var c = i[e]; if (c.isDirectionalLight) { const i = w.directional[r]; i.direction.setFromMatrixPosition(c.matrixWorld), h.setFromMatrixPosition(c.target.matrixWorld), i.direction.sub(h), i.direction.transformDirection(l), r++ } else if (c.isSpotLight) { const i = w.spot[a]; i.position.setFromMatrixPosition(c.matrixWorld), i.position.applyMatrix4(l), i.direction.setFromMatrixPosition(c.matrixWorld), h.setFromMatrixPosition(c.target.matrixWorld), i.direction.sub(h), i.direction.transformDirection(l), a++ } else if (c.isRectAreaLight) { const i = w.rectArea[o]; i.position.setFromMatrixPosition(c.matrixWorld), i.position.applyMatrix4(l), d.identity(), u.copy(c.matrixWorld), u.premultiply(l), d.extractRotation(u), i.halfWidth.set(.5 * c.width, 0, 0), i.halfHeight.set(0, .5 * c.height, 0), i.halfWidth.applyMatrix4(d), i.halfHeight.applyMatrix4(d), o++ } else if (c.isPointLight) { const i = w.point[n]; i.position.setFromMatrixPosition(c.matrixWorld), i.position.applyMatrix4(l), n++ } else if (c.isHemisphereLight) { const i = w.hemi[s]; i.direction.setFromMatrixPosition(c.matrixWorld), i.direction.transformDirection(l), i.direction.normalize(), s++ } } }, state: w } } function ba(e, t) { const i = new _a(e, t), r = [], n = []; return { init: function () { r.length = 0, n.length = 0 }, state: { lightsArray: r, shadowsArray: n, lights: i }, setupLights: function () { i.setup(r) }, setupLightsView: function (e) { i.setupView(r, e) }, pushLight: function (e) { r.push(e) }, pushShadow: function (e) { n.push(e) } } } function wa(r, n) { let a = new WeakMap; return { get: function (e, t = 0) { let i; return !1 === a.has(e) ? (i = new ba(r, n), a.set(e, [i])) : t >= a.get(e).length ? (i = new ba(r, n), a.get(e).push(i)) : i = a.get(e)[t], i }, dispose: function () { a = new WeakMap } } } class Ea extends t { constructor(e) { super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this } } Ea.prototype.isMeshDepthMaterial = !0; class Ta extends t { constructor(e) { super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Le, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(e) } copy(e) { return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this } } function Sa(p, f, e) { let m = new $i; const v = new k, g = new k, x = new Re, l = new Ea({ depthPacking: 3201 }), c = new Ta, h = {}, y = e.maxTextureSize, u = { 0: 1, 1: 0, 2: 2 }, _ = new ki({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new k }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), b = _.clone(), t = (b.defines.HORIZONTAL_PASS = 1, new S), w = (t.setAttribute("position", new P(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)), new M(t, _)), E = this; function T(i, e, r, t, n, a, o) { let s = null; if (i = !0 === t.isPointLight ? i.customDistanceMaterial : i.customDepthMaterial, s = void 0 !== i ? i : !0 === t.isPointLight ? c : l, p.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) { const p = s.uuid, i = r.uuid; let e = h[p], t = (void 0 === e && (e = {}, h[p] = e), e[i]); void 0 === t && (t = s.clone(), e[i] = t), s = t } return s.visible = r.visible, s.wireframe = r.wireframe, s.side = 3 === o ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : u[r.side], s.clipShadows = r.clipShadows, s.clippingPlanes = r.clippingPlanes, s.clipIntersection = r.clipIntersection, s.wireframeLinewidth = r.wireframeLinewidth, s.linewidth = r.linewidth, !0 === t.isPointLight && !0 === s.isMeshDistanceMaterial && (s.referencePosition.setFromMatrixPosition(t.matrixWorld), s.nearDistance = n, s.farDistance = a), s } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (i, r, n) { if (!1 !== E.enabled && (!1 !== E.autoUpdate || !1 !== E.needsUpdate) && 0 !== i.length) { const e = p.getRenderTarget(), t = p.getActiveCubeFace(), c = p.getActiveMipmapLevel(), h = p.state; h.setBlending(0), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1); for (let e = 0, t = i.length; e < t; e++) { const u = i[e], d = u.shadow; if (void 0 === d) console.warn("THREE.WebGLShadowMap:", u, "has no shadow."); else if (!1 !== d.autoUpdate || !1 !== d.needsUpdate) { v.copy(d.mapSize); var a = d.getFrameExtents(); if (v.multiply(a), g.copy(d.mapSize), (v.x > y || v.y > y) && (v.x > y && (g.x = Math.floor(y / a.x), v.x = g.x * a.x, d.mapSize.x = g.x), v.y > y && (g.y = Math.floor(y / a.y), v.y = g.y * a.y, d.mapSize.y = g.y)), null === d.map && !d.isPointLightShadow && 3 === this.type) { const p = { minFilter: U, magFilter: U, format: He }; d.map = new Ue(v.x, v.y, p), d.map.texture.name = u.name + ".shadowMap", d.mapPass = new Ue(v.x, v.y, p), d.camera.updateProjectionMatrix() } if (null === d.map) { const p = { minFilter: Ae, magFilter: Ae, format: He }; d.map = new Ue(v.x, v.y, p), d.map.texture.name = u.name + ".shadowMap", d.camera.updateProjectionMatrix() } p.setRenderTarget(d.map), p.clear(); var o = d.getViewportCount(); for (let e = 0; e < o; e++) { const i = d.getViewport(e); x.set(g.x * i.x, g.y * i.y, g.x * i.z, g.y * i.w), h.viewport(x), d.updateMatrices(u, e), m = d.getFrustum(), function i(r, n, a, o, s) { if (!1 !== r.visible) { if (r.layers.test(n.layers) && (r.isMesh || r.isLine || r.isPoints) && (r.castShadow || r.receiveShadow && 3 === s) && (!r.frustumCulled || m.intersectsObject(r))) { r.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, r.matrixWorld); const m = f.update(r), n = r.material; if (Array.isArray(n)) { const f = m.groups; for (let e = 0, t = f.length; e < t; e++) { var l = f[e], c = n[l.materialIndex]; if (c && c.visible) { const f = T(r, 0, c, o, a.near, a.far, s); p.renderBufferDirect(a, null, m, f, r, l) } } } else if (n.visible) { const f = T(r, 0, n, o, a.near, a.far, s); p.renderBufferDirect(a, null, m, f, r, null) } } var h = r.children; for (let e = 0, t = h.length; e < t; e++)i(h[e], n, a, o, s) } }(r, n, d.camera, u, this.type) } d.isPointLightShadow || 3 !== this.type || (a = d, s = n, l = f.update(w), _.uniforms.shadow_pass.value = a.map.texture, _.uniforms.resolution.value = a.mapSize, _.uniforms.radius.value = a.radius, p.setRenderTarget(a.mapPass), p.clear(), p.renderBufferDirect(s, null, l, _, w, null), b.uniforms.shadow_pass.value = a.mapPass.texture, b.uniforms.resolution.value = a.mapSize, b.uniforms.radius.value = a.radius, p.setRenderTarget(a.map), p.clear(), p.renderBufferDirect(s, null, l, b, w, null)), d.needsUpdate = !1 } } var s, l; E.needsUpdate = !1, p.setRenderTarget(e, t, c) } } } function Ma(h, H, B) { const i = B.isWebGL2, r = new function () { let t = !1; const a = new Re; let i = null; const o = new Re(0, 0, 0, 0); return { setMask: function (e) { i === e || t || (h.colorMask(e, e, e, e), i = e) }, setLocked: function (e) { t = e }, setClear: function (e, t, i, r, n) { !0 === n && (e *= r, t *= r, i *= r), a.set(e, t, i, r), !1 === o.equals(a) && (h.clearColor(e, t, i, r), o.copy(a)) }, reset: function () { t = !1, i = null, o.set(-1, 0, 0, 0) } } }, n = new function () { let t = !1, i = null, r = null, n = null; return { setTest: function (e) { (e ? C : F)(2929) }, setMask: function (e) { i === e || t || (h.depthMask(e), i = e) }, setFunc: function (e) { if (r !== e) { if (e) switch (e) { case 0: h.depthFunc(512); break; case 1: h.depthFunc(519); break; case 2: h.depthFunc(513); break; case 3: h.depthFunc(515); break; case 4: h.depthFunc(514); break; case 5: h.depthFunc(518); break; case 6: h.depthFunc(516); break; case 7: h.depthFunc(517); break; default: h.depthFunc(515) } else h.depthFunc(515); r = e } }, setLocked: function (e) { t = e }, setClear: function (e) { n !== e && (h.clearDepth(e), n = e) }, reset: function () { t = !1, i = null, r = null, n = null } } }, a = new function () { let t = !1, i = null, r = null, n = null, a = null, o = null, s = null, l = null, c = null; return { setTest: function (e) { t || (e ? C : F)(2960) }, setMask: function (e) { i === e || t || (h.stencilMask(e), i = e) }, setFunc: function (e, t, i) { r === e && n === t && a === i || (h.stencilFunc(e, t, i), r = e, n = t, a = i) }, setOp: function (e, t, i) { o === e && s === t && l === i || (h.stencilOp(e, t, i), o = e, s = t, l = i) }, setLocked: function (e) { t = e }, setClear: function (e) { c !== e && (h.clearStencil(e), c = e) }, reset: function () { t = !1, i = null, r = null, n = null, a = null, o = null, s = null, l = null, c = null } } }; let t = {}, o = null, s = {}, l = null, c = !1, u = null, d = null, p = null, f = null, m = null, v = null, g = null, x = !1, y = null, _ = null, b = null, w = null, E = null; const U = h.getParameter(35661); let T = !1, e = 0; const S = h.getParameter(7938); -1 !== S.indexOf("WebGL") ? (e = parseFloat(/^WebGL (\d)/.exec(S)[1]), T = 1 <= e) : -1 !== S.indexOf("OpenGL ES") && (e = parseFloat(/^OpenGL ES (\d)/.exec(S)[1]), T = 2 <= e); let M = null, A = {}; const z = h.getParameter(3088), O = h.getParameter(2978), R = (new Re).fromArray(z), L = (new Re).fromArray(O); function V(e, t, i) { var r = new Uint8Array(4), n = h.createTexture(); h.bindTexture(e, n), h.texParameteri(e, 10241, 9728), h.texParameteri(e, 10240, 9728); for (let e = 0; e < i; e++)h.texImage2D(t + e, 0, 6408, 1, 1, 0, 6408, 5121, r); return n } const P = {}; function C(e) { !0 !== t[e] && (h.enable(e), t[e] = !0) } function F(e) { !1 !== t[e] && (h.disable(e), t[e] = !1) } P[3553] = V(3553, 3553, 1), P[34067] = V(34067, 34069, 6), r.setClear(0, 0, 0, 1), n.setClear(1), a.setClear(0), C(2929), n.setFunc(3), k(!1), G(1), C(2884), N(0); const D = { [X]: 32774, 101: 32778, 102: 32779 }; if (i) D[103] = 32775, D[104] = 32776; else { const h = H.get("EXT_blend_minmax"); null !== h && (D[103] = h.MIN_EXT, D[104] = h.MAX_EXT) } const I = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 }; function N(e, t, i, r, n, a, o, s) { if (0 !== e) { if (!1 === c && (C(3042), c = !0), 5 === e) n = n || t, a = a || i, o = o || r, t === d && n === m || (h.blendEquationSeparate(D[t], D[n]), d = t, m = n), i === p && r === f && a === v && o === g || (h.blendFuncSeparate(I[i], I[r], I[a], I[o]), p = i, f = r, v = a, g = o), u = e, x = null; else if (e !== u || s !== x) { if (d === X && m === X || (h.blendEquation(32774), d = X, m = X), s) switch (e) { case 1: h.blendFuncSeparate(1, 771, 1, 771); break; case 2: h.blendFunc(1, 1); break; case 3: h.blendFuncSeparate(0, 0, 769, 771); break; case 4: h.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case 1: h.blendFuncSeparate(770, 771, 1, 771); break; case 2: h.blendFunc(770, 1); break; case 3: h.blendFunc(0, 769); break; case 4: h.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }p = null, f = null, v = null, g = null, u = e, x = s } } else !0 === c && (F(3042), c = !1) } function k(e) { y !== e && (e ? h.frontFace(2304) : h.frontFace(2305), y = e) } function G(e) { 0 !== e ? (C(2884), e !== _ && (1 === e ? h.cullFace(1029) : 2 === e ? h.cullFace(1028) : h.cullFace(1032))) : F(2884), _ = e } function W(e, t, i) { e ? (C(32823), w === t && E === i || (h.polygonOffset(t, i), w = t, E = i)) : F(32823) } function j(e) { void 0 === e && (e = 33984 + U - 1), M !== e && (h.activeTexture(e), M = e) } return { buffers: { color: r, depth: n, stencil: a }, enable: C, disable: F, bindFramebuffer: function (e, t) { return null === t && null !== o && (t = o), s[e] !== t && (h.bindFramebuffer(e, t), s[e] = t, i && (36009 === e && (s[36160] = t), 36160 === e && (s[36009] = t)), !0) }, bindXRFramebuffer: function (e) { e !== o && (h.bindFramebuffer(36160, e), o = e) }, useProgram: function (e) { return l !== e && (h.useProgram(e), l = e, !0) }, setBlending: N, setMaterial: function (e, t) { (2 === e.side ? F : C)(2884); let i = 1 === e.side; k(i = t ? !i : i), 1 === e.blending && !1 === e.transparent ? N(0) : N(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), n.setFunc(e.depthFunc), n.setTest(e.depthTest), n.setMask(e.depthWrite), r.setMask(e.colorWrite), t = e.stencilWrite, a.setTest(t), t && (a.setMask(e.stencilWriteMask), a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), W(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), (!0 === e.alphaToCoverage ? C : F)(32926) }, setFlipSided: k, setCullFace: G, setLineWidth: function (e) { e !== b && (T && h.lineWidth(e), b = e) }, setPolygonOffset: W, setScissorTest: function (e) { (e ? C : F)(3089) }, activeTexture: j, bindTexture: function (e, t) { null === M && j(); let i = A[M]; void 0 === i && (i = { type: void 0, texture: void 0 }, A[M] = i), i.type === e && i.texture === t || (h.bindTexture(e, t || P[e]), i.type = e, i.texture = t) }, unbindTexture: function () { const e = A[M]; void 0 !== e && void 0 !== e.type && (h.bindTexture(e.type, null), e.type = void 0, e.texture = void 0) }, compressedTexImage2D: function () { try { h.compressedTexImage2D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { h.texImage2D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { h.texImage3D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (e) { !1 === R.equals(e) && (h.scissor(e.x, e.y, e.z, e.w), R.copy(e)) }, viewport: function (e) { !1 === L.equals(e) && (h.viewport(e.x, e.y, e.z, e.w), L.copy(e)) }, reset: function () { h.disable(3042), h.disable(2884), h.disable(2929), h.disable(32823), h.disable(3089), h.disable(2960), h.disable(32926), h.blendEquation(32774), h.blendFunc(1, 0), h.blendFuncSeparate(1, 0, 1, 0), h.colorMask(!0, !0, !0, !0), h.clearColor(0, 0, 0, 0), h.depthMask(!0), h.depthFunc(513), h.clearDepth(1), h.stencilMask(4294967295), h.stencilFunc(519, 0, 4294967295), h.stencilOp(7680, 7680, 7680), h.clearStencil(0), h.cullFace(1029), h.frontFace(2305), h.polygonOffset(0, 0), h.activeTexture(33984), h.bindFramebuffer(36160, null), !0 === i && (h.bindFramebuffer(36009, null), h.bindFramebuffer(36008, null)), h.useProgram(null), h.lineWidth(1), h.scissor(0, 0, h.canvas.width, h.canvas.height), h.viewport(0, 0, h.canvas.width, h.canvas.height), t = {}, M = null, A = {}, o = null, s = {}, l = null, c = !1, u = null, d = null, p = null, f = null, m = null, v = null, g = null, x = !1, y = null, _ = null, b = null, w = null, E = null, R.set(0, 0, h.canvas.width, h.canvas.height), L.set(0, 0, h.canvas.width, h.canvas.height), r.reset(), n.reset(), a.reset() } } } function Aa(d, n, p, f, m, v, g) { const x = m.isWebGL2, t = m.maxTextures, y = m.maxCubemapSize, h = m.maxTextureSize, B = m.maxSamples, a = new WeakMap; let l, i = !1; try { i = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (d) { } function c(e, t) { return i ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function _(e, t, i, r) { let n = 1; if ((n = e.width > r || e.height > r ? r / Math.max(e.width, e.height) : n) < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const r = t ? xe : Math.floor, a = r(n * e.width), o = r(n * e.height), s = (void 0 === l && (l = c(a, o)), i ? c(a, o) : l); return s.width = a, s.height = o, s.getContext("2d").drawImage(e, 0, 0, a, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + o + ")."), s } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function b(e) { return ve(e.width) && ve(e.height) } function w(e, t) { return e.generateMipmaps && t && e.minFilter !== Ae && e.minFilter !== U } function E(e, t, i, r, n = 1) { d.generateMipmap(e), f.get(t).__maxMipLevel = Math.log2(Math.max(i, r, n)) } function T(e, t, i) { if (!1 === x) return t; if (null !== e) { if (void 0 !== d[e]) return d[e]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'") } let r = t; return 6403 === t && (5126 === i && (r = 33326), 5131 === i && (r = 33325), 5121 === i && (r = 33321)), 6407 === t && (5126 === i && (r = 34837), 5131 === i && (r = 34843), 5121 === i && (r = 32849)), 6408 === t && (5126 === i && (r = 34836), 5131 === i && (r = 34842), 5121 === i && (r = 32856)), 33325 !== r && 33326 !== r && 34842 !== r && 34836 !== r || n.get("EXT_color_buffer_float"), r } function r(e) { return e === Ae || e === V || e === W ? 9728 : 9729 } function o(e) { const t = e.target; var i; t.removeEventListener("dispose", o), e = t, void 0 !== (i = f.get(e)).__webglInit && (d.deleteTexture(i.__webglTexture), f.remove(e)), t.isVideoTexture && a.delete(t), g.memory.textures-- } function S(e) { const t = e.target; t.removeEventListener("dispose", S); var i = (e = t).texture, r = f.get(e), n = f.get(i); if (e) { if (void 0 !== n.__webglTexture && (d.deleteTexture(n.__webglTexture), g.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget) for (let e = 0; e < 6; e++)d.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && d.deleteRenderbuffer(r.__webglDepthbuffer[e]); else d.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && d.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && d.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && d.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && d.deleteRenderbuffer(r.__webglDepthRenderbuffer); if (e.isWebGLMultipleRenderTargets) for (let e = 0, t = i.length; e < t; e++) { var a = f.get(i[e]); a.__webglTexture && (d.deleteTexture(a.__webglTexture), g.memory.textures--), f.remove(i[e]) } f.remove(i), f.remove(e) } } let s = 0; function M(e, t) { var i, r, n = f.get(e); if (e.isVideoTexture && (i = e, r = g.render.frame, a.get(i) !== r && (a.set(i, r), i.update())), 0 < e.version && n.__version !== e.version) { const p = e.image; if (void 0 === p) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== p.complete) return void C(n, e, t); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } p.activeTexture(33984 + t), p.bindTexture(3553, n.__webglTexture) } function u(e, t) { var i = f.get(e); if (0 < e.version && i.__version !== e.version) { var r = i, n = e, a = t; if (6 === n.image.length) { P(r, n), p.activeTexture(33984 + a), p.bindTexture(34067, r.__webglTexture), d.pixelStorei(37440, n.flipY), d.pixelStorei(37441, n.premultiplyAlpha), d.pixelStorei(3317, n.unpackAlignment), d.pixelStorei(37443, 0); const c = n && (n.isCompressedTexture || n.image[0].isCompressedTexture), h = n.image[0] && n.image[0].isDataTexture, u = []; for (let e = 0; e < 6; e++)u[e] = c || h ? h ? n.image[e].image : n.image[e] : _(n.image[e], !1, !0, y); var a = u[0], e = b(a) || x, o = v.convert(n.format), s = v.convert(n.type), l = T(n.internalFormat, o, s); let i; if (L(34067, n, e), c) { for (let t = 0; t < 6; t++) { i = u[t].mipmaps; for (let e = 0; e < i.length; e++) { const a = i[e]; n.format !== He && n.format !== Z ? null !== o ? p.compressedTexImage2D(34069 + t, e, l, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : p.texImage2D(34069 + t, e, l, a.width, a.height, 0, o, s, a.data) } } r.__maxMipLevel = i.length - 1 } else { i = n.mipmaps; for (let t = 0; t < 6; t++)if (h) { p.texImage2D(34069 + t, 0, l, u[t].width, u[t].height, 0, o, s, u[t].data); for (let e = 0; e < i.length; e++) { const n = i[e].image[t].image; p.texImage2D(34069 + t, e + 1, l, n.width, n.height, 0, o, s, n.data) } } else { p.texImage2D(34069 + t, 0, l, o, s, u[t]); for (let e = 0; e < i.length; e++) { const n = i[e]; p.texImage2D(34069 + t, e + 1, l, o, s, n.image[t]) } } r.__maxMipLevel = i.length } w(n, e) && E(34067, n, a.width, a.height), r.__version = n.version, n.onUpdate && n.onUpdate(n) } } else p.activeTexture(33984 + t), p.bindTexture(34067, i.__webglTexture) } const A = { [z]: 10497, [Ce]: 33071, [O]: 33648 }, R = { [Ae]: 9728, [V]: 9984, [W]: 9986, [U]: 9729, [j]: 9985, [Fe]: 9987 }; function L(e, t, i) { if (i ? (d.texParameteri(e, 10242, A[t.wrapS]), d.texParameteri(e, 10243, A[t.wrapT]), 32879 !== e && 35866 !== e || d.texParameteri(e, 32882, A[t.wrapR]), d.texParameteri(e, 10240, R[t.magFilter]), d.texParameteri(e, 10241, R[t.minFilter])) : (d.texParameteri(e, 10242, 33071), d.texParameteri(e, 10243, 33071), 32879 !== e && 35866 !== e || d.texParameteri(e, 32882, 33071), t.wrapS === Ce && t.wrapT === Ce || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), d.texParameteri(e, 10240, r(t.magFilter)), d.texParameteri(e, 10241, r(t.minFilter)), t.minFilter !== Ae && t.minFilter !== U && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === n.has("EXT_texture_filter_anisotropic")) { const i = n.get("EXT_texture_filter_anisotropic"); t.type === Ie && !1 === n.has("OES_texture_float_linear") || !1 === x && t.type === Ne && !1 === n.has("OES_texture_half_float_linear") || (1 < t.anisotropy || f.get(t).__currentAnisotropy) && (d.texParameterf(e, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, m.getMaxAnisotropy())), f.get(t).__currentAnisotropy = t.anisotropy) } } function P(e, t) { void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", o), e.__webglTexture = d.createTexture(), g.memory.textures++) } function C(e, i, t) { let r = 3553; i.isDataTexture2DArray && (r = 35866), i.isDataTexture3D && (r = 32879), P(e, i), p.activeTexture(33984 + t), p.bindTexture(r, e.__webglTexture), d.pixelStorei(37440, i.flipY), d.pixelStorei(37441, i.premultiplyAlpha), d.pixelStorei(3317, i.unpackAlignment), d.pixelStorei(37443, 0), t = i; var t = !x && (t.wrapS !== Ce || t.wrapT !== Ce || t.minFilter !== Ae && t.minFilter !== U) && !1 === b(i.image), n = b(t = _(i.image, t, !1, h)) || x, a = v.convert(i.format); let o, s = v.convert(i.type), l = T(i.internalFormat, a, s); L(r, i, n); var c = i.mipmaps; if (i.isDepthTexture) l = 6402, x ? l = i.type === Ie ? 36012 : i.type === Y ? 33190 : i.type === Q ? 35056 : 33189 : i.type === Ie && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === J && 6402 === l && i.type !== q && i.type !== Y && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = q, s = v.convert(i.type)), i.format === K && 6402 === l && (l = 34041, i.type !== Q && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Q, s = v.convert(i.type))), p.texImage2D(3553, 0, l, t.width, t.height, 0, a, s, null); else if (i.isDataTexture) if (0 < c.length && n) { for (let e = 0, t = c.length; e < t; e++)o = c[e], p.texImage2D(3553, e, l, o.width, o.height, 0, a, s, o.data); i.generateMipmaps = !1, e.__maxMipLevel = c.length - 1 } else p.texImage2D(3553, 0, l, t.width, t.height, 0, a, s, t.data), e.__maxMipLevel = 0; else if (i.isCompressedTexture) { for (let e = 0, t = c.length; e < t; e++)o = c[e], i.format !== He && i.format !== Z ? null !== a ? p.compressedTexImage2D(3553, e, l, o.width, o.height, 0, o.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : p.texImage2D(3553, e, l, o.width, o.height, 0, a, s, o.data); e.__maxMipLevel = c.length - 1 } else if (i.isDataTexture2DArray) p.texImage3D(35866, 0, l, t.width, t.height, t.depth, 0, a, s, t.data), e.__maxMipLevel = 0; else if (i.isDataTexture3D) p.texImage3D(32879, 0, l, t.width, t.height, t.depth, 0, a, s, t.data), e.__maxMipLevel = 0; else if (0 < c.length && n) { for (let e = 0, t = c.length; e < t; e++)o = c[e], p.texImage2D(3553, e, l, a, s, o); i.generateMipmaps = !1, e.__maxMipLevel = c.length - 1 } else p.texImage2D(3553, 0, l, a, s, t), e.__maxMipLevel = 0; w(i, n) && E(r, i, t.width, t.height), e.__version = i.version, i.onUpdate && i.onUpdate(i) } function F(e, t, i, r, n) { var a = v.convert(i.format), o = v.convert(i.type), s = T(i.internalFormat, a, o); 32879 === n || 35866 === n ? p.texImage3D(n, 0, s, t.width, t.height, t.depth, 0, a, o, null) : p.texImage2D(n, 0, s, t.width, t.height, 0, a, o, null), p.bindFramebuffer(36160, e), d.framebufferTexture2D(36160, r, n, f.get(i).__webglTexture, 0), p.bindFramebuffer(36160, null) } function D(t, i, r) { if (d.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer) { let e = 33189; if (r) { const t = i.depthTexture, r = (t && t.isDepthTexture && (t.type === Ie ? e = 36012 : t.type === Y && (e = 33190)), I(i)); d.renderbufferStorageMultisample(36161, r, e, i.width, i.height) } else d.renderbufferStorage(36161, e, i.width, i.height); d.framebufferRenderbuffer(36160, 36096, 36161, t) } else if (i.depthBuffer && i.stencilBuffer) { if (r) { const t = I(i); d.renderbufferStorageMultisample(36161, t, 35056, i.width, i.height) } else d.renderbufferStorage(36161, 34041, i.width, i.height); d.framebufferRenderbuffer(36160, 33306, 36161, t) } else { const t = !0 === i.isWebGLMultipleRenderTargets ? i.texture[0] : i.texture, e = v.convert(t.format), n = v.convert(t.type), a = T(t.internalFormat, e, n); if (r) { const t = I(i); d.renderbufferStorageMultisample(36161, t, a, i.width, i.height) } else d.renderbufferStorage(36161, a, i.width, i.height) } d.bindRenderbuffer(36161, null) } function I(e) { return x && e.isWebGLMultisampleRenderTarget ? Math.min(B, e.samples) : 0 } let N = !1, H = !1; this.allocateTextureUnit = function () { var e = s; return e >= t && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + t), s += 1, e }, this.resetTextureUnits = function () { s = 0 }, this.setTexture2D = M, this.setTexture2DArray = function (e, t) { var i = f.get(e); 0 < e.version && i.__version !== e.version ? C(i, e, t) : (p.activeTexture(33984 + t), p.bindTexture(35866, i.__webglTexture)) }, this.setTexture3D = function (e, t) { var i = f.get(e); 0 < e.version && i.__version !== e.version ? C(i, e, t) : (p.activeTexture(33984 + t), p.bindTexture(32879, i.__webglTexture)) }, this.setTextureCube = u, this.setupRenderTarget = function (i) { const t = i.texture, r = f.get(i), n = f.get(t); i.addEventListener("dispose", S), !0 !== i.isWebGLMultipleRenderTargets && (n.__webglTexture = d.createTexture(), n.__version = t.version, g.memory.textures++); var e = !0 === i.isWebGLCubeRenderTarget, a = !0 === i.isWebGLMultipleRenderTargets, o = !0 === i.isWebGLMultisampleRenderTarget, s = t.isDataTexture3D || t.isDataTexture2DArray, l = b(i) || x; if (!x || t.format !== Z || t.type !== Ie && t.type !== Ne || (t.format = He, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), e) { r.__webglFramebuffer = []; for (let e = 0; e < 6; e++)r.__webglFramebuffer[e] = d.createFramebuffer() } else if (r.__webglFramebuffer = d.createFramebuffer(), a) if (m.drawBuffers) { const p = i.texture; for (let e = 0, t = p.length; e < t; e++) { const m = f.get(p[e]); void 0 === m.__webglTexture && (m.__webglTexture = d.createTexture(), g.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); else if (o) if (x) { r.__webglMultisampledFramebuffer = d.createFramebuffer(), r.__webglColorRenderbuffer = d.createRenderbuffer(), d.bindRenderbuffer(36161, r.__webglColorRenderbuffer); const f = v.convert(t.format), m = v.convert(t.type), g = T(t.internalFormat, f, m), x = I(i); d.renderbufferStorageMultisample(36161, x, g, i.width, i.height), p.bindFramebuffer(36160, r.__webglMultisampledFramebuffer), d.framebufferRenderbuffer(36160, 36064, 36161, r.__webglColorRenderbuffer), d.bindRenderbuffer(36161, null), i.depthBuffer && (r.__webglDepthRenderbuffer = d.createRenderbuffer(), D(r.__webglDepthRenderbuffer, i, !0)), p.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (e) { p.bindTexture(34067, n.__webglTexture), L(34067, t, l); for (let e = 0; e < 6; e++)F(r.__webglFramebuffer[e], i, t, 36064, 34069 + e); w(t, l) && E(34067, t, i.width, i.height), p.bindTexture(34067, null) } else if (a) { const d = i.texture; for (let e = 0, t = d.length; e < t; e++) { const v = d[e], g = f.get(v); p.bindTexture(3553, g.__webglTexture), L(3553, v, l), F(r.__webglFramebuffer, i, v, 36064 + e, 3553), w(v, l) && E(3553, v, i.width, i.height) } p.bindTexture(3553, null) } else { let e = 3553; s && (x ? e = t.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), p.bindTexture(e, n.__webglTexture), L(e, t, l), F(r.__webglFramebuffer, i, t, 36064, e), w(t, l) && E(e, t, i.width, i.height, i.depth), p.bindTexture(e, null) } if (i.depthBuffer) { var c = i; const h = f.get(c), u = !0 === c.isWebGLCubeRenderTarget; if (c.depthTexture) { if (u) throw new Error("target.depthTexture not supported in Cube render targets"); if (o = h.__webglFramebuffer, (e = c) && e.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (p.bindFramebuffer(36160, o), !e.depthTexture || !e.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); if (f.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), M(e.depthTexture, 0), o = f.get(e.depthTexture).__webglTexture, e.depthTexture.format === J) d.framebufferTexture2D(36160, 36096, 3553, o, 0); else { if (e.depthTexture.format !== K) throw new Error("Unknown depthTexture format"); d.framebufferTexture2D(36160, 33306, 3553, o, 0) } } else if (u) { h.__webglDepthbuffer = []; for (let e = 0; e < 6; e++)p.bindFramebuffer(36160, h.__webglFramebuffer[e]), h.__webglDepthbuffer[e] = d.createRenderbuffer(), D(h.__webglDepthbuffer[e], c, !1) } else p.bindFramebuffer(36160, h.__webglFramebuffer), h.__webglDepthbuffer = d.createRenderbuffer(), D(h.__webglDepthbuffer, c, !1); p.bindFramebuffer(36160, null) } }, this.updateRenderTargetMipmap = function (i) { const r = b(i) || x, n = !0 === i.isWebGLMultipleRenderTargets ? i.texture : [i.texture]; for (let e = 0, t = n.length; e < t; e++) { var a = n[e]; if (w(a, r)) { const r = i.isWebGLCubeRenderTarget ? 34067 : 3553, n = f.get(a).__webglTexture; p.bindTexture(r, n), E(r, a, i.width, i.height), p.bindTexture(r, null) } } }, this.updateMultisampleRenderTarget = function (t) { if (t.isWebGLMultisampleRenderTarget) if (x) { var i = t.width, r = t.height; let e = 16384; t.depthBuffer && (e |= 256), t.stencilBuffer && (e |= 1024); const x = f.get(t); p.bindFramebuffer(36008, x.__webglMultisampledFramebuffer), p.bindFramebuffer(36009, x.__webglFramebuffer), d.blitFramebuffer(0, 0, i, r, 0, 0, i, r, e, 9728), p.bindFramebuffer(36008, null), p.bindFramebuffer(36009, x.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (e, t) { e && e.isWebGLRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), N = !0), e = e.texture), M(e, t) }, this.safeSetTextureCube = function (e, t) { e && e.isWebGLCubeRenderTarget && (!1 === H && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H = !0), e = e.texture), u(e, t) } } function Ra(e, i, t) { const r = t.isWebGL2; return { convert: function (e) { let t; if (e === De) return 5121; if (1017 === e) return 32819; if (1018 === e) return 32820; if (1019 === e) return 33635; if (1010 === e) return 5120; if (1011 === e) return 5122; if (e === q) return 5123; if (1013 === e) return 5124; if (e === Y) return 5125; if (e === Ie) return 5126; if (e === Ne) return r ? 5131 : null !== (t = i.get("OES_texture_half_float")) ? t.HALF_FLOAT_OES : null; if (1021 === e) return 6406; if (e === Z) return 6407; if (e === He) return 6408; if (1024 === e) return 6409; if (1025 === e) return 6410; if (e === J) return 6402; if (e === K) return 34041; if (1028 === e) return 6403; if (1029 === e) return 36244; if (1030 === e) return 33319; if (1031 === e) return 33320; if (1032 === e) return 36248; if (1033 === e) return 36249; if (e === N || e === H || e === B || e === $) { if (null === (t = i.get("WEBGL_compressed_texture_s3tc"))) return null; if (e === N) return t.COMPRESSED_RGB_S3TC_DXT1_EXT; if (e === H) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (e === B) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (e === $) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (e === ee || e === te || e === ie || e === re) { if (null === (t = i.get("WEBGL_compressed_texture_pvrtc"))) return null; if (e === ee) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (e === te) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (e === ie) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (e === re) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === e) return null !== (t = i.get("WEBGL_compressed_texture_etc1")) ? t.COMPRESSED_RGB_ETC1_WEBGL : null; if ((e === ne || e === ae) && null !== (t = i.get("WEBGL_compressed_texture_etc"))) { if (e === ne) return t.COMPRESSED_RGB8_ETC2; if (e === ae) return t.COMPRESSED_RGBA8_ETC2_EAC } return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? null !== (t = i.get("WEBGL_compressed_texture_astc")) ? e : null : 36492 === e ? null !== (t = i.get("EXT_texture_compression_bptc")) ? e : null : e === Q ? r ? 34042 : null !== (t = i.get("WEBGL_depth_texture")) ? t.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } Ta.prototype.isMeshDistanceMaterial = !0; class La extends C { constructor(e = []) { super(), this.cameras = e } } La.prototype.isArrayCamera = !0; class Pa extends u { constructor() { super(), this.type = "Group" } } Pa.prototype.isGroup = !0; const Ca = { type: "move" }; class Fa { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace() { return null === this._hand && (this._hand = new Pa, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace() { return null === this._targetRay && (this._targetRay = new Pa, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Le, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Le), this._targetRay } getGripSpace() { return null === this._grip && (this._grip = new Pa, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Le, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Le), this._grip } dispatchEvent(e) { return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this } disconnect(e) { return this.dispatchEvent({ type: "disconnected", data: e }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this } update(e, t, i) { let r = null, n = null, a = null; const o = this._targetRay, s = this._grip, l = this._hand; if (e && "visible-blurred" !== t.session.visibilityState) if (null !== o && null !== (r = t.getPose(e.targetRaySpace, i)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(Ca)), l && e.hand) { a = !0; for (const r of e.hand.values()) { const e = t.getJointPose(r, i); if (void 0 === l.joints[r.jointName]) { const e = new Pa; e.matrixAutoUpdate = !1, e.visible = !1, l.joints[r.jointName] = e, l.add(e) } const n = l.joints[r.jointName]; null !== e && (n.matrix.fromArray(e.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.jointRadius = e.radius), n.visible = null !== e } const r = l.joints["index-finger-tip"], n = l.joints["thumb-tip"], o = r.position.distanceTo(n.position), s = .02; l.inputState.pinching && .025 < o ? (l.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !l.inputState.pinching && o <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this })) } else null !== s && e.gripSpace && null !== (n = t.getPose(e.gripSpace, i)) && (s.matrix.fromArray(n.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), n.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(n.linearVelocity)) : s.hasLinearVelocity = !1, n.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(n.angularVelocity)) : s.hasAngularVelocity = !1); return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== n), null !== l && (l.visible = null !== a), this } } class Da extends ce { constructor(e, o) { super(); const r = this, s = e.state; let f = null, n = 1, l = null, a = "local-floor", c, h = null, u = null, d = null, p = null; const m = [], v = new Map, g = new C, x = (g.layers.enable(1), g.viewport = new Re, new C), y = (x.layers.enable(2), x.viewport = new Re, [g, x]), _ = new La; _.layers.enable(1), _.layers.enable(2); let b = null, w = null; function E(e) { const t = v.get(e.inputSource); t && t.dispatchEvent({ type: e.type, data: e.inputSource }) } function T() { v.forEach(function (e, t) { e.disconnect(t) }), v.clear(), b = null, w = null, s.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), L.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" }) } function S(t) { var i = f.inputSources; for (let e = 0; e < m.length; e++)v.set(i[e], m[e]); for (let e = 0; e < t.removed.length; e++) { const r = t.removed[e], n = v.get(r); n && (n.dispatchEvent({ type: "disconnected", data: r }), v.delete(r)) } for (let e = 0; e < t.added.length; e++) { const a = t.added[e], o = v.get(a); o && o.dispatchEvent({ type: "connected", data: a }) } } this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = m[e]; return void 0 === t && (t = new Fa, m[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = m[e]; return void 0 === t && (t = new Fa, m[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = m[e]; return void 0 === t && (t = new Fa, m[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { n = e, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { a = e, !0 === r.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return l }, this.getSession = function () { return f }, this.setSession = async function (t) { if (null !== (f = t)) { f.addEventListener("select", E), f.addEventListener("selectstart", E), f.addEventListener("selectend", E), f.addEventListener("squeeze", E), f.addEventListener("squeezestart", E), f.addEventListener("squeezeend", E), f.addEventListener("end", T), f.addEventListener("inputsourceschange", S); const t = o.getContextAttributes(); if (!0 !== t.xrCompatible && await o.makeXRCompatible(), void 0 === f.renderState.layers) { const r = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: n }; p = new XRWebGLLayer(f, o, r), f.updateRenderState({ baseLayer: p }) } else { let e = 0; if (t.antialias) { const r = { antialias: !0, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: n }; p = new XRWebGLLayer(f, o, r), f.updateRenderState({ layers: [p] }) } else { t.depth && (e = t.stencil ? 34041 : 6402); var i = { colorFormat: t.alpha ? 6408 : 6407, depthFormat: e, scaleFactor: n }; h = new XRWebGLBinding(f, o), d = h.createProjectionLayer(i), u = o.createFramebuffer(), f.updateRenderState({ layers: [d] }) } } l = await f.requestReferenceSpace(a), L.setContext(f), L.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" }) } }; const M = new Le, A = new Le; function R(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } this.updateCamera = function (e) { if (null !== f) { _.near = x.near = g.near = e.near, _.far = x.far = g.far = e.far, b === _.near && w === _.far || (f.updateRenderState({ depthNear: _.near, depthFar: _.far }), b = _.near, w = _.far); var t, i, r, n, a, o, s, l, c, h, u = e.parent, d = _.cameras; R(_, u); for (let e = 0; e < d.length; e++)R(d[e], u); _.matrixWorld.decompose(_.position, _.quaternion, _.scale), e.position.copy(_.position), e.quaternion.copy(_.quaternion), e.scale.copy(_.scale), e.matrix.copy(_.matrix), e.matrixWorld.copy(_.matrixWorld); const p = e.children; for (let e = 0, t = p.length; e < t; e++)p[e].updateMatrixWorld(!0); 2 === d.length ? (e = _, t = g, i = x, M.setFromMatrixPosition(t.matrixWorld), A.setFromMatrixPosition(i.matrixWorld), r = M.distanceTo(A), n = t.projectionMatrix.elements, i = i.projectionMatrix.elements, a = n[14] / (n[10] - 1), o = n[14] / (n[10] + 1), s = (n[9] + 1) / n[5], l = (n[9] - 1) / n[5], c = a * (n = (n[8] - 1) / n[0]), h = a * (i = (i[8] + 1) / i[0]), n = (i = r / (i - n)) * -n, t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(n), e.translateZ(i), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(), t = a + i, e.projectionMatrix.makePerspective(c - n, r - n + h, s * o / (a = o + i) * t, l * o / a * t, t, a)) : _.projectionMatrix.copy(g.projectionMatrix) } }, this.getCamera = function () { return _ }, this.getFoveation = function () { return null !== d ? d.fixedFoveation : null !== p ? p.fixedFoveation : void 0 }, this.setFoveation = function (e) { null !== d && (d.fixedFoveation = e), null !== p && void 0 !== p.fixedFoveation && (p.fixedFoveation = e) }; let i = null; const L = new er; L.setAnimationLoop(function (r, t) { if (null !== (c = t.getViewerPose(l))) { const r = c.views; null !== p && s.bindXRFramebuffer(p.framebuffer); let i = !1; r.length !== _.cameras.length && (_.cameras.length = 0, i = !0); for (let t = 0; t < r.length; t++) { const n = r[t]; let e = null; if (null !== p) e = p.getViewport(n); else { const r = h.getViewSubImage(d, n); s.bindXRFramebuffer(u), void 0 !== r.depthStencilTexture && o.framebufferTexture2D(36160, 36096, 3553, r.depthStencilTexture, 0), o.framebufferTexture2D(36160, 36064, 3553, r.colorTexture, 0), e = r.viewport } const a = y[t]; a.matrix.fromArray(n.transform.matrix), a.projectionMatrix.fromArray(n.projectionMatrix), a.viewport.set(e.x, e.y, e.width, e.height), 0 === t && _.matrix.copy(a.matrix), !0 === i && _.cameras.push(a) } } const n = f.inputSources; for (let e = 0; e < m.length; e++) { const o = m[e], s = n[e]; o.update(s, t, l) } i && i(r, t) }), this.setAnimationLoop = function (e) { i = e }, this.dispose = function () { } } } function Ia(a) { function d(e, t) { e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap); var i = a.get(t).envMap; if (i) { e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio; const r = a.get(i).__maxMipLevel; void 0 !== r && (e.maxMipLevel.value = r) } let r, n; t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? r = t.map : t.specularMap ? r = t.specularMap : t.displacementMap ? r = t.displacementMap : t.normalMap ? r = t.normalMap : t.bumpMap ? r = t.bumpMap : t.roughnessMap ? r = t.roughnessMap : t.metalnessMap ? r = t.metalnessMap : t.alphaMap ? r = t.alphaMap : t.emissiveMap ? r = t.emissiveMap : t.clearcoatMap ? r = t.clearcoatMap : t.clearcoatNormalMap ? r = t.clearcoatNormalMap : t.clearcoatRoughnessMap ? r = t.clearcoatRoughnessMap : t.specularIntensityMap ? r = t.specularIntensityMap : t.specularTintMap && (r = t.specularTintMap), void 0 !== r && (!0 === (r = r.isWebGLRenderTarget ? r.texture : r).matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), t.aoMap ? n = t.aoMap : t.lightMap && (n = t.lightMap), void 0 !== n && (!0 === (n = n.isWebGLRenderTarget ? n.texture : n).matrixAutoUpdate && n.updateMatrix(), e.uv2Transform.value.copy(n.matrix)) } function p(e, t) { e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), a.get(t).envMap && (e.envMapIntensity.value = t.envMapIntensity) } return { refreshFogUniforms: function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function (t, i, r, n, a) { if (i.isMeshBasicMaterial) d(t, i); else if (i.isMeshLambertMaterial) d(t, i), u = t, i.emissiveMap && (u.emissiveMap.value = i.emissiveMap); else if (i.isMeshToonMaterial) d(t, i), u = t, (h = i).gradientMap && (u.gradientMap.value = h.gradientMap), h.emissiveMap && (u.emissiveMap.value = h.emissiveMap), h.bumpMap && (u.bumpMap.value = h.bumpMap, u.bumpScale.value = h.bumpScale, 1 === h.side && (u.bumpScale.value *= -1)), h.normalMap && (u.normalMap.value = h.normalMap, u.normalScale.value.copy(h.normalScale), 1 === h.side && u.normalScale.value.negate()), h.displacementMap && (u.displacementMap.value = h.displacementMap, u.displacementScale.value = h.displacementScale, u.displacementBias.value = h.displacementBias); else if (i.isMeshPhongMaterial) d(t, i), (c = t).specular.value.copy((h = i).specular), c.shininess.value = Math.max(h.shininess, 1e-4), h.emissiveMap && (c.emissiveMap.value = h.emissiveMap), h.bumpMap && (c.bumpMap.value = h.bumpMap, c.bumpScale.value = h.bumpScale, 1 === h.side && (c.bumpScale.value *= -1)), h.normalMap && (c.normalMap.value = h.normalMap, c.normalScale.value.copy(h.normalScale), 1 === h.side && c.normalScale.value.negate()), h.displacementMap && (c.displacementMap.value = h.displacementMap, c.displacementScale.value = h.displacementScale, c.displacementBias.value = h.displacementBias); else if (i.isMeshStandardMaterial) d(t, i), i.isMeshPhysicalMaterial ? (c = a, p(a = t, l = i), a.reflectivity.value = l.reflectivity, a.clearcoat.value = l.clearcoat, a.clearcoatRoughness.value = l.clearcoatRoughness, l.sheen && a.sheen.value.copy(l.sheen), l.clearcoatMap && (a.clearcoatMap.value = l.clearcoatMap), l.clearcoatRoughnessMap && (a.clearcoatRoughnessMap.value = l.clearcoatRoughnessMap), l.clearcoatNormalMap && (a.clearcoatNormalScale.value.copy(l.clearcoatNormalScale), a.clearcoatNormalMap.value = l.clearcoatNormalMap, 1 === l.side && a.clearcoatNormalScale.value.negate()), a.transmission.value = l.transmission, l.transmissionMap && (a.transmissionMap.value = l.transmissionMap), 0 < l.transmission && (a.transmissionSamplerMap.value = c.texture, a.transmissionSamplerSize.value.set(c.width, c.height)), a.thickness.value = l.thickness, l.thicknessMap && (a.thicknessMap.value = l.thicknessMap), a.attenuationDistance.value = l.attenuationDistance, a.attenuationTint.value.copy(l.attenuationTint), a.specularIntensity.value = l.specularIntensity, a.specularTint.value.copy(l.specularTint), l.specularIntensityMap && (a.specularIntensityMap.value = l.specularIntensityMap), l.specularTintMap && (a.specularTintMap.value = l.specularTintMap)) : p(t, i); else if (i.isMeshMatcapMaterial) d(t, i), a = t, (l = i).matcap && (a.matcap.value = l.matcap), l.bumpMap && (a.bumpMap.value = l.bumpMap, a.bumpScale.value = l.bumpScale, 1 === l.side && (a.bumpScale.value *= -1)), l.normalMap && (a.normalMap.value = l.normalMap, a.normalScale.value.copy(l.normalScale), 1 === l.side && a.normalScale.value.negate()), l.displacementMap && (a.displacementMap.value = l.displacementMap, a.displacementScale.value = l.displacementScale, a.displacementBias.value = l.displacementBias); else if (i.isMeshDepthMaterial) d(t, i), a = t, (s = i).displacementMap && (a.displacementMap.value = s.displacementMap, a.displacementScale.value = s.displacementScale, a.displacementBias.value = s.displacementBias); else if (i.isMeshDistanceMaterial) d(t, i), a = t, (s = i).displacementMap && (a.displacementMap.value = s.displacementMap, a.displacementScale.value = s.displacementScale, a.displacementBias.value = s.displacementBias), a.referencePosition.value.copy(s.referencePosition), a.nearDistance.value = s.nearDistance, a.farDistance.value = s.farDistance; else if (i.isMeshNormalMaterial) d(t, i), a = t, (e = i).bumpMap && (a.bumpMap.value = e.bumpMap, a.bumpScale.value = e.bumpScale, 1 === e.side && (a.bumpScale.value *= -1)), e.normalMap && (a.normalMap.value = e.normalMap, a.normalScale.value.copy(e.normalScale), 1 === e.side && a.normalScale.value.negate()), e.displacementMap && (a.displacementMap.value = e.displacementMap, a.displacementScale.value = e.displacementScale, a.displacementBias.value = e.displacementBias); else if (i.isLineBasicMaterial) (e = t).diffuse.value.copy((a = i).color), e.opacity.value = a.opacity, i.isLineDashedMaterial && ((o = t).dashSize.value = (a = i).dashSize, o.totalSize.value = a.dashSize + a.gapSize, o.scale.value = a.scale); else if (i.isPointsMaterial) { (o = t).diffuse.value.copy((a = i).color), o.opacity.value = a.opacity, o.size.value = a.size * r, o.scale.value = .5 * n, a.map && (o.map.value = a.map), a.alphaMap && (o.alphaMap.value = a.alphaMap); let e; a.map ? e = a.map : a.alphaMap && (e = a.alphaMap), void 0 !== e && (!0 === e.matrixAutoUpdate && e.updateMatrix(), o.uvTransform.value.copy(e.matrix)) } else if (i.isSpriteMaterial) { (r = t).diffuse.value.copy((n = i).color), r.opacity.value = n.opacity, r.rotation.value = n.rotation, n.map && (r.map.value = n.map), n.alphaMap && (r.alphaMap.value = n.alphaMap); let e; n.map ? e = n.map : n.alphaMap && (e = n.alphaMap), void 0 !== e && (!0 === e.matrixAutoUpdate && e.updateMatrix(), r.uvTransform.value.copy(e.matrix)) } else i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1); var o, e, s, l, c, h, u } } } function o(e = {}) { const n = void 0 !== e.canvas ? e.canvas : function () { const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"); return e.style.display = "block", e }(), i = void 0 !== e.context ? e.context : null, a = void 0 !== e.alpha && e.alpha, o = void 0 === e.depth || e.depth, z = void 0 === e.stencil || e.stencil, O = void 0 !== e.antialias && e.antialias, V = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, k = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, G = void 0 !== e.powerPreference ? e.powerPreference : "default", W = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat; let u = null, b = null; const c = [], h = [], w = (this.domElement = n, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Be, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this); let j = !1, X = 0, q = 0, E = null, Y = -1, T = null; const f = new Re, Q = new Re; let Z = null, r = n.width, S = n.height, M = 1, J = null, K = null; const s = new Re(0, 0, r, S), l = new Re(0, 0, r, S); let $ = !1; const d = [], ee = new $i; let te = !1, ie = !1, A = null; const p = new Pe, R = new Le, re = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function ne() { return null === E ? M : 1 } let m, L, P, v, C, F, D, ae, oe, se, g, x, le, ce, he, I, y, _, ue, de, pe, N, H, B = i; function fe(t, i) { for (let e = 0; e < t.length; e++) { var r = t[e]; if (null !== (r = n.getContext(r, i))) return r } return null } try { const e = { alpha: a, depth: o, stencil: z, antialias: O, premultipliedAlpha: V, preserveDrawingBuffer: k, powerPreference: G, failIfMajorPerformanceCaveat: W }; if (n.addEventListener("webglcontextlost", ve, !1), n.addEventListener("webglcontextrestored", ge, !1), null === B) { const n = ["webgl2", "webgl", "experimental-webgl"]; if (!0 === w.isWebGL1Renderer && n.shift(), null === (B = fe(n, e))) throw fe(n) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } void 0 === B.getShaderPrecisionFormat && (B.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function me() { m = new Hr(B), L = new sr(B, m, e), m.init(L), N = new Ra(B, m, L), P = new Ma(B, m, L), d[0] = 1029, v = new zr(B), C = new da, F = new Aa(B, m, P, C, L, N, v), D = new cr(w), ae = new Nr(w), oe = new tr(B, L), H = new ar(B, m, oe, L), se = new Br(B, oe, v, H), g = new Gr(B, se, oe, v), ue = new kr(B), I = new lr(C), x = new ua(w, D, ae, m, L, H, I), le = new Ia(C), ce = new va(C), he = new wa(m, L), _ = new nr(w, D, P, g, V), y = new Sa(w, g, L), de = new or(B, m, v, L), pe = new Ur(B, m, v, L), v.programs = x.programs, w.capabilities = L, w.extensions = m, w.properties = C, w.renderLists = ce, w.shadowMap = y, w.state = P, w.info = v } me(); const U = new Da(w, B); function ve(e) { e.preventDefault(), j = !0 } function ge() { j = !1; var e = v.autoReset, t = y.enabled, i = y.autoUpdate, r = y.needsUpdate, n = y.type; me(), v.autoReset = e, y.enabled = t, y.autoUpdate = i, y.needsUpdate = r, y.type = n } function xe(e) { const t = e.target; t.removeEventListener("dispose", xe); { var i = e = t; const r = C.get(i).programs; void 0 !== r && r.forEach(function (e) { x.releaseProgram(e) }) } C.remove(e) } this.xr = U, this.getContext = function () { return B }, this.getContextAttributes = function () { return B.getContextAttributes() }, this.forceContextLoss = function () { const e = m.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { const e = m.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return M }, this.setPixelRatio = function (e) { void 0 !== e && (M = e, this.setSize(r, S, !1)) }, this.getSize = function (e) { return e.set(r, S) }, this.setSize = function (e, t, i) { U.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (r = e, S = t, n.width = Math.floor(e * M), n.height = Math.floor(t * M), !1 !== i && (n.style.width = e + "px", n.style.height = t + "px"), this.setViewport(0, 0, e, t)) }, this.getDrawingBufferSize = function (e) { return e.set(r * M, S * M).floor() }, this.setDrawingBufferSize = function (e, t, i) { r = e, S = t, M = i, n.width = Math.floor(e * i), n.height = Math.floor(t * i), this.setViewport(0, 0, e, t) }, this.getCurrentViewport = function (e) { return e.copy(f) }, this.getViewport = function (e) { return e.copy(s) }, this.setViewport = function (e, t, i, r) { e.isVector4 ? s.set(e.x, e.y, e.z, e.w) : s.set(e, t, i, r), P.viewport(f.copy(s).multiplyScalar(M).floor()) }, this.getScissor = function (e) { return e.copy(l) }, this.setScissor = function (e, t, i, r) { e.isVector4 ? l.set(e.x, e.y, e.z, e.w) : l.set(e, t, i, r), P.scissor(Q.copy(l).multiplyScalar(M).floor()) }, this.getScissorTest = function () { return $ }, this.setScissorTest = function (e) { P.setScissorTest($ = e) }, this.setOpaqueSort = function (e) { J = e }, this.setTransparentSort = function (e) { K = e }, this.getClearColor = function (e) { return e.copy(_.getClearColor()) }, this.setClearColor = function () { _.setClearColor.apply(_, arguments) }, this.getClearAlpha = function () { return _.getClearAlpha() }, this.setClearAlpha = function () { _.setClearAlpha.apply(_, arguments) }, this.clear = function (e, t, i) { let r = 0; void 0 !== e && !e || (r |= 16384), void 0 !== t && !t || (r |= 256), void 0 !== i && !i || (r |= 1024), B.clear(r) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { n.removeEventListener("webglcontextlost", ve, !1), n.removeEventListener("webglcontextrestored", ge, !1), ce.dispose(), he.dispose(), C.dispose(), D.dispose(), ae.dispose(), g.dispose(), H.dispose(), U.dispose(), U.removeEventListener("sessionstart", _e), U.removeEventListener("sessionend", be), A && (A.dispose(), A = null), t.stop() }, this.renderBufferImmediate = function (e, t) { H.initAttributes(); const i = C.get(e); e.hasPositions && !i.position && (i.position = B.createBuffer()), e.hasNormals && !i.normal && (i.normal = B.createBuffer()), e.hasUvs && !i.uv && (i.uv = B.createBuffer()), e.hasColors && !i.color && (i.color = B.createBuffer()), t = t.getAttributes(), e.hasPositions && (B.bindBuffer(34962, i.position), B.bufferData(34962, e.positionArray, 35048), H.enableAttribute(t.position), B.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)), e.hasNormals && (B.bindBuffer(34962, i.normal), B.bufferData(34962, e.normalArray, 35048), H.enableAttribute(t.normal), B.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (B.bindBuffer(34962, i.uv), B.bufferData(34962, e.uvArray, 35048), H.enableAttribute(t.uv), B.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)), e.hasColors && (B.bindBuffer(34962, i.color), B.bufferData(34962, e.colorArray, 35048), H.enableAttribute(t.color), B.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)), H.disableUnusedAttributes(), B.drawArrays(4, 0, e.count), e.count = 0 }, this.renderBufferDirect = function (e, t, i, r, n, a) { null === t && (t = re); var o = n.isMesh && n.matrixWorld.determinant() < 0, e = Me(e, t, r, n); P.setMaterial(r, o); let s = i.index; if (t = i.attributes.position, null === s) { if (void 0 === t || 0 === t.count) return } else if (0 === s.count) return; let l, c = 1, h = (!0 === r.wireframe && (s = se.getWireframeAttribute(i), c = 2), void 0 === i.morphAttributes.position && void 0 === i.morphAttributes.normal || ue.update(n, i, r, e), H.setup(n, r, e, i, s), de); null !== s && (l = oe.get(s), (h = pe).setIndex(l)); var o = (null !== s ? s : t).count, e = i.drawRange.start * c, t = i.drawRange.count * c, u = null !== a ? a.start * c : 0, a = null !== a ? a.count * c : 1 / 0, d = Math.max(e, u), o = Math.min(o, e + t, u + a) - 1; if (0 !== (t = Math.max(0, o - d + 1))) { if (n.isMesh) !0 === r.wireframe ? (P.setLineWidth(r.wireframeLinewidth * ne()), h.setMode(1)) : h.setMode(4); else if (n.isLine) { let e = r.linewidth; void 0 === e && (e = 1), P.setLineWidth(e * ne()), n.isLineSegments ? h.setMode(1) : n.isLineLoop ? h.setMode(2) : h.setMode(3) } else n.isPoints ? h.setMode(0) : n.isSprite && h.setMode(4); if (n.isInstancedMesh) h.renderInstances(d, t, n.count); else if (i.isInstancedBufferGeometry) { const e = Math.min(i.instanceCount, i._maxInstanceCount); h.renderInstances(d, t, e) } else h.render(d, t) } }, this.compile = function (r, t) { (b = he.get(r)).init(), h.push(b), r.traverseVisible(function (e) { e.isLight && e.layers.test(t.layers) && (b.pushLight(e), e.castShadow && b.pushShadow(e)) }), b.setupLights(), r.traverse(function (t) { var i = t.material; if (i) if (Array.isArray(i)) for (let e = 0; e < i.length; e++)Te(i[e], r, t); else Te(i, r, t) }), h.pop(), b = null }; let ye = null; function _e() { t.stop() } function be() { t.start() } const t = new er; function we(i, r, n) { var a = !0 === r.isScene ? r.overrideMaterial : null; if (n.isArrayCamera) { var o = n.cameras; for (let e = 0, t = o.length; e < t; e++) { var s = o[e]; P.viewport(f.copy(s.viewport)), b.setupLightsView(s); for (let e = 0, t = i.length; e < t; e++) { const c = i[e], h = c.object, u = c.geometry, d = null === a ? c.material : a, p = c.group; h.layers.test(s.layers) && Ee(h, r, s, u, d, p) } } } else for (let e = 0, t = i.length; e < t; e++) { var l = i[e]; Ee(l.object, r, n, l.geometry, null === a ? l.material : a, l.group) } } function Ee(e, t, i, r, n, a) { if (e.onBeforeRender(w, t, i, r, n, a), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { const r = Me(i, t, n, e); P.setMaterial(n), H.reset(), o = r, e.render(function (e) { w.renderBufferImmediate(e, o) }) } else !0 === n.transparent && 2 === n.side ? (n.side = 1, n.needsUpdate = !0, w.renderBufferDirect(i, t, r, n, e, a), n.side = 0, n.needsUpdate = !0, w.renderBufferDirect(i, t, r, n, e, a), n.side = 2) : w.renderBufferDirect(i, t, r, n, e, a); var o; e.onAfterRender(w, t, i, r, n, a) } function Te(e, t, i) { !0 !== t.isScene && (t = re); const r = C.get(e), n = b.state.lights, a = b.state.shadowsArray, o = n.state.version, s = x.getParameters(e, n.state, a, t, i), l = x.getProgramCacheKey(s); let c = r.programs, h = (r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? ae : D).get(e.envMap || r.environment), void 0 === c && (e.addEventListener("dispose", xe), c = new Map, r.programs = c), c.get(l)); if (void 0 !== h) { if (r.currentProgram === h && r.lightsStateVersion === o) return Se(e, s), h } else s.uniforms = x.getUniforms(e), e.onBuild(s, w), e.onBeforeCompile(s, w), h = x.acquireProgram(s, l), c.set(l, h), r.uniforms = s.uniforms; const u = r.uniforms; return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = I.uniform), Se(e, s), r.needsLights = e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights, r.lightsStateVersion = o, r.needsLights && (u.ambientLightColor.value = n.state.ambient, u.lightProbe.value = n.state.probe, u.directionalLights.value = n.state.directional, u.directionalLightShadows.value = n.state.directionalShadow, u.spotLights.value = n.state.spot, u.spotLightShadows.value = n.state.spotShadow, u.rectAreaLights.value = n.state.rectArea, u.ltc_1.value = n.state.rectAreaLTC1, u.ltc_2.value = n.state.rectAreaLTC2, u.pointLights.value = n.state.point, u.pointLightShadows.value = n.state.pointShadow, u.hemisphereLights.value = n.state.hemi, u.directionalShadowMap.value = n.state.directionalShadowMap, u.directionalShadowMatrix.value = n.state.directionalShadowMatrix, u.spotShadowMap.value = n.state.spotShadowMap, u.spotShadowMatrix.value = n.state.spotShadowMatrix, u.pointShadowMap.value = n.state.pointShadowMap, u.pointShadowMatrix.value = n.state.pointShadowMatrix), i = h.getUniforms(), t = Xn.seqWithValue(i.seq, u), r.currentProgram = h, r.uniformsList = t, h } function Se(e, t) { const i = C.get(e); i.outputEncoding = t.outputEncoding, i.instancing = t.instancing, i.skinning = t.skinning, i.morphTargets = t.morphTargets, i.morphNormals = t.morphNormals, i.numClippingPlanes = t.numClippingPlanes, i.numIntersection = t.numClipIntersection, i.vertexAlphas = t.vertexAlphas, i.vertexTangents = t.vertexTangents } function Me(e, t, i, r) { !0 !== t.isScene && (t = re), F.resetTextureUnits(); const n = t.fog, a = i.isMeshStandardMaterial ? t.environment : null, o = null === E ? w.outputEncoding : E.texture.encoding, s = (i.isMeshStandardMaterial ? ae : D).get(i.envMap || a), l = !0 === i.vertexColors && !!r.geometry && !!r.geometry.attributes.color && 4 === r.geometry.attributes.color.itemSize, c = !!r.geometry && !!r.geometry.attributes.tangent, h = !!r.geometry && !!r.geometry.morphAttributes.position, u = !!r.geometry && !!r.geometry.morphAttributes.normal, d = C.get(i), p = b.state.lights; if (!0 === te && (!0 === ie || e !== T)) { const t = e === T && i.id === Y; I.setState(i, e, t) } let f = !1, m = (i.version === d.__version ? (d.needsLights && d.lightsStateVersion !== p.state.version || d.outputEncoding !== o || r.isInstancedMesh && !1 === d.instancing || !r.isInstancedMesh && !0 === d.instancing || r.isSkinnedMesh && !1 === d.skinning || !r.isSkinnedMesh && !0 === d.skinning || d.envMap !== s || i.fog && d.fog !== n || void 0 !== d.numClippingPlanes && (d.numClippingPlanes !== I.numPlanes || d.numIntersection !== I.numIntersection) || d.vertexAlphas !== l || d.vertexTangents !== c || d.morphTargets !== h || d.morphNormals !== u) && (f = !0) : (f = !0, d.__version = i.version), d.currentProgram), v = !1, g = !1, x = !1; const y = (m = !0 === f ? Te(i, t, r) : m).getUniforms(), _ = d.uniforms; if (P.useProgram(m.program) && (v = !0, g = !0, x = !0), i.id !== Y && (Y = i.id, g = !0), v || T !== e) { if (y.setValue(B, "projectionMatrix", e.projectionMatrix), L.logarithmicDepthBuffer && y.setValue(B, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), T !== e && (T = e, g = !0, x = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) { const t = y.map.cameraPosition; void 0 !== t && t.setValue(B, R.setFromMatrixPosition(e.matrixWorld)) } (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && y.setValue(B, "isOrthographic", !0 === e.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && y.setValue(B, "viewMatrix", e.matrixWorldInverse) } if (r.isSkinnedMesh) { y.setOptional(B, r, "bindMatrix"), y.setOptional(B, r, "bindMatrixInverse"); const e = r.skeleton; e && (L.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(), y.setValue(B, "boneTexture", e.boneTexture, F), y.setValue(B, "boneTextureSize", e.boneTextureSize)) : y.setOptional(B, e, "boneMatrices")) } return !g && d.receiveShadow === r.receiveShadow || (d.receiveShadow = r.receiveShadow, y.setValue(B, "receiveShadow", r.receiveShadow)), g && (y.setValue(B, "toneMappingExposure", w.toneMappingExposure), d.needsLights && (t = x, (e = _).ambientLightColor.needsUpdate = t, e.lightProbe.needsUpdate = t, e.directionalLights.needsUpdate = t, e.directionalLightShadows.needsUpdate = t, e.pointLights.needsUpdate = t, e.pointLightShadows.needsUpdate = t, e.spotLights.needsUpdate = t, e.spotLightShadows.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t), n && i.fog && le.refreshFogUniforms(_, n), le.refreshMaterialUniforms(_, i, M, S, A), Xn.upload(B, d.uniformsList, _, F)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Xn.upload(B, d.uniformsList, _, F), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && y.setValue(B, "center", r.center), y.setValue(B, "modelViewMatrix", r.modelViewMatrix), y.setValue(B, "normalMatrix", r.normalMatrix), y.setValue(B, "modelMatrix", r.matrixWorld), m } t.setAnimationLoop(function (e) { ye && ye(e) }), "undefined" != typeof window && t.setContext(window), this.setAnimationLoop = function (e) { ye = e, U.setAnimationLoop(e), null === e ? t.stop() : t.start() }, U.addEventListener("sessionstart", _e), U.addEventListener("sessionend", be), this.render = function (e, t) { if (void 0 !== t && !0 !== t.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); else if (!0 !== j) { !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), !0 === U.enabled && !0 === U.isPresenting && (!0 === U.cameraAutoUpdate && U.updateCamera(t), t = U.getCamera()), !0 === e.isScene && e.onBeforeRender(w, e, t, E), (b = he.get(e, h.length)).init(), h.push(b), p.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ee.setFromProjectionMatrix(p), ie = this.localClippingEnabled, te = I.init(this.clippingPlanes, ie, t), (u = ce.get(e, c.length)).init(), c.push(u), function i(r, n, a, o) { if (!1 !== r.visible) { if (r.layers.test(n.layers)) if (r.isGroup) a = r.renderOrder; else if (r.isLOD) !0 === r.autoUpdate && r.update(n); else if (r.isLight) b.pushLight(r), r.castShadow && b.pushShadow(r); else if (r.isSprite) { if (!r.frustumCulled || ee.intersectsSprite(r)) { o && R.setFromMatrixPosition(r.matrixWorld).applyMatrix4(p); const n = g.update(r), e = r.material; e.visible && u.push(r, n, e, a, R.z, null) } } else if (r.isImmediateRenderObject) o && R.setFromMatrixPosition(r.matrixWorld).applyMatrix4(p), u.push(r, null, r.material, a, R.z, null); else if ((r.isMesh || r.isLine || r.isPoints) && (r.isSkinnedMesh && r.skeleton.frame !== v.render.frame && (r.skeleton.update(), r.skeleton.frame = v.render.frame), !r.frustumCulled || ee.intersectsObject(r))) { o && R.setFromMatrixPosition(r.matrixWorld).applyMatrix4(p); const n = g.update(r), h = r.material; if (Array.isArray(h)) { const o = n.groups; for (let e = 0, t = o.length; e < t; e++) { var s = o[e], l = h[s.materialIndex]; l && l.visible && u.push(r, n, l, a, R.z, s) } } else h.visible && u.push(r, n, h, a, R.z, null) } var c = r.children; for (let e = 0, t = c.length; e < t; e++)i(c[e], n, a, o) } }(e, t, 0, w.sortObjects), u.finish(), !0 === w.sortObjects && u.sort(J, K), !0 === te && I.beginShadows(); var i = b.state.shadowsArray, i = (y.render(i, e, t), b.setupLights(), b.setupLightsView(t), !0 === te && I.endShadows(), !0 === this.info.autoReset && this.info.reset(), _.render(u, e), u.opaque), r = u.transmissive, n = u.transparent; if (0 < i.length && we(i, e, t), 0 < r.length) { var a = i, o = (i = r, r = e, t); if (null === A) { const a = !0 === O && !0 === L.isWebGL2; A = new (a ? ze : Ue)(1024, 1024, { generateMipmaps: !0, type: null !== N.convert(Ne) ? Ne : De, minFilter: Fe, magFilter: Ae, wrapS: Ce, wrapT: Ce }) } var s = w.getRenderTarget(), l = (w.setRenderTarget(A), w.clear(), w.toneMapping); w.toneMapping = 0, we(a, r, o), w.toneMapping = l, F.updateMultisampleRenderTarget(A), F.updateRenderTargetMipmap(A), w.setRenderTarget(s), we(i, r, o) } 0 < n.length && we(n, e, t), null !== E && (F.updateMultisampleRenderTarget(E), F.updateRenderTargetMipmap(E)), !0 === e.isScene && e.onAfterRender(w, e, t), P.buffers.depth.setTest(!0), P.buffers.depth.setMask(!0), P.buffers.color.setMask(!0), P.setPolygonOffset(!1), H.resetDefaultState(), Y = -1, T = null, h.pop(), b = 0 < h.length ? h[h.length - 1] : null, c.pop(), u = 0 < c.length ? c[c.length - 1] : null } }, this.getActiveCubeFace = function () { return X }, this.getActiveMipmapLevel = function () { return q }, this.getRenderTarget = function () { return E }, this.setRenderTarget = function (t, e = 0, i = 0) { E = t, X = e, q = i, t && void 0 === C.get(t).__webglFramebuffer && F.setupRenderTarget(t); let r = null, n = !1, a = !1; if (t) { const i = t.texture; (i.isDataTexture3D || i.isDataTexture2DArray) && (a = !0); var o = C.get(t).__webglFramebuffer; t.isWebGLCubeRenderTarget ? (r = o[e], n = !0) : r = t.isWebGLMultisampleRenderTarget ? C.get(t).__webglMultisampledFramebuffer : o, f.copy(t.viewport), Q.copy(t.scissor), Z = t.scissorTest } else f.copy(s).multiplyScalar(M).floor(), Q.copy(l).multiplyScalar(M).floor(), Z = $; if (P.bindFramebuffer(36160, r) && L.drawBuffers) { let e = !1; if (t) if (t.isWebGLMultipleRenderTargets) { const i = t.texture; if (d.length !== i.length || 36064 !== d[0]) { for (let e = 0, t = i.length; e < t; e++)d[e] = 36064 + e; d.length = i.length, e = !0 } } else 1 === d.length && 36064 === d[0] || (d[0] = 36064, d.length = 1, e = !0); else 1 === d.length && 1029 === d[0] || (d[0] = 1029, d.length = 1, e = !0); e && (L.isWebGL2 ? B.drawBuffers(d) : m.get("WEBGL_draw_buffers").drawBuffersWEBGL(d)) } if (P.viewport(f), P.scissor(Q), P.setScissorTest(Z), n) { const r = C.get(t.texture); B.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, i) } else if (a) { const r = C.get(t.texture), n = e || 0; B.framebufferTextureLayer(36160, 36064, r.__webglTexture, i || 0, n) } }, this.readRenderTargetPixels = function (t, i, r, n, a, o, s) { if (t && t.isWebGLRenderTarget) { let e = C.get(t).__webglFramebuffer; if (e = t.isWebGLCubeRenderTarget && void 0 !== s ? e[s] : e) { P.bindFramebuffer(36160, e); try { const s = t.texture, c = s.format, h = s.type; if (c !== He && N.convert(c) !== B.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); var l = h === Ne && (m.has("EXT_color_buffer_half_float") || L.isWebGL2 && m.has("EXT_color_buffer_float")); if (!(h === De || N.convert(h) === B.getParameter(35738) || h === Ie && (L.isWebGL2 || m.has("OES_texture_float") || m.has("WEBGL_color_buffer_float")) || l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === B.checkFramebufferStatus(36160) ? 0 <= i && i <= t.width - n && 0 <= r && r <= t.height - a && B.readPixels(i, r, n, a, N.convert(c), N.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { const t = null !== E ? C.get(E).__webglFramebuffer : null; P.bindFramebuffer(36160, t) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function (e, t, i = 0) { var r = Math.pow(2, -i), n = Math.floor(t.image.width * r), r = Math.floor(t.image.height * r); let a = N.convert(t.format); L.isWebGL2 && 6408 === (a = 6407 === a ? 32849 : a) && (a = 32856), F.setTexture2D(t, 0), B.copyTexImage2D(3553, i, a, e.x, e.y, n, r, 0), P.unbindTexture() }, this.copyTextureToTexture = function (e, t, i, r = 0) { var n = t.image.width, a = t.image.height, o = N.convert(i.format), s = N.convert(i.type); F.setTexture2D(i, 0), B.pixelStorei(37440, i.flipY), B.pixelStorei(37441, i.premultiplyAlpha), B.pixelStorei(3317, i.unpackAlignment), t.isDataTexture ? B.texSubImage2D(3553, r, e.x, e.y, n, a, o, s, t.image.data) : t.isCompressedTexture ? B.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : B.texSubImage2D(3553, r, e.x, e.y, o, s, t.image), 0 === r && i.generateMipmaps && B.generateMipmap(3553), P.unbindTexture() }, this.copyTextureToTexture3D = function (t, i, r, n, a = 0) { if (w.isWebGL1Renderer) console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); else { var o = t.max.x - t.min.x + 1, s = t.max.y - t.min.y + 1, l = t.max.z - t.min.z + 1, c = N.convert(n.format), h = N.convert(n.type); let e; if (n.isDataTexture3D) F.setTexture3D(n, 0), e = 32879; else { if (!n.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); F.setTexture2DArray(n, 0), e = 35866 } B.pixelStorei(37440, n.flipY), B.pixelStorei(37441, n.premultiplyAlpha), B.pixelStorei(3317, n.unpackAlignment); var u = B.getParameter(3314), d = B.getParameter(32878), p = B.getParameter(3316), f = B.getParameter(3315), m = B.getParameter(32877), v = r.isCompressedTexture ? r.mipmaps[0] : r.image; B.pixelStorei(3314, v.width), B.pixelStorei(32878, v.height), B.pixelStorei(3316, t.min.x), B.pixelStorei(3315, t.min.y), B.pixelStorei(32877, t.min.z), r.isDataTexture || r.isDataTexture3D ? B.texSubImage3D(e, a, i.x, i.y, i.z, o, s, l, c, h, v.data) : r.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), B.compressedTexSubImage3D(e, a, i.x, i.y, i.z, o, s, l, c, v.data)) : B.texSubImage3D(e, a, i.x, i.y, i.z, o, s, l, c, h, v), B.pixelStorei(3314, u), B.pixelStorei(32878, d), B.pixelStorei(3316, p), B.pixelStorei(3315, f), B.pixelStorei(32877, m), 0 === a && n.generateMipmaps && B.generateMipmap(e), P.unbindTexture() } }, this.initTexture = function (e) { F.setTexture2D(e, 0), P.unbindTexture() }, this.resetState = function () { X = 0, q = 0, E = null, P.reset(), H.reset() }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } class Na extends o { } class Ha { constructor(e, t = 25e-5) { this.name = "", this.color = new y(e), this.density = t } clone() { return new Ha(this.color, this.density) } toJSON() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } } Ha.prototype.isFogExp2 = Na.prototype.isWebGL1Renderer = !0; class Ba { constructor(e, t = 1, i = 1e3) { this.name = "", this.color = new y(e), this.near = t, this.far = i } clone() { return new Ba(this.color, this.near, this.far) } toJSON() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } } Ba.prototype.isFog = !0; class Ua extends u { constructor() { super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy(e, t) { return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this } toJSON(e) { const t = super.toJSON(e); return null !== this.fog && (t.object.fog = this.fog.toJSON()), t } } Ua.prototype.isScene = !0; class za { constructor(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = oe, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = pe() } onUploadCallback() { } set needsUpdate(e) { !0 === e && this.version++ } setUsage(e) { return this.usage = e, this } copy(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this } copyAt(i, r, n) { i *= this.stride, n *= r.stride; for (let e = 0, t = this.stride; e < t; e++)this.array[i + e] = r.array[n + e]; return this } set(e, t = 0) { return this.array.set(e, t), this } clone(e) { void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = pe()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride); return i.setUsage(this.usage), i } onUpload(e) { return this.onUploadCallback = e, this } toJSON(e) { return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = pe()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } } za.prototype.isInterleavedBuffer = !0; const s = new Le; class Oa { constructor(e, t, i, r = !1) { this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === r } get count() { return this.data.count } get array() { return this.data.array } set needsUpdate(e) { this.data.needsUpdate = e } applyMatrix4(i) { for (let e = 0, t = this.data.count; e < t; e++)s.x = this.getX(e), s.y = this.getY(e), s.z = this.getZ(e), s.applyMatrix4(i), this.setXYZ(e, s.x, s.y, s.z); return this } applyNormalMatrix(i) { for (let e = 0, t = this.count; e < t; e++)s.x = this.getX(e), s.y = this.getY(e), s.z = this.getZ(e), s.applyNormalMatrix(i), this.setXYZ(e, s.x, s.y, s.z); return this } transformDirection(i) { for (let e = 0, t = this.count; e < t; e++)s.x = this.getX(e), s.y = this.getY(e), s.z = this.getZ(e), s.transformDirection(i), this.setXYZ(e, s.x, s.y, s.z); return this } setX(e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this } setY(e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this } setZ(e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this } setW(e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this } getX(e) { return this.data.array[e * this.data.stride + this.offset] } getY(e) { return this.data.array[e * this.data.stride + this.offset + 1] } getZ(e) { return this.data.array[e * this.data.stride + this.offset + 2] } getW(e) { return this.data.array[e * this.data.stride + this.offset + 3] } setXY(e, t, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this } setXYZ(e, t, i, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this } setXYZW(e, t, i, r, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = n, this } clone(t) { if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Oa(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized); { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { var i = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[i + e]) } return new P(new this.array.constructor(t), this.itemSize, this.normalized) } } toJSON(t) { if (void 0 !== t) return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized }; { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."); const t = []; for (let e = 0; e < this.count; e++) { var i = e * this.data.stride + this.offset; for (let e = 0; e < this.itemSize; e++)t.push(this.data.array[i + e]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized } } } } Oa.prototype.isInterleavedBufferAttribute = !0; class Va extends t { constructor(e) { super(), this.type = "SpriteMaterial", this.color = new y(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this } } let ka; Va.prototype.isSpriteMaterial = !0; const Ga = new Le, Wa = new Le, ja = new Le, Xa = new k, qa = new k, Ya = new Pe, Qa = new Le, Za = new Le, Ja = new Le, Ka = new k, $a = new k, eo = new k; class to extends u { constructor(e) { if (super(), this.type = "Sprite", void 0 === ka) { ka = new S; const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), t = new za(e, 5); ka.setIndex([0, 1, 2, 0, 2, 3]), ka.setAttribute("position", new Oa(t, 3, 0, !1)), ka.setAttribute("uv", new Oa(t, 2, 3, !1)) } this.geometry = ka, this.material = void 0 !== e ? e : new Va, this.center = new k(.5, .5) } raycast(e, t) { null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Wa.setFromMatrixScale(this.matrixWorld), Ya.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ja.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Wa.multiplyScalar(-ja.z); let i, r; 0 !== (n = this.material.rotation) && (r = Math.cos(n), i = Math.sin(n)); var n = this.center; io(Qa.set(-.5, -.5, 0), ja, n, Wa, i, r), io(Za.set(.5, -.5, 0), ja, n, Wa, i, r), io(Ja.set(.5, .5, 0), ja, n, Wa, i, r), Ka.set(0, 0), $a.set(1, 0), eo.set(1, 1), null === e.ray.intersectTriangle(Qa, Za, Ja, !1, Ga) && (io(Za.set(-.5, .5, 0), ja, n, Wa, i, r), $a.set(0, 1), null === e.ray.intersectTriangle(Qa, Ja, Za, !1, Ga)) || (n = e.ray.origin.distanceTo(Ga)) < e.near || n > e.far || t.push({ distance: n, point: Ga.clone(), uv: x.getUV(Ga, Qa, Za, Ja, Ka, $a, eo, new k), face: null, object: this }) } copy(e) { return super.copy(e), void 0 !== e.center && this.center.copy(e.center), this.material = e.material, this } } function io(e, t, i, r, n, a) { Xa.subVectors(e, i).addScalar(.5).multiply(r), void 0 !== n ? (qa.x = a * Xa.x - n * Xa.y, qa.y = n * Xa.x + a * Xa.y) : qa.copy(Xa), e.copy(t), e.x += qa.x, e.y += qa.y, e.applyMatrix4(Ya) } to.prototype.isSprite = !0; const ro = new Le, no = new Le; class ao extends u { constructor() { super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }), this.autoUpdate = !0 } copy(e) { super.copy(e, !1); var i = e.levels; for (let e = 0, t = i.length; e < t; e++) { const r = i[e]; this.addLevel(r.object.clone(), r.distance) } return this.autoUpdate = e.autoUpdate, this } addLevel(e, t = 0) { t = Math.abs(t); const i = this.levels; let r; for (r = 0; r < i.length && !(t < i[r].distance); r++); return i.splice(r, 0, { distance: t, object: e }), this.add(e), this } getCurrentLevel() { return this._currentLevel } getObjectForDistance(i) { var r = this.levels; if (0 < r.length) { let e, t; for (e = 1, t = r.length; e < t && !(i < r[e].distance); e++); return r[e - 1].object } return null } raycast(e, t) { var i; 0 < this.levels.length && (ro.setFromMatrixPosition(this.matrixWorld), i = e.ray.origin.distanceTo(ro), this.getObjectForDistance(i).raycast(e, t)) } update(i) { const r = this.levels; if (1 < r.length) { ro.setFromMatrixPosition(i.matrixWorld), no.setFromMatrixPosition(this.matrixWorld); var n = ro.distanceTo(no) / i.zoom; let e, t; for (r[0].object.visible = !0, e = 1, t = r.length; e < t && n >= r[e].distance; e++)r[e - 1].object.visible = !1, r[e].object.visible = !0; for (this._currentLevel = e - 1; e < t; e++)r[e].object.visible = !1 } } toJSON(e) { const i = super.toJSON(e); !1 === this.autoUpdate && (i.object.autoUpdate = !1), i.object.levels = []; var r = this.levels; for (let e = 0, t = r.length; e < t; e++) { var n = r[e]; i.object.levels.push({ object: n.object.uuid, distance: n.distance }) } return i } } const oo = new Le, so = new Re, lo = new Re, co = new Le, ho = new Pe; class uo extends M { constructor(e, t) { super(e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Pe, this.bindMatrixInverse = new Pe } copy(e) { return super.copy(e), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this } bind(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert() } pose() { this.skeleton.pose() } normalizeSkinWeights() { const i = new Re, r = this.geometry.attributes.skinWeight; for (let e = 0, t = r.count; e < t; e++) { i.x = r.getX(e), i.y = r.getY(e), i.z = r.getZ(e), i.w = r.getW(e); var n = 1 / i.manhattanLength(); n != 1 / 0 ? i.multiplyScalar(n) : i.set(1, 0, 0, 0), r.setXYZW(e, i.x, i.y, i.z, i.w) } } updateMatrixWorld(e) { super.updateMatrixWorld(e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) } boneTransform(e, t) { const i = this.skeleton, r = this.geometry; so.fromBufferAttribute(r.attributes.skinIndex, e), lo.fromBufferAttribute(r.attributes.skinWeight, e), oo.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix), t.set(0, 0, 0); for (let e = 0; e < 4; e++) { const r = lo.getComponent(e); var n; 0 !== r && (n = so.getComponent(e), ho.multiplyMatrices(i.bones[n].matrixWorld, i.boneInverses[n]), t.addScaledVector(co.copy(oo).applyMatrix4(ho), r)) } return t.applyMatrix4(this.bindMatrixInverse) } } uo.prototype.isSkinnedMesh = !0; class po extends u { constructor() { super(), this.type = "Bone" } } po.prototype.isBone = !0; class fo extends h { constructor(e = null, t = 1, i = 1, r, n, a, o, s, l = 1003, c = 1003, h, u) { super(null, a, o, s, l, c, r, n, h, u), this.image = { data: e, width: t, height: i }, this.magFilter = l, this.minFilter = c, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0 } } fo.prototype.isDataTexture = !0; const mo = new Pe, vo = new Pe; class go { constructor(e = [], t = []) { this.uuid = pe(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init() { var e = this.bones, t = this.boneInverses; if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses(); else if (e.length !== t.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let e = 0, t = this.bones.length; e < t; e++)this.boneInverses.push(new Pe) } } calculateInverses() { for (let e = this.boneInverses.length = 0, t = this.bones.length; e < t; e++) { const i = new Pe; this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i) } } pose() { for (let e = 0, t = this.bones.length; e < t; e++) { const i = this.bones[e]; i && i.matrixWorld.copy(this.boneInverses[e]).invert() } for (let e = 0, t = this.bones.length; e < t; e++) { const r = this.bones[e]; r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale)) } } update() { const i = this.bones, r = this.boneInverses, n = this.boneMatrices, e = this.boneTexture; for (let e = 0, t = i.length; e < t; e++) { var a = i[e] ? i[e].matrixWorld : vo; mo.multiplyMatrices(a, r[e]), mo.toArray(n, 16 * e) } null !== e && (e.needsUpdate = !0) } clone() { return new go(this.bones, this.boneInverses) } computeBoneTexture() { var e = ge(Math.sqrt(4 * this.bones.length)), e = Math.max(e, 4); const t = new Float32Array(e * e * 4); t.set(this.boneMatrices); var i = new fo(t, e, e, He, Ie); return this.boneMatrices = t, this.boneTexture = i, this.boneTextureSize = e, this } getBoneByName(i) { for (let e = 0, t = this.bones.length; e < t; e++) { var r = this.bones[e]; if (r.name === i) return r } } dispose() { null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON(i, r) { this.uuid = i.uuid; for (let t = 0, e = i.bones.length; t < e; t++) { var n = i.bones[t]; let e = r[n]; void 0 === e && (console.warn("THREE.Skeleton: No bone found with UUID:", n), e = new po), this.bones.push(e), this.boneInverses.push((new Pe).fromArray(i.boneInverses[t])) } return this.init(), this } toJSON() { const i = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; i.uuid = this.uuid; var r = this.bones, n = this.boneInverses; for (let e = 0, t = r.length; e < t; e++) { var a = r[e]; i.bones.push(a.uuid); const o = n[e]; i.boneInverses.push(o.toArray()) } return i } } const xo = new Pe, yo = new Pe, _o = [], bo = new M; class wo extends M { constructor(e, t, i) { super(e, t), this.instanceMatrix = new P(new Float32Array(16 * i), 16), this.instanceColor = null, this.count = i, this.frustumCulled = !1 } copy(e) { return super.copy(e), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this } getColorAt(e, t) { t.fromArray(this.instanceColor.array, 3 * e) } getMatrixAt(e, t) { t.fromArray(this.instanceMatrix.array, 16 * e) } raycast(e, r) { const n = this.matrixWorld, t = this.count; if (bo.geometry = this.geometry, bo.material = this.material, void 0 !== bo.material) for (let i = 0; i < t; i++) { this.getMatrixAt(i, xo), yo.multiplyMatrices(n, xo), bo.matrixWorld = yo, bo.raycast(e, _o); for (let e = 0, t = _o.length; e < t; e++) { const n = _o[e]; n.instanceId = i, n.object = this, r.push(n) } _o.length = 0 } } setColorAt(e, t) { null === this.instanceColor && (this.instanceColor = new P(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e) } setMatrixAt(e, t) { t.toArray(this.instanceMatrix.array, 16 * e) } updateMorphTargets() { } dispose() { this.dispatchEvent({ type: "dispose" }) } } wo.prototype.isInstancedMesh = !0; class v extends t { constructor(e) { super(), this.type = "LineBasicMaterial", this.color = new y(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this } } v.prototype.isLineBasicMaterial = !0; const Eo = new Le, To = new Le, So = new Pe, Mo = new pt, Ao = new at; class Ro extends u { constructor(e = new S, t = new v) { super(), this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const i = e.attributes.position, r = [0]; for (let e = 1, t = i.count; e < t; e++)Eo.fromBufferAttribute(i, e - 1), To.fromBufferAttribute(i, e), r[e] = r[e - 1], r[e] += Eo.distanceTo(To); e.setAttribute("lineDistance", new G(r, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } raycast(i, r) { const e = this.geometry, n = this.matrixWorld, a = i.params.Line.threshold, o = e.drawRange; if (null === e.boundingSphere && e.computeBoundingSphere(), Ao.copy(e.boundingSphere), Ao.applyMatrix4(n), Ao.radius += a, !1 !== i.ray.intersectsSphere(Ao)) { So.copy(n).invert(), Mo.copy(i.ray).applyMatrix4(So); const t = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = t * t, c = new Le, h = new Le, u = new Le, d = new Le, p = this.isLineSegments ? 2 : 1; if (e.isBufferGeometry) { const n = e.index, a = e.attributes.position; if (null !== n) for (let e = Math.max(0, o.start), t = Math.min(n.count, o.start + o.count) - 1; e < t; e += p) { const o = n.getX(e), f = n.getX(e + 1); var s; c.fromBufferAttribute(a, o), h.fromBufferAttribute(a, f), Mo.distanceSqToSegment(c, h, d, u) > l || (d.applyMatrix4(this.matrixWorld), (s = i.ray.origin.distanceTo(d)) < i.near || s > i.far || r.push({ distance: s, point: u.clone().applyMatrix4(this.matrixWorld), index: e, face: null, faceIndex: null, object: this })) } else for (let e = Math.max(0, o.start), t = Math.min(a.count, o.start + o.count) - 1; e < t; e += p)if (c.fromBufferAttribute(a, e), h.fromBufferAttribute(a, e + 1), !(Mo.distanceSqToSegment(c, h, d, u) > l)) { d.applyMatrix4(this.matrixWorld); const n = i.ray.origin.distanceTo(d); n < i.near || n > i.far || r.push({ distance: n, point: u.clone().applyMatrix4(this.matrixWorld), index: e, face: null, faceIndex: null, object: this }) } } else e.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } updateMorphTargets() { const i = this.geometry; if (i.isBufferGeometry) { var e = i.morphAttributes, t = Object.keys(e); if (0 < t.length) { const i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { var r = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else void 0 !== (e = i.morphTargets) && 0 < e.length && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } Ro.prototype.isLine = !0; const Lo = new Le, Po = new Le; class Co extends Ro { constructor(e, t) { super(e, t), this.type = "LineSegments" } computeLineDistances() { const e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { const i = e.attributes.position, r = []; for (let e = 0, t = i.count; e < t; e += 2)Lo.fromBufferAttribute(i, e), Po.fromBufferAttribute(i, e + 1), r[e] = 0 === e ? 0 : r[e - 1], r[e + 1] = r[e] + Lo.distanceTo(Po); e.setAttribute("lineDistance", new G(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); return this } } Co.prototype.isLineSegments = !0; class Fo extends Ro { constructor(e, t) { super(e, t), this.type = "LineLoop" } } Fo.prototype.isLineLoop = !0; class Do extends t { constructor(e) { super(), this.type = "PointsMaterial", this.color = new y(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this } } Do.prototype.isPointsMaterial = !0; const Io = new Pe, No = new pt, Ho = new at, Bo = new Le; class Uo extends u { constructor(e = new S, t = new Do) { super(), this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets() } copy(e) { return super.copy(e), this.material = e.material, this.geometry = e.geometry, this } raycast(i, r) { const e = this.geometry, n = this.matrixWorld, a = i.params.Points.threshold, o = e.drawRange; if (null === e.boundingSphere && e.computeBoundingSphere(), Ho.copy(e.boundingSphere), Ho.applyMatrix4(n), Ho.radius += a, !1 !== i.ray.intersectsSphere(Ho)) { Io.copy(n).invert(), No.copy(i.ray).applyMatrix4(Io); var t = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), s = t * t; if (e.isBufferGeometry) { const a = e.index, l = e.attributes.position; if (null !== a) for (let e = Math.max(0, o.start), t = Math.min(a.count, o.start + o.count); e < t; e++) { const o = a.getX(e); Bo.fromBufferAttribute(l, o), zo(Bo, o, s, n, i, r, this) } else for (let e = Math.max(0, o.start), t = Math.min(l.count, o.start + o.count); e < t; e++)Bo.fromBufferAttribute(l, e), zo(Bo, e, s, n, i, r, this) } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } } updateMorphTargets() { const i = this.geometry; if (i.isBufferGeometry) { var e = i.morphAttributes, t = Object.keys(e); if (0 < t.length) { const i = e[t[0]]; if (void 0 !== i) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let e = 0, t = i.length; e < t; e++) { var r = i[e].name || String(e); this.morphTargetInfluences.push(0), this.morphTargetDictionary[r] = e } } } } else void 0 !== (e = i.morphTargets) && 0 < e.length && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.") } } function zo(e, t, i, r, n, a, o) { var s = No.distanceSqToPoint(e); if (s < i) { const i = new Le; No.closestPointToPoint(e, i), i.applyMatrix4(r), (e = n.ray.origin.distanceTo(i)) < n.near || e > n.far || a.push({ distance: e, distanceToRay: Math.sqrt(s), point: i, index: t, face: null, object: o }) } } Uo.prototype.isPoints = !0; class Oo extends h { constructor(t, e, i, r, n, a, o, s, l) { super(t, e, i, r, n, a, o, s, l), this.format = void 0 !== o ? o : Z, this.minFilter = void 0 !== a ? a : U, this.magFilter = void 0 !== n ? n : U, this.generateMipmaps = !1; const c = this; "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() { c.needsUpdate = !0, t.requestVideoFrameCallback(e) }) } clone() { return new this.constructor(this.image).copy(this) } update() { var e = this.image; 0 == "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } } class Vo extends h { constructor(e, t, i, r, n, a, o, s, l, c, h, u) { super(null, a, o, s, l, c, r, n, h, u), this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } } Vo.prototype.isCompressedTexture = Oo.prototype.isVideoTexture = !0; class ko extends h { constructor(e, t, i, r, n, a, o, s, l) { super(e, t, i, r, n, a, o, s, l), this.needsUpdate = !0 } } class Go extends h { constructor(e, t, i, r, n, a, o, s, l, c) { if ((c = void 0 !== c ? c : J) !== J && c !== K) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); super(null, r, n, a, o, s, c, i = void 0 === (i = void 0 === i && c === J ? q : i) && c === K ? Q : i, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== o ? o : Ae, this.minFilter = void 0 !== s ? s : Ae, this.flipY = !1, this.generateMipmaps = !1 } } Go.prototype.isDepthTexture = ko.prototype.isCanvasTexture = !0; class Wo extends S { constructor(i = 1, r = 8, n = 0, a = 2 * Math.PI) { super(), this.type = "CircleGeometry", this.parameters = { radius: i, segments: r, thetaStart: n, thetaLength: a }, r = Math.max(3, r); const t = [], o = [], s = [], l = [], c = new Le, h = new k; o.push(0, 0, 0), s.push(0, 0, 1), l.push(.5, .5); for (let e = 0, t = 3; e <= r; e++, t += 3) { var u = n + e / r * a; c.x = i * Math.cos(u), c.y = i * Math.sin(u), o.push(c.x, c.y, c.z), s.push(0, 0, 1), h.x = (o[t] / i + 1) / 2, h.y = (o[t + 1] / i + 1) / 2, l.push(h.x, h.y) } for (let e = 1; e <= r; e++)t.push(e, e + 1, 0); this.setIndex(t), this.setAttribute("position", new G(o, 3)), this.setAttribute("normal", new G(s, 3)), this.setAttribute("uv", new G(l, 2)) } static fromJSON(e) { return new Wo(e.radius, e.segments, e.thetaStart, e.thetaLength) } } class jo extends S { constructor(c = 1, h = 1, r = 1, u = 8, n = 1, e = !1, d = 0, p = 2 * Math.PI) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: c, radiusBottom: h, height: r, radialSegments: u, heightSegments: n, openEnded: e, thetaStart: d, thetaLength: p }; const f = this, m = (u = Math.floor(u), n = Math.floor(n), []), v = [], g = [], x = []; let y = 0; const a = [], _ = r / 2; let b = 0; function t(t) { const i = y, r = new k, n = new Le; let a = 0; var o = !0 === t ? c : h, s = !0 === t ? 1 : -1; for (let e = 1; e <= u; e++)v.push(0, _ * s, 0), g.push(0, s, 0), x.push(.5, .5), y++; var l = y; for (let e = 0; e <= u; e++) { const h = e / u * p + d, t = Math.cos(h), i = Math.sin(h); n.x = o * i, n.y = _ * s, n.z = o * t, v.push(n.x, n.y, n.z), g.push(0, s, 0), r.x = .5 * t + .5, r.y = .5 * i * s + .5, x.push(r.x, r.y), y++ } for (let e = 0; e < u; e++) { const h = i + e, u = l + e; !0 === t ? m.push(u, u + 1, h) : m.push(u + 1, u, h), a += 3 } f.addGroup(b, a, !0 === t ? 1 : 2), b += a } { const s = new Le, l = new Le; let i = 0; var o = (h - c) / r; for (let e = 0; e <= n; e++) { const m = [], b = e / n, t = b * (h - c) + c; for (let e = 0; e <= u; e++) { const h = e / u, n = h * p + d, f = Math.sin(n), a = Math.cos(n); l.x = t * f, l.y = -b * r + _, l.z = t * a, v.push(l.x, l.y, l.z), s.set(f, o, a).normalize(), g.push(s.x, s.y, s.z), x.push(h, 1 - b), m.push(y++) } a.push(m) } for (let t = 0; t < u; t++)for (let e = 0; e < n; e++) { const r = a[e][t], u = a[e + 1][t], n = a[e + 1][t + 1], w = a[e][t + 1]; m.push(r, u, w), m.push(u, n, w), i += 6 } f.addGroup(b, i, 0), b += i } !1 === e && (0 < c && t(!0), 0 < h && t(!1)), this.setIndex(m), this.setAttribute("position", new G(v, 3)), this.setAttribute("normal", new G(g, 3)), this.setAttribute("uv", new G(x, 2)) } static fromJSON(e) { return new jo(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class Xo extends jo { constructor(e = 1, t = 1, i = 8, r = 1, n = !1, a = 0, o = 2 * Math.PI) { super(0, e, t, i, r, n, a, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: n, thetaStart: a, thetaLength: o } } static fromJSON(e) { return new Xo(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength) } } class qo extends S { constructor(i, t, e = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: i, indices: t, radius: e, detail: r }; const n = [], a = []; function o(e) { n.push(e.x, e.y, e.z) } function s(e, t) { t.x = i[0 + (e *= 3)], t.y = i[1 + e], t.z = i[2 + e] } function l(e, t, i, r) { r < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === i.x && 0 === i.z && (a[t] = r / 2 / Math.PI + .5) } function c(e) { return Math.atan2(e.z, -e.x) } var h = r, u = new Le, d = new Le, p = new Le; for (let e = 0; e < t.length; e += 3) { s(t[e + 0], u), s(t[e + 1], d), s(t[e + 2], p); { var f = void 0, m = void 0, v = void 0, f = u, m = d, v = p; const E = h + 1, T = []; for (let t = 0; t <= E; t++) { T[t] = []; const S = f.clone().lerp(v, t / E), o = m.clone().lerp(v, t / E), M = E - t; for (let e = 0; e <= M; e++)T[t][e] = 0 === e && t === E ? S : S.clone().lerp(o, e / M) } for (let t = 0; t < E; t++)for (let e = 0; e < 2 * (E - t) - 1; e++) { const v = Math.floor(e / 2); e % 2 == 0 ? (o(T[t][v + 1]), o(T[t + 1][v]), o(T[t][v])) : (o(T[t][v + 1]), o(T[t + 1][v + 1]), o(T[t + 1][v])) } } } { var g = e; const A = new Le; for (let e = 0; e < n.length; e += 3)A.x = n[e + 0], A.y = n[e + 1], A.z = n[e + 2], A.normalize().multiplyScalar(g), n[e + 0] = A.x, n[e + 1] = A.y, n[e + 2] = A.z } { const R = new Le; for (let e = 0; e < n.length; e += 3) { R.x = n[e + 0], R.y = n[e + 1], R.z = n[e + 2]; var H = c(R) / 2 / Math.PI + .5, x = (x = R, Math.atan2(-x.y, Math.sqrt(x.x * x.x + x.z * x.z)) / Math.PI + .5); a.push(H, 1 - x) } { const L = new Le, P = new Le, C = new Le, F = new Le, D = new k, I = new k, N = new k; for (let e = 0, t = 0; e < n.length; e += 9, t += 6) { L.set(n[e + 0], n[e + 1], n[e + 2]), P.set(n[e + 3], n[e + 4], n[e + 5]), C.set(n[e + 6], n[e + 7], n[e + 8]), D.set(a[t + 0], a[t + 1]), I.set(a[t + 2], a[t + 3]), N.set(a[t + 4], a[t + 5]), F.copy(L).add(P).add(C).divideScalar(3); var y = c(F); l(D, t + 0, L, y), l(I, t + 2, P, y), l(N, t + 4, C, y) } } for (let e = 0; e < a.length; e += 6) { var _ = a[e + 0], b = a[e + 2], w = a[e + 4], B = Math.max(_, b, w), U = Math.min(_, b, w); .9 < B && U < .1 && (_ < .2 && (a[e + 0] += 1), b < .2 && (a[e + 2] += 1), w < .2 && (a[e + 4] += 1)) } } this.setAttribute("position", new G(n, 3)), this.setAttribute("normal", new G(n.slice(), 3)), this.setAttribute("uv", new G(a, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals() } static fromJSON(e) { return new qo(e.vertices, e.indices, e.radius, e.details) } } class Yo extends qo { constructor(e = 1, t = 0) { var i = (1 + Math.sqrt(5)) / 2, r = 1 / i; super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Yo(e.radius, e.detail) } } const Qo = new Le, Zo = new Le, Jo = new Le, Ko = new x; class $o extends S { constructor(e, t) { if (super(), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t }, t = void 0 !== t ? t : 1, !0 === e.isGeometry) console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); else { const i = Math.cos(ue * t), r = e.getIndex(), n = e.getAttribute("position"), a = (r || n).count, o = [0, 0, 0], s = ["a", "b", "c"], l = new Array(3), c = {}, h = []; for (let e = 0; e < a; e += 3) { r ? (o[0] = r.getX(e), o[1] = r.getX(e + 1), o[2] = r.getX(e + 2)) : (o[0] = e, o[1] = e + 1, o[2] = e + 2); const { a: t, b: u, c: d } = Ko; if (t.fromBufferAttribute(n, o[0]), u.fromBufferAttribute(n, o[1]), d.fromBufferAttribute(n, o[2]), Ko.getNormal(Jo), l[0] = `${t.x},${t.y},` + t.z, l[1] = `${u.x},${u.y},` + u.z, l[2] = `${d.x},${d.y},` + d.z, l[0] !== l[1] && l[1] !== l[2] && l[2] !== l[0]) for (let e = 0; e < 3; e++) { const t = (e + 1) % 3, p = l[e], f = l[t], m = Ko[s[e]], v = Ko[s[t]], g = p + "_" + f, x = f + "_" + p; x in c && c[x] ? (Jo.dot(c[x].normal) <= i && (h.push(m.x, m.y, m.z), h.push(v.x, v.y, v.z)), c[x] = null) : g in c || (c[g] = { index0: o[e], index1: o[t], normal: Jo.clone() }) } } for (const e in c) if (c[e]) { const { index0: t, index1: y } = c[e]; Qo.fromBufferAttribute(n, t), Zo.fromBufferAttribute(n, y), h.push(Qo.x, Qo.y, Qo.z), h.push(Zo.x, Zo.y, Zo.z) } this.setAttribute("position", new G(h, 3)) } } } class es { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint() { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt(e, t) { return e = this.getUtoTmapping(e), this.getPoint(e, t) } getPoints(t = 5) { const i = []; for (let e = 0; e <= t; e++)i.push(this.getPoint(e / t)); return i } getSpacedPoints(t = 5) { const i = []; for (let e = 0; e <= t; e++)i.push(this.getPointAt(e / t)); return i } getLength() { var e = this.getLengths(); return e[e.length - 1] } getLengths(t = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; const i = []; let r, n = this.getPoint(0), a = 0; i.push(0); for (let e = 1; e <= t; e++)r = this.getPoint(e / t), a += r.distanceTo(n), i.push(a), n = r; return this.cacheArcLengths = i } updateArcLengths() { this.needsUpdate = !0, this.getLengths() } getUtoTmapping(e, t) { var i = this.getLengths(); let r = 0; var n = i.length, a = t || e * i[n - 1]; let o, s = 0, l = n - 1; for (; s <= l;)if ((o = i[r = Math.floor(s + (l - s) / 2)] - a) < 0) s = r + 1; else { if (!(0 < o)) { l = r; break } l = r - 1 } return i[r = l] === a ? r / (n - 1) : (t = i[r], (r + (a - t) / (i[r + 1] - t)) / (n - 1)) } getTangent(e, t) { let i = e - 1e-4, r = e + 1e-4; i < 0 && (i = 0), 1 < r && (r = 1); const n = this.getPoint(i), a = this.getPoint(r), o = t || new (n.isVector2 ? k : Le); return o.copy(a).sub(n).normalize(), o } getTangentAt(e, t) { return e = this.getUtoTmapping(e), this.getTangent(e, t) } computeFrenetFrames(i, e) { const t = new Le, r = [], n = [], a = [], o = new Le, s = new Pe; for (let e = 0; e <= i; e++) { const t = e / i; r[e] = this.getTangentAt(t, new Le), r[e].normalize() } n[0] = new Le, a[0] = new Le; let l = Number.MAX_VALUE; var c = Math.abs(r[0].x), h = Math.abs(r[0].y), u = Math.abs(r[0].z); c <= l && (l = c, t.set(1, 0, 0)), h <= l && (l = h, t.set(0, 1, 0)), u <= l && t.set(0, 0, 1), o.crossVectors(r[0], t).normalize(), n[0].crossVectors(r[0], o), a[0].crossVectors(r[0], n[0]); for (let e = 1; e <= i; e++) { if (n[e] = n[e - 1].clone(), a[e] = a[e - 1].clone(), o.crossVectors(r[e - 1], r[e]), o.length() > Number.EPSILON) { o.normalize(); const i = Math.acos(f(r[e - 1].dot(r[e]), -1, 1)); n[e].applyMatrix4(s.makeRotationAxis(o, i)) } a[e].crossVectors(r[e], n[e]) } if (!0 === e) { let t = Math.acos(f(n[0].dot(n[i]), -1, 1)); t /= i, 0 < r[0].dot(o.crossVectors(n[0], n[i])) && (t = -t); for (let e = 1; e <= i; e++)n[e].applyMatrix4(s.makeRotationAxis(r[e], t * e)), a[e].crossVectors(r[e], n[e]) } return { tangents: r, normals: n, binormals: a } } clone() { return (new this.constructor).copy(this) } copy(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } toJSON() { const e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e } fromJSON(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } } class ts extends es { constructor(e = 0, t = 0, i = 1, r = 1, n = 0, a = 2 * Math.PI, o = !1, s = 0) { super(), this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = n, this.aEndAngle = a, this.aClockwise = o, this.aRotation = s } getPoint(e, t) { const i = t || new k, r = 2 * Math.PI; let n = this.aEndAngle - this.aStartAngle; for (t = Math.abs(n) < Number.EPSILON; n < 0;)n += r; for (; n > r;)n -= r; n < Number.EPSILON && (n = t ? 0 : r), !0 !== this.aClockwise || t || (n === r ? n = -r : n -= r), t = this.aStartAngle + e * n; let a = this.aX + this.xRadius * Math.cos(t), o = this.aY + this.yRadius * Math.sin(t); if (0 !== this.aRotation) { const e = Math.cos(this.aRotation), t = Math.sin(this.aRotation), i = a - this.aX, r = o - this.aY; a = i * e - r * t + this.aX, o = i * t + r * e + this.aY } return i.set(a, o) } copy(e) { return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } toJSON() { const e = super.toJSON(); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e } fromJSON(e) { return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this } } ts.prototype.isEllipseCurve = !0; class is extends ts { constructor(e, t, i, r, n, a) { super(e, t, i, i, r, n, a), this.type = "ArcCurve" } } function rs() { let n = 0, a = 0, o = 0, s = 0; function l(e, t, i, r) { n = e, a = i, o = -3 * e + 3 * t - 2 * i - r, s = 2 * e - 2 * t + i + r } return { initCatmullRom: function (e, t, i, r, n) { l(t, i, n * (i - e), n * (r - t)) }, initNonuniformCatmullRom: function (e, t, i, r, n, a, o) { e = (t - e) / n - (i - e) / (n + a) + (i - t) / a, n = (i - t) / a - (r - t) / (a + o) + (r - i) / o, l(t, i, e *= a, n *= a) }, calc: function (e) { var t = e * e; return n + a * e + o * t + s * (t * e) } } } is.prototype.isArcCurve = !0; const ns = new Le, as = new rs, os = new rs, ss = new rs; class ls extends es { constructor(e = [], t = !1, i = "centripetal", r = .5) { super(), this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r } getPoint(r, e = new Le) { const t = e, i = this.points, n = i.length, a = (n - (this.closed ? 0 : 1)) * r; let o, s, l = Math.floor(a), c = a - l; this.closed ? l += 0 < l ? 0 : (Math.floor(Math.abs(l) / n) + 1) * n : 0 === c && l === n - 1 && (l = n - 2, c = 1), o = this.closed || 0 < l ? i[(l - 1) % n] : (ns.subVectors(i[0], i[1]).add(i[0]), ns); const h = i[l % n], u = i[(l + 1) % n]; if (s = this.closed || l + 2 < n ? i[(l + 2) % n] : (ns.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), ns), "centripetal" === this.curveType || "chordal" === this.curveType) { const r = "chordal" === this.curveType ? .5 : .25; let e = Math.pow(o.distanceToSquared(h), r), t = Math.pow(h.distanceToSquared(u), r), i = Math.pow(u.distanceToSquared(s), r); t < 1e-4 && (t = 1), e < 1e-4 && (e = t), i < 1e-4 && (i = t), as.initNonuniformCatmullRom(o.x, h.x, u.x, s.x, e, t, i), os.initNonuniformCatmullRom(o.y, h.y, u.y, s.y, e, t, i), ss.initNonuniformCatmullRom(o.z, h.z, u.z, s.z, e, t, i) } else "catmullrom" === this.curveType && (as.initCatmullRom(o.x, h.x, u.x, s.x, this.tension), os.initCatmullRom(o.y, h.y, u.y, s.y, this.tension), ss.initCatmullRom(o.z, h.z, u.z, s.z, this.tension)); return t.set(as.calc(c), os.calc(c), ss.calc(c)), t } copy(i) { super.copy(i), this.points = []; for (let e = 0, t = i.points.length; e < t; e++) { const r = i.points[e]; this.points.push(r.clone()) } return this.closed = i.closed, this.curveType = i.curveType, this.tension = i.tension, this } toJSON() { const i = super.toJSON(); i.points = []; for (let e = 0, t = this.points.length; e < t; e++) { const r = this.points[e]; i.points.push(r.toArray()) } return i.closed = this.closed, i.curveType = this.curveType, i.tension = this.tension, i } fromJSON(i) { super.fromJSON(i), this.points = []; for (let e = 0, t = i.points.length; e < t; e++) { var r = i.points[e]; this.points.push((new Le).fromArray(r)) } return this.closed = i.closed, this.curveType = i.curveType, this.tension = i.tension, this } } function cs(e, t, i, r, n) { var a = e * e; return e * a * (2 * i - 2 * r + (t = .5 * (r - t)) + (n = .5 * (n - i))) + (-3 * i + 3 * r - 2 * t - n) * a + t * e + i } function hs(e, t, i, r) { return (n = 1 - e) * n * t + 2 * (1 - e) * e * i + e * e * r; var n } function us(e, t, i, r, n) { return (a = 1 - e) * a * a * t + 3 * (a = 1 - e) * a * e * i + 3 * (1 - e) * e * e * r + e * e * e * n; var a } class ds extends es { constructor(e = new k, t = new k, i = new k, r = new k) { super(), this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new k) { const i = t, r = this.v0, n = this.v1, a = this.v2, o = this.v3; return i.set(us(e, r.x, n.x, a.x, o.x), us(e, r.y, n.y, a.y, o.y)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } ds.prototype.isCubicBezierCurve = ls.prototype.isCatmullRomCurve3 = !0; class ps extends es { constructor(e = new Le, t = new Le, i = new Le, r = new Le) { super(), this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r } getPoint(e, t = new Le) { const i = t, r = this.v0, n = this.v1, a = this.v2, o = this.v3; return i.set(us(e, r.x, n.x, a.x, o.x), us(e, r.y, n.y, a.y, o.y), us(e, r.z, n.z, a.z, o.z)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this } } class fs extends es { constructor(e = new k, t = new k) { super(), this.type = "LineCurve", this.v1 = e, this.v2 = t } getPoint(e, t = new k) { const i = t; return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i } getPointAt(e, t) { return this.getPoint(e, t) } getTangent(e, t) { const i = t || new k; return i.copy(this.v2).sub(this.v1).normalize(), i } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } fs.prototype.isLineCurve = ps.prototype.isCubicBezierCurve3 = !0; class ms extends es { constructor(e = new Le, t = new Le) { super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = e, this.v2 = t } getPoint(e, t = new Le) { const i = t; return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i } getPointAt(e, t) { return this.getPoint(e, t) } copy(e) { return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class vs extends es { constructor(e = new k, t = new k, i = new k) { super(), this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new k) { const i = t, r = this.v0, n = this.v1, a = this.v2; return i.set(hs(e, r.x, n.x, a.x), hs(e, r.y, n.y, a.y)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } vs.prototype.isQuadraticBezierCurve = !0; class gs extends es { constructor(e = new Le, t = new Le, i = new Le) { super(), this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i } getPoint(e, t = new Le) { const i = t, r = this.v0, n = this.v1, a = this.v2; return i.set(hs(e, r.x, n.x, a.x), hs(e, r.y, n.y, a.y), hs(e, r.z, n.z, a.z)), i } copy(e) { return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this } toJSON() { const e = super.toJSON(); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this } } class xs extends es { constructor(e = []) { super(), this.type = "SplineCurve", this.points = e } getPoint(e, t = new k) { const i = t, r = this.points, n = (r.length - 1) * e, a = Math.floor(n), o = n - a, s = r[0 === a ? a : a - 1], l = r[a], c = r[a > r.length - 2 ? r.length - 1 : a + 1], h = r[a > r.length - 3 ? r.length - 1 : a + 2]; return i.set(cs(o, s.x, l.x, c.x, h.x), cs(o, s.y, l.y, c.y, h.y)), i } copy(i) { super.copy(i), this.points = []; for (let e = 0, t = i.points.length; e < t; e++) { const r = i.points[e]; this.points.push(r.clone()) } return this } toJSON() { const i = super.toJSON(); i.points = []; for (let e = 0, t = this.points.length; e < t; e++) { const r = this.points[e]; i.points.push(r.toArray()) } return i } fromJSON(i) { super.fromJSON(i), this.points = []; for (let e = 0, t = i.points.length; e < t; e++) { var r = i.points[e]; this.points.push((new k).fromArray(r)) } return this } } xs.prototype.isSplineCurve = gs.prototype.isQuadraticBezierCurve3 = !0; var ys = Object.freeze({ __proto__: null, ArcCurve: is, CatmullRomCurve3: ls, CubicBezierCurve: ds, CubicBezierCurve3: ps, EllipseCurve: ts, LineCurve: fs, LineCurve3: ms, QuadraticBezierCurve: vs, QuadraticBezierCurve3: gs, SplineCurve: xs }); function _s(t, e, i = 2) { var r = e && e.length, n = r ? e[0] * i : t.length; let a = bs(t, 0, n, i, !0); var o = []; if (!a || a.next === a.prev) return o; let s, l, c, h, u, d, p; if (r && (a = function (e, t, i, r) { const n = []; let a, o, s, l, c; for (a = 0, o = t.length; a < o; a++)s = t[a] * r, l = a < o - 1 ? t[a + 1] * r : e.length, (c = bs(e, s, l, r, !1)) === c.next && (c.steiner = !0), n.push(function (e) { let t = e, i = e; for (; (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), (t = t.next) !== e;); return i }(c)); for (n.sort(Es), a = 0; a < n.length; a++)(u = function (e, t) { let i = t; var r = e.x, n = e.y; let a, o = -1 / 0; do { if (n <= i.y && n >= i.next.y && i.next.y !== i.y) { const e = i.x + (n - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (e <= r && e > o) { if ((o = e) === r) { if (n === i.y) return i; if (n === i.next.y) return i.next } a = i.x < i.next.x ? i : i.next } } } while ((i = i.next) !== t); if (!a) return null; if (r === o) return a; var s, l, c = a, h = a.x, u = a.y; let d, p = 1 / 0; for (i = a; r >= i.x && i.x >= h && r !== i.x && Ss(n < u ? r : o, n, h, u, n < u ? o : r, n, i.x, i.y) && (d = Math.abs(n - i.y) / (r - i.x), Ps(i, e) && (d < p || d === p && (i.x > a.x || i.x === a.x && (s = a, l = i, _(s.prev, s, l.prev) < 0 && _(l.next, s, s.next) < 0))) && (a = i, p = d)), (i = i.next) !== c;); return a }(h = n[a], i)) && (h = Cs(u, h), ws(u, u.next), ws(h, h.next)), i = ws(i, i.next); var h, u; return i }(t, e, a, i)), t.length > 80 * i) { s = c = t[0], l = h = t[1]; for (let e = i; e < n; e += i)u = t[e], d = t[e + 1], u < s && (s = u), d < l && (l = d), u > c && (c = u), d > h && (h = d); p = 0 !== (p = Math.max(c - s, h - l)) ? 1 / p : 0 } return function c(r, n, a, d, p, f, o) { if (r) { if (!o && f) { var s = r, l = d, h = p, u = f; let c = s; for (; null === c.z && (c.z = Ts(c.x, c.y, l, h, u)), c.prevZ = c.prev, c.nextZ = c.next, (c = c.next) !== s;); c.prevZ.nextZ = null, c.prevZ = null; { var m = c; let e, t, i, r, n, a, o, s, l = 1; do { for (t = m, m = null, n = null, a = 0; t;) { for (a++, i = t, o = 0, e = 0; e < l && (o++, i = i.nextZ); e++); for (s = l; 0 < o || 0 < s && i;)0 !== o && (0 === s || !i || t.z <= i.z) ? (t = (r = t).nextZ, o--) : (i = (r = i).nextZ, s--), n ? n.nextZ = r : m = r, r.prevZ = n, n = r; t = i } } while (n.nextZ = null, l *= 2, 1 < a) } } let e, t, i = r; for (; r.prev !== r.next;)if (e = r.prev, t = r.next, (f ? function (i) { var r = i.prev, n = i, a = i.next; if (!(0 <= _(r, n, a))) { var o = (r.x < n.x ? r.x < a.x ? r : a : n.x < a.x ? n : a).x, s = (r.y < n.y ? r.y < a.y ? r : a : n.y < a.y ? n : a).y, l = (r.x > n.x ? r.x > a.x ? r : a : n.x > a.x ? n : a).x, c = (r.y > n.y ? r.y > a.y ? r : a : n.y > a.y ? n : a).y, h = Ts(o, s, d, p, f), u = Ts(l, c, d, p, f); let e = i.prevZ, t = i.nextZ; for (; e && e.z >= h && t && t.z <= u;) { if (e !== i.prev && e !== i.next && Ss(r.x, r.y, n.x, n.y, a.x, a.y, e.x, e.y) && 0 <= _(e.prev, e, e.next)) return; if (e = e.prevZ, t !== i.prev && t !== i.next && Ss(r.x, r.y, n.x, n.y, a.x, a.y, t.x, t.y) && 0 <= _(t.prev, t, t.next)) return; t = t.nextZ } for (; e && e.z >= h;) { if (e !== i.prev && e !== i.next && Ss(r.x, r.y, n.x, n.y, a.x, a.y, e.x, e.y) && 0 <= _(e.prev, e, e.next)) return; e = e.prevZ } for (; t && t.z <= u;) { if (t !== i.prev && t !== i.next && Ss(r.x, r.y, n.x, n.y, a.x, a.y, t.x, t.y) && 0 <= _(t.prev, t, t.next)) return; t = t.nextZ } return 1 } } : function (t) { var i = t.prev, r = t, n = t.next; if (!(0 <= _(i, r, n))) { let e = t.next.next; for (; e !== t.prev;) { if (Ss(i.x, i.y, r.x, r.y, n.x, n.y, e.x, e.y) && 0 <= _(e.prev, e, e.next)) return; e = e.next } return 1 } })(r)) n.push(e.i / a), n.push(r.i / a), n.push(t.i / a), Ds(r), r = t.next, i = t.next; else if ((r = t) === i) { o ? 1 === o ? c(r = function (e, t, i) { let r = e; do { var n = r.prev, a = r.next.next } while (!Ms(n, a) && As(n, r, r.next, a) && Ps(n, a) && Ps(a, n) && (t.push(n.i / i), t.push(r.i / i), t.push(a.i / i), Ds(r), Ds(r.next), r = e = a), (r = r.next) !== e); return ws(r) }(ws(r), n, a), n, a, d, p, f, 2) : 2 === o && function (e, t, i, r, n, a) { let o = e; do { let e = o.next.next; for (; e !== o.prev;) { if (o.i !== e.i && (s = o, l = e, s.next.i !== l.i && s.prev.i !== l.i && !function (e, t) { let i = e; do { if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && As(i, i.next, e, t)) return 1 } while ((i = i.next) !== e) }(s, l) && (Ps(s, l) && Ps(l, s) && function (e) { let t = e, i = !1; for (var r = (e.x + l.x) / 2, n = (e.y + l.y) / 2; t.y > n != t.next.y > n && t.next.y !== t.y && r < (t.next.x - t.x) * (n - t.y) / (t.next.y - t.y) + t.x && (i = !i), (t = t.next) !== e;); return i }(s) && (_(s.prev, s, l.prev) || _(s, l.prev, l)) || Ms(s, l) && 0 < _(s.prev, s, s.next) && 0 < _(l.prev, l, l.next)))) return s = Cs(o, e), o = ws(o, o.next), s = ws(s, s.next), c(o, t, i, r, n, a), c(s, t, i, r, n, a); e = e.next } } while ((o = o.next) !== e); var s, l }(r, n, a, d, p, f) : c(ws(r), n, a, d, p, f, 1); break } } }(a, o, i, s, l, p), o } function bs(e, o, t, i, r) { let n, a; if (r === 0 < function (i, r, n) { let a = 0; for (let e = o, t = r - n; e < r; e += n)a += (i[t] - i[e]) * (i[e + 1] + i[t + 1]), t = e; return a }(e, t, i)) for (n = o; n < t; n += i)a = Fs(n, e[n], e[n + 1], a); else for (n = t - i; n >= o; n -= i)a = Fs(n, e[n], e[n + 1], a); return a && Ms(a, a.next) && (Ds(a), a = a.next), a } function ws(e, t) { if (!e) return e; t = t || e; let i, r = e; do { if (i = !1, r.steiner || !Ms(r, r.next) && 0 !== _(r.prev, r, r.next)) r = r.next; else { if (Ds(r), (r = t = r.prev) === r.next) break; i = !0 } } while (i || r !== t); return t } function Es(e, t) { return e.x - t.x } function Ts(e, t, i, r, n) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * n) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - r) * n) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function Ss(e, t, i, r, n, a, o, s) { return 0 <= (n - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (r - s) - (i - o) * (t - s) && 0 <= (i - o) * (a - s) - (n - o) * (r - s) } function _(e, t, i) { return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y) } function Ms(e, t) { return e.x === t.x && e.y === t.y } function As(e, t, i, r) { var n = Ls(_(e, t, i)), a = Ls(_(e, t, r)), o = Ls(_(i, r, e)), s = Ls(_(i, r, t)); return n !== a && o !== s || 0 === n && Rs(e, i, t) || 0 === a && Rs(e, r, t) || 0 === o && Rs(i, e, r) || 0 === s && Rs(i, t, r) } function Rs(e, t, i) { return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y) } function Ls(e) { return 0 < e ? 1 : e < 0 ? -1 : 0 } function Ps(e, t) { return _(e.prev, e, e.next) < 0 ? 0 <= _(e, t, e.next) && 0 <= _(e, e.prev, t) : _(e, t, e.prev) < 0 || _(e, e.next, t) < 0 } function Cs(e, t) { const i = new Is(e.i, e.x, e.y), r = new Is(t.i, t.x, t.y), n = e.next, a = t.prev; return (e.next = t).prev = e, (i.next = n).prev = i, (r.next = i).prev = r, (a.next = r).prev = a, r } function Fs(e, t, i, r) { const n = new Is(e, t, i); return r ? (n.next = r.next, (n.prev = r).next.prev = n, r.next = n) : (n.prev = n).next = n, n } function Ds(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function Is(e, t, i) { this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } class Ns { static area(i) { var r = i.length; let n = 0; for (let e = r - 1, t = 0; t < r; e = t++)n += i[e].x * i[t].y - i[t].x * i[e].y; return .5 * n } static isClockWise(e) { return Ns.area(e) < 0 } static triangulateShape(e, t) { const i = [], r = [], n = []; Hs(e), Bs(i, e); let a = e.length; t.forEach(Hs); for (let e = 0; e < t.length; e++)r.push(a), a += t[e].length, Bs(i, t[e]); const o = _s(i, r); for (let e = 0; e < o.length; e += 3)n.push(o.slice(e, e + 3)); return n } } function Hs(e) { var t = e.length; 2 < t && e[t - 1].equals(e[0]) && e.pop() } function Bs(t, i) { for (let e = 0; e < i.length; e++)t.push(i[e].x), t.push(i[e].y) } class Us extends S { constructor(i, U) { super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: i, options: U }, i = Array.isArray(i) ? i : [i]; const z = this, O = [], V = []; for (let e = 0, t = i.length; e < t; e++)!function (e) { const r = [], H = void 0 !== U.curveSegments ? U.curveSegments : 12, u = void 0 !== U.steps ? U.steps : 1; let i = void 0 !== U.depth ? U.depth : 100, n = void 0 === U.bevelEnabled || U.bevelEnabled, t = void 0 !== U.bevelThickness ? U.bevelThickness : 6, a = void 0 !== U.bevelSize ? U.bevelSize : t - 2, o = void 0 !== U.bevelOffset ? U.bevelOffset : 0, d = void 0 !== U.bevelSegments ? U.bevelSegments : 3; const s = U.extrudePath, p = void 0 !== U.UVGenerator ? U.UVGenerator : zs; void 0 !== U.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), i = U.amount); let l, c, h, f, m, v = !1, g = (s && (l = s.getSpacedPoints(u), v = !0, n = !1, c = s.computeFrenetFrames(u, !1), h = new Le, f = new Le, m = new Le), n || (d = 0, t = 0, a = 0, o = 0), (e = e.extractPoints(H)).shape); const x = e.holes; if (!Ns.isClockWise(g)) { g = g.reverse(); for (let e = 0, t = x.length; e < t; e++) { const U = x[e]; Ns.isClockWise(U) && (x[e] = U.reverse()) } } var y = Ns.triangulateShape(g, x), _ = g; for (let e = 0, t = x.length; e < t; e++) { const U = x[e]; g = g.concat(U) } function b(e, t, i) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e) } const w = g.length, E = y.length; function T(e, t, i) { let r, n, a; const o = e.x - t.x, s = e.y - t.y, l = i.x - e.x, c = i.y - e.y, h = o * o + s * s, u = o * c - s * l; if (Math.abs(u) > Number.EPSILON) { const u = Math.sqrt(h), d = Math.sqrt(l * l + c * c), p = t.x - s / u, f = t.y + o / u, m = ((i.x - c / d - p) * c - (i.y + l / d - f) * l) / (o * c - s * l); if (r = p + o * m - e.x, n = f + s * m - e.y, (t = r * r + n * n) <= 2) return new k(r, n); a = Math.sqrt(t / 2) } else { let e = !1; o > Number.EPSILON ? l > Number.EPSILON && (e = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(s) === Math.sign(c) && (e = !0), a = e ? (r = -s, n = o, Math.sqrt(h)) : (r = o, n = s, Math.sqrt(h / 2)) } return new k(r / a, n / a) } const S = []; for (let e = 0, t = _.length, i = t - 1, r = e + 1; e < t; e++, i++, r++)i === t && (i = 0), r === t && (r = 0), S[e] = T(_[e], _[i], _[r]); const M = []; let A, R = S.concat(); for (let e = 0, t = x.length; e < t; e++) { const U = x[e]; A = []; for (let e = 0, t = U.length, i = t - 1, r = e + 1; e < t; e++, i++, r++)i === t && (i = 0), r === t && (r = 0), A[e] = T(U[e], U[i], U[r]); M.push(A), R = R.concat(A) } for (let e = 0; e < d; e++) { const U = e / d, z = t * Math.cos(U * Math.PI / 2), O = a * Math.sin(U * Math.PI / 2) + o; for (let e = 0, t = _.length; e < t; e++) { const U = b(_[e], S[e], O); P(U.x, U.y, -z) } for (let e = 0, t = x.length; e < t; e++) { const U = x[e]; A = M[e]; for (let e = 0, t = U.length; e < t; e++) { const V = b(U[e], A[e], O); P(V.x, V.y, -z) } } } var L = a + o; for (let e = 0; e < w; e++) { const U = n ? b(g[e], R[e], L) : g[e]; v ? (f.copy(c.normals[0]).multiplyScalar(U.x), h.copy(c.binormals[0]).multiplyScalar(U.y), m.copy(l[0]).add(f).add(h), P(m.x, m.y, m.z)) : P(U.x, U.y, 0) } for (let t = 1; t <= u; t++)for (let e = 0; e < w; e++) { const z = n ? b(g[e], R[e], L) : g[e]; v ? (f.copy(c.normals[t]).multiplyScalar(z.x), h.copy(c.binormals[t]).multiplyScalar(z.y), m.copy(l[t]).add(f).add(h), P(m.x, m.y, m.z)) : P(z.x, z.y, i / u * t) } for (let e = d - 1; 0 <= e; e--) { const U = e / d, z = t * Math.cos(U * Math.PI / 2), O = a * Math.sin(U * Math.PI / 2) + o; for (let e = 0, t = _.length; e < t; e++) { const U = b(_[e], S[e], O); P(U.x, U.y, i + z) } for (let e = 0, t = x.length; e < t; e++) { const U = x[e]; A = M[e]; for (let e = 0, t = U.length; e < t; e++) { const V = b(U[e], A[e], O); v ? P(V.x, V.y + l[u - 1].y, l[u - 1].x + z) : P(V.x, V.y, i + z) } } } function B(e, r) { let n = e.length; for (; 0 <= --n;) { var a = n; let i = n - 1; i < 0 && (i = e.length - 1); for (let e = 0, t = u + 2 * d; e < t; e++) { const n = w * e, h = w * (e + 1); var o = r + a + n, s = r + i + n, l = r + i + h, c = r + a + h; F(o), F(s), F(c), F(s), F(l), F(c), o = O.length / 3, D((s = p.generateSideWallUV(z, O, o - 6, o - 3, o - 2, o - 1))[0]), D(s[1]), D(s[3]), D(s[1]), D(s[2]), D(s[3]) } } } function P(e, t, i) { r.push(e), r.push(t), r.push(i) } function C(e, t, i) { F(e), F(t), F(i), e = O.length / 3, D((t = p.generateTopUV(z, O, e - 3, e - 2, e - 1))[0]), D(t[1]), D(t[2]) } function F(e) { O.push(r[3 * e + 0]), O.push(r[3 * e + 1]), O.push(r[3 * e + 2]) } function D(e) { V.push(e.x), V.push(e.y) } if (e = O.length / 3, n) { let e, t = 0 * w; for (let e = 0; e < E; e++) { const z = y[e]; C(z[2] + t, z[1] + t, z[0] + t) } e = u + 2 * d, t = w * e; for (let e = 0; e < E; e++) { const z = y[e]; C(z[0] + t, z[1] + t, z[2] + t) } } else { for (let e = 0; e < E; e++) { var I = y[e]; C(I[2], I[1], I[0]) } for (let e = 0; e < E; e++) { var N = y[e]; C(N[0] + w * u, N[1] + w * u, N[2] + w * u) } } z.addGroup(e, O.length / 3 - e, 0); { e = O.length / 3; let i = 0; B(_, i), i += _.length; for (let e = 0, t = x.length; e < t; e++) { const z = x[e]; B(z, i), i += z.length } z.addGroup(e, O.length / 3 - e, 1) } }(i[e]); this.setAttribute("position", new G(O, 3)), this.setAttribute("uv", new G(V, 2)), this.computeVertexNormals() } toJSON() { var e = super.toJSON(), i = this.parameters.shapes, t = this.parameters.options, r = e; if (r.shapes = [], Array.isArray(i)) for (let e = 0, t = i.length; e < t; e++) { var n = i[e]; r.shapes.push(n.uuid) } else r.shapes.push(i.uuid); return void 0 !== t.extrudePath && (r.options.extrudePath = t.extrudePath.toJSON()), r } static fromJSON(i, r) { const n = []; for (let e = 0, t = i.shapes.length; e < t; e++) { var a = r[i.shapes[e]]; n.push(a) } var e = i.options.extrudePath; return void 0 !== e && (i.options.extrudePath = (new ys[e.type]).fromJSON(e)), new Us(n, i.options) } } const zs = { generateTopUV: function (e, t, i, r, n) { var a = t[3 * i], i = t[3 * i + 1], o = t[3 * r], r = t[3 * r + 1], s = t[3 * n], t = t[3 * n + 1]; return [new k(a, i), new k(o, r), new k(s, t)] }, generateSideWallUV: function (e, t, i, r, n, a) { var o = t[3 * i], s = t[3 * i + 1], i = t[3 * i + 2], l = t[3 * r], c = t[3 * r + 1], r = t[3 * r + 2], h = t[3 * n], u = t[3 * n + 1], n = t[3 * n + 2], d = t[3 * a], p = t[3 * a + 1], t = t[3 * a + 2]; return Math.abs(s - c) < Math.abs(o - l) ? [new k(o, 1 - i), new k(l, 1 - r), new k(h, 1 - n), new k(d, 1 - t)] : [new k(s, 1 - i), new k(c, 1 - r), new k(u, 1 - n), new k(p, 1 - t)] } }; class Os extends qo { constructor(e = 1, t = 0) { var i = (1 + Math.sqrt(5)) / 2; super([-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new Os(e.radius, e.detail) } } class Vs extends S { constructor(i, r = 12, n = 0, a = 2 * Math.PI) { super(), this.type = "LatheGeometry", this.parameters = { points: i, segments: r, phiStart: n, phiLength: a }, r = Math.floor(r), a = f(a, 0, 2 * Math.PI); const o = [], s = [], l = [], c = 1 / r, h = new Le, u = new k; for (let t = 0; t <= r; t++) { var e = n + t * c * a, d = Math.sin(e), p = Math.cos(e); for (let e = 0; e <= i.length - 1; e++)h.x = i[e].x * d, h.y = i[e].y, h.z = i[e].x * p, s.push(h.x, h.y, h.z), u.x = t / r, u.y = e / (i.length - 1), l.push(u.x, u.y) } for (let t = 0; t < r; t++)for (let e = 0; e < i.length - 1; e++) { const a = e + t * i.length, s = a, l = a + i.length, c = a + i.length + 1, h = a + 1; o.push(s, l, h), o.push(l, c, h) } if (this.setIndex(o), this.setAttribute("position", new G(s, 3)), this.setAttribute("uv", new G(l, 2)), this.computeVertexNormals(), a === 2 * Math.PI) { const n = this.attributes.normal.array, a = new Le, o = new Le, s = new Le, l = r * i.length * 3; for (let e = 0, t = 0; e < i.length; e++, t += 3)a.x = n[t + 0], a.y = n[t + 1], a.z = n[t + 2], o.x = n[l + t + 0], o.y = n[l + t + 1], o.z = n[l + t + 2], s.addVectors(a, o).normalize(), n[t + 0] = n[l + t + 0] = s.x, n[t + 1] = n[l + t + 1] = s.y, n[t + 2] = n[l + t + 2] = s.z } } static fromJSON(e) { return new Vs(e.points, e.segments, e.phiStart, e.phiLength) } } class ks extends qo { constructor(e = 1, t = 0) { super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new ks(e.radius, e.detail) } } class Gs extends S { constructor(t, i, r) { super(), this.type = "ParametricGeometry", this.parameters = { func: t, slices: i, stacks: r }; const n = [], a = [], o = [], s = [], l = new Le, c = new Le, h = new Le, u = new Le, d = new Le, p = (t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."), i + 1); for (let e = 0; e <= r; e++) { const p = e / r; for (let e = 0; e <= i; e++) { const n = e / i; t(n, p, c), a.push(c.x, c.y, c.z), 0 <= n - 1e-5 ? (t(n - 1e-5, p, h), u.subVectors(c, h)) : (t(1e-5 + n, p, h), u.subVectors(h, c)), 0 <= p - 1e-5 ? (t(n, p - 1e-5, h), d.subVectors(c, h)) : (t(n, 1e-5 + p, h), d.subVectors(h, c)), l.crossVectors(u, d).normalize(), o.push(l.x, l.y, l.z), s.push(n, p) } } for (let t = 0; t < r; t++)for (let e = 0; e < i; e++) { const i = t * p + e, a = t * p + e + 1, o = (t + 1) * p + e + 1, s = (t + 1) * p + e; n.push(i, a, s), n.push(a, o, s) } this.setIndex(n), this.setAttribute("position", new G(a, 3)), this.setAttribute("normal", new G(o, 3)), this.setAttribute("uv", new G(s, 2)) } } class Ws extends S { constructor(e = .5, t = 1, i = 8, r = 1, n = 0, a = 2 * Math.PI) { super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: n, thetaLength: a }, i = Math.max(3, i); const o = [], s = [], l = [], c = []; let h = e; const u = (t - e) / (r = Math.max(1, r)), d = new Le, p = new k; for (let e = 0; e <= r; e++) { for (let e = 0; e <= i; e++) { const r = n + e / i * a; d.x = h * Math.cos(r), d.y = h * Math.sin(r), s.push(d.x, d.y, d.z), l.push(0, 0, 1), p.x = (d.x / t + 1) / 2, p.y = (d.y / t + 1) / 2, c.push(p.x, p.y) } h += u } for (let e = 0; e < r; e++) { const t = e * (i + 1); for (let e = 0; e < i; e++) { const r = e + t, n = r, a = r + i + 1, s = r + i + 2, l = r + 1; o.push(n, a, l), o.push(a, s, l) } } this.setIndex(o), this.setAttribute("position", new G(s, 3)), this.setAttribute("normal", new G(l, 3)), this.setAttribute("uv", new G(c, 2)) } static fromJSON(e) { return new Ws(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength) } } class js extends S { constructor(t, o = 12) { super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: o }; const s = [], l = [], c = [], h = []; let i = 0, u = 0; if (!1 === Array.isArray(t)) r(t); else for (let e = 0; e < t.length; e++)r(t[e]), this.addGroup(i, u, e), i += u, u = 0; function r(e) { var i = l.length / 3; let r = (e = e.extractPoints(o)).shape; const n = e.holes; !1 === Ns.isClockWise(r) && (r = r.reverse()); for (let e = 0, t = n.length; e < t; e++) { const o = n[e]; !0 === Ns.isClockWise(o) && (n[e] = o.reverse()) } var a = Ns.triangulateShape(r, n); for (let e = 0, t = n.length; e < t; e++) { const o = n[e]; r = r.concat(o) } for (let e = 0, t = r.length; e < t; e++) { const o = r[e]; l.push(o.x, o.y, 0), c.push(0, 0, 1), h.push(o.x, o.y) } for (let e = 0, t = a.length; e < t; e++) { const o = a[e], l = o[0] + i, c = o[1] + i, h = o[2] + i; s.push(l, c, h), u += 3 } } this.setIndex(s), this.setAttribute("position", new G(l, 3)), this.setAttribute("normal", new G(c, 3)), this.setAttribute("uv", new G(h, 2)) } toJSON() { var e = super.toJSON(), i = this.parameters.shapes, r = e; if (r.shapes = [], Array.isArray(i)) for (let e = 0, t = i.length; e < t; e++) { var n = i[e]; r.shapes.push(n.uuid) } else r.shapes.push(i.uuid); return r } static fromJSON(i, r) { const n = []; for (let e = 0, t = i.shapes.length; e < t; e++) { var a = r[i.shapes[e]]; n.push(a) } return new js(n, i.curveSegments) } } class Xs extends S { constructor(i = 1, r = 32, n = 16, a = 0, o = 2 * Math.PI, s = 0, l = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: i, widthSegments: r, heightSegments: n, phiStart: a, phiLength: o, thetaStart: s, thetaLength: l }, r = Math.max(3, Math.floor(r)), n = Math.max(2, Math.floor(n)); const c = Math.min(s + l, Math.PI); let h = 0; const u = [], d = new Le, p = new Le, f = [], m = [], v = [], g = []; for (let e = 0; e <= n; e++) { const x = [], y = e / n; let t = 0; 0 == e && 0 == s ? t = .5 / r : e == n && c == Math.PI && (t = -.5 / r); for (let e = 0; e <= r; e++) { const c = e / r; d.x = -i * Math.cos(a + c * o) * Math.sin(s + y * l), d.y = i * Math.cos(s + y * l), d.z = i * Math.sin(a + c * o) * Math.sin(s + y * l), m.push(d.x, d.y, d.z), p.copy(d).normalize(), v.push(p.x, p.y, p.z), g.push(c + t, 1 - y), x.push(h++) } u.push(x) } for (let t = 0; t < n; t++)for (let e = 0; e < r; e++) { const r = u[t][e + 1], o = u[t][e], l = u[t + 1][e], h = u[t + 1][e + 1]; (0 !== t || 0 < s) && f.push(r, o, h), (t !== n - 1 || c < Math.PI) && f.push(o, l, h) } this.setIndex(f), this.setAttribute("position", new G(m, 3)), this.setAttribute("normal", new G(v, 3)), this.setAttribute("uv", new G(g, 2)) } static fromJSON(e) { return new Xs(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength) } } class qs extends qo { constructor(e = 1, t = 0) { super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t } } static fromJSON(e) { return new qs(e.radius, e.detail) } } class Ys extends Us { constructor(e, t = {}) { const i = t.font; if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new S; e = i.generateShapes(e, t.size), t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), super(e, t), this.type = "TextGeometry" } } class Qs extends S { constructor(i = 1, r = .4, n = 8, a = 6, o = 2 * Math.PI) { super(), this.type = "TorusGeometry", this.parameters = { radius: i, tube: r, radialSegments: n, tubularSegments: a, arc: o }, n = Math.floor(n), a = Math.floor(a); const s = [], l = [], c = [], h = [], u = new Le, d = new Le, p = new Le; for (let t = 0; t <= n; t++)for (let e = 0; e <= a; e++) { var f = e / a * o, m = t / n * Math.PI * 2; d.x = (i + r * Math.cos(m)) * Math.cos(f), d.y = (i + r * Math.cos(m)) * Math.sin(f), d.z = r * Math.sin(m), l.push(d.x, d.y, d.z), u.x = i * Math.cos(f), u.y = i * Math.sin(f), p.subVectors(d, u).normalize(), c.push(p.x, p.y, p.z), h.push(e / a), h.push(t / n) } for (let t = 1; t <= n; t++)for (let e = 1; e <= a; e++) { const n = (a + 1) * t + e - 1, o = (a + 1) * (t - 1) + e - 1, l = (a + 1) * (t - 1) + e, c = (a + 1) * t + e; s.push(n, o, c), s.push(o, l, c) } this.setIndex(s), this.setAttribute("position", new G(l, 3)), this.setAttribute("normal", new G(c, 3)), this.setAttribute("uv", new G(h, 2)) } static fromJSON(e) { return new Qs(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc) } } class Zs extends S { constructor(e = 1, i = .4, r = 64, n = 8, a = 2, o = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: i, tubularSegments: r, radialSegments: n, p: a, q: o }, r = Math.floor(r), n = Math.floor(n); const s = [], l = [], c = [], h = [], u = new Le, d = new Le, p = new Le, f = new Le, m = new Le, v = new Le, g = new Le; for (let t = 0; t <= r; ++t) { var x = t / r * a * Math.PI * 2; y(x, a, o, e, p), y(.01 + x, a, o, e, f), v.subVectors(f, p), g.addVectors(f, p), m.crossVectors(v, g), g.crossVectors(m, v), m.normalize(), g.normalize(); for (let e = 0; e <= n; ++e) { const a = e / n * Math.PI * 2, o = -i * Math.cos(a), f = i * Math.sin(a); u.x = p.x + (o * g.x + f * m.x), u.y = p.y + (o * g.y + f * m.y), u.z = p.z + (o * g.z + f * m.z), l.push(u.x, u.y, u.z), d.subVectors(u, p).normalize(), c.push(d.x, d.y, d.z), h.push(t / r), h.push(e / n) } } for (let t = 1; t <= r; t++)for (let e = 1; e <= n; e++) { const r = (n + 1) * (t - 1) + (e - 1), a = (n + 1) * t + (e - 1), o = (n + 1) * t + e, l = (n + 1) * (t - 1) + e; s.push(r, a, l), s.push(a, o, l) } function y(e, t, i, r, n) { var a = Math.cos(e), o = Math.sin(e), i = i / t * e, t = Math.cos(i); n.x = r * (2 + t) * .5 * a, n.y = r * (2 + t) * o * .5, n.z = r * Math.sin(i) * .5 } this.setIndex(s), this.setAttribute("position", new G(l, 3)), this.setAttribute("normal", new G(c, 3)), this.setAttribute("uv", new G(h, 2)) } static fromJSON(e) { return new Zs(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q) } } class Js extends S { constructor(e, n = 64, a = 1, o = 8, t = !1) { super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: n, radius: a, radialSegments: o, closed: t }; const s = e.computeFrenetFrames(n, t), l = (this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, new Le), c = new Le, i = new k; let h = new Le; const u = [], d = [], r = [], p = []; function f(t) { h = e.getPointAt(t / n, h); var i = s.normals[t], r = s.binormals[t]; for (let e = 0; e <= o; e++) { const n = e / o * Math.PI * 2, t = Math.sin(n), s = -Math.cos(n); c.x = s * i.x + t * r.x, c.y = s * i.y + t * r.y, c.z = s * i.z + t * r.z, c.normalize(), d.push(c.x, c.y, c.z), l.x = h.x + a * c.x, l.y = h.y + a * c.y, l.z = h.z + a * c.z, u.push(l.x, l.y, l.z) } } for (let e = 0; e < n; e++)f(e); f(!1 === t ? n : 0); for (let t = 0; t <= n; t++)for (let e = 0; e <= o; e++)i.x = t / n, i.y = e / o, r.push(i.x, i.y); for (let t = 1; t <= n; t++)for (let e = 1; e <= o; e++) { var m = (o + 1) * (t - 1) + (e - 1), v = (o + 1) * t + (e - 1), g = (o + 1) * t + e, x = (o + 1) * (t - 1) + e; p.push(m, v, x), p.push(v, g, x) } this.setIndex(p), this.setAttribute("position", new G(u, 3)), this.setAttribute("normal", new G(d, 3)), this.setAttribute("uv", new G(r, 2)) } toJSON() { const e = super.toJSON(); return e.path = this.parameters.path.toJSON(), e } static fromJSON(e) { return new Js((new ys[e.path.type]).fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed) } } class Ks extends S { constructor(e) { if (super(), this.type = "WireframeGeometry", !0 === e.isGeometry) console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."); else { const c = [], h = new Set, u = new Le, d = new Le; if (null !== e.index) { const p = e.attributes.position, f = e.index; let i = e.groups; for (let e = 0, t = (i = 0 === i.length ? [{ start: 0, count: f.count, materialIndex: 0 }] : i).length; e < t; ++e) { var r = i[e], n = r.start; for (let t = n, e = n + r.count; t < e; t += 3)for (let e = 0; e < 3; e++) { var a = f.getX(t + e), o = f.getX(t + (e + 1) % 3); u.fromBufferAttribute(p, a), d.fromBufferAttribute(p, o), !0 === $s(u, d, h) && (c.push(u.x, u.y, u.z), c.push(d.x, d.y, d.z)) } } } else { var i = e.attributes.position; for (let t = 0, e = i.count / 3; t < e; t++)for (let e = 0; e < 3; e++) { var s = 3 * t + e, l = 3 * t + (e + 1) % 3; u.fromBufferAttribute(i, s), d.fromBufferAttribute(i, l), !0 === $s(u, d, h) && (c.push(u.x, u.y, u.z), c.push(d.x, d.y, d.z)) } } this.setAttribute("position", new G(c, 3)) } } } function $s(e, t, i) { var r = `${e.x},${e.y},${e.z}-${t.x},${t.y},` + t.z, t = `${t.x},${t.y},${t.z}-${e.x},${e.y},` + e.z; return !0 !== i.has(r) && !0 !== i.has(t) && (i.add(r, t), !0) } var el = Object.freeze({ __proto__: null, BoxGeometry: zi, BoxBufferGeometry: zi, CircleGeometry: Wo, CircleBufferGeometry: Wo, ConeGeometry: Xo, ConeBufferGeometry: Xo, CylinderGeometry: jo, CylinderBufferGeometry: jo, DodecahedronGeometry: Yo, DodecahedronBufferGeometry: Yo, EdgesGeometry: $o, ExtrudeGeometry: Us, ExtrudeBufferGeometry: Us, IcosahedronGeometry: Os, IcosahedronBufferGeometry: Os, LatheGeometry: Vs, LatheBufferGeometry: Vs, OctahedronGeometry: ks, OctahedronBufferGeometry: ks, ParametricGeometry: Gs, ParametricBufferGeometry: Gs, PlaneGeometry: ir, PlaneBufferGeometry: ir, PolyhedronGeometry: qo, PolyhedronBufferGeometry: qo, RingGeometry: Ws, RingBufferGeometry: Ws, ShapeGeometry: js, ShapeBufferGeometry: js, SphereGeometry: Xs, SphereBufferGeometry: Xs, TetrahedronGeometry: qs, TetrahedronBufferGeometry: qs, TextGeometry: Ys, TextBufferGeometry: Ys, TorusGeometry: Qs, TorusBufferGeometry: Qs, TorusKnotGeometry: Zs, TorusKnotBufferGeometry: Zs, TubeGeometry: Js, TubeBufferGeometry: Js, WireframeGeometry: Ks }); class tl extends t { constructor(e) { super(), this.type = "ShadowMaterial", this.color = new y(0), this.transparent = !0, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this } } class il extends t { constructor(e) { super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new y(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this } } il.prototype.isMeshStandardMaterial = tl.prototype.isShadowMaterial = !0; class rl extends il { constructor(e) { super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new k(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", { get: function () { return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity) }, set: function (e) { this.reflectivity = f(2.5 * (e - 1) / (e + 1), 0, 1) } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.thickness = .01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationTint = new y(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularTint = new y(1, 1, 1), this.specularTintMap = null, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.reflectivity = e.reflectivity, e.sheen ? this.sheen = (this.sheen || new y).copy(e.sheen) : this.sheen = null, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationTint.copy(e.attenuationTint), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularTint.copy(e.specularTint), this.specularTintMap = e.specularTintMap, this } } class nl extends t { constructor(e) { super(), this.type = "MeshPhongMaterial", this.color = new y(16777215), this.specular = new y(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this } } class al extends t { constructor(e) { super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new y(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } class ol extends t { constructor(e) { super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this } } class sl extends t { constructor(e) { super(), this.type = "MeshLambertMaterial", this.color = new y(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new y(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(e) } copy(e) { return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this } } class ll extends t { constructor(e) { super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new y(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new k(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(e) } copy(e) { return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this } } class cl extends v { constructor(e) { super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } copy(e) { return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this } } cl.prototype.isLineDashedMaterial = ll.prototype.isMeshMatcapMaterial = sl.prototype.isMeshLambertMaterial = ol.prototype.isMeshNormalMaterial = al.prototype.isMeshToonMaterial = nl.prototype.isMeshPhongMaterial = rl.prototype.isMeshPhysicalMaterial = !0; var hl = Object.freeze({ __proto__: null, ShadowMaterial: tl, SpriteMaterial: Va, RawShaderMaterial: ur, ShaderMaterial: ki, PointsMaterial: Do, MeshPhysicalMaterial: rl, MeshStandardMaterial: il, MeshPhongMaterial: nl, MeshToonMaterial: al, MeshNormalMaterial: ol, MeshLambertMaterial: sl, MeshDepthMaterial: Ea, MeshDistanceMaterial: Ta, MeshBasicMaterial: ti, MeshMatcapMaterial: ll, LineDashedMaterial: cl, LineBasicMaterial: v, Material: t }); const b = { arraySlice: function (e, t, i) { return b.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i) }, convertArray: function (e, t, i) { return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function (e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function (i) { const t = i.length, r = new Array(t); for (let e = 0; e !== t; ++e)r[e] = e; return r.sort(function (e, t) { return i[e] - i[t] }), r }, sortedArray: function (i, r, n) { const a = i.length, o = new i.constructor(a); for (let e = 0, t = 0; t !== a; ++e) { const a = n[e] * r; for (let e = 0; e !== r; ++e)o[t++] = i[a + e] } return o }, flattenJSON: function (t, i, r, n) { let a = 1, o = t[0]; for (; void 0 !== o && void 0 === o[n];)o = t[a++]; if (void 0 !== o) { let e = o[n]; if (void 0 !== e) if (Array.isArray(e)) for (; void 0 !== (e = o[n]) && (i.push(o.time), r.push.apply(r, e)), void 0 !== (o = t[a++]);); else if (void 0 !== e.toArray) for (; void 0 !== (e = o[n]) && (i.push(o.time), e.toArray(r, r.length)), void 0 !== (o = t[a++]);); else for (; void 0 !== (e = o[n]) && (i.push(o.time), r.push(e)), void 0 !== (o = t[a++]);); } }, subclip: function (e, i, r, n, a = 30) { const o = e.clone(), t = (o.name = i, []); for (let e = 0; e < o.tracks.length; ++e) { const i = o.tracks[e], s = i.getValueSize(), l = [], c = []; for (let t = 0; t < i.times.length; ++t) { const o = i.times[t] * a; if (!(o < r || o >= n)) { l.push(i.times[t]); for (let e = 0; e < s; ++e)c.push(i.values[t * s + e]) } } 0 !== l.length && (i.times = b.convertArray(l, i.times.constructor), i.values = b.convertArray(c, i.values.constructor), t.push(i)) } o.tracks = t; let s = 1 / 0; for (let e = 0; e < o.tracks.length; ++e)s > o.tracks[e].times[0] && (s = o.tracks[e].times[0]); for (let e = 0; e < o.tracks.length; ++e)o.tracks[e].shift(-1 * s); return o.resetDuration(), o }, makeClipAdditive: function (r, n = 0, a = r, o = 30) { const s = a.tracks.length, l = n / (o = o <= 0 ? 30 : o); for (let e = 0; e < s; ++e) { const o = a.tracks[e], s = o.ValueTypeName; if ("bool" !== s && "string" !== s) { const p = r.tracks.find(function (e) { return e.name === o.name && e.ValueTypeName === s }); if (void 0 !== p) { let e = 0; var c = o.getValueSize(); o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (e = c / 3); let t = 0; var h = p.getValueSize(), u = (p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (t = h / 3), o.times.length - 1); let i; if (l <= o.times[0]) { const r = e, n = c - e; i = b.arraySlice(o.values, r, n) } else if (l >= o.times[u]) { const r = u * c + e, n = r + c - e; i = b.arraySlice(o.values, r, n) } else { const r = o.createInterpolant(), n = e, a = c - e; r.evaluate(l), i = b.arraySlice(r.resultBuffer, n, a) } "quaternion" === s && (new m).fromArray(i).normalize().conjugate().toArray(i); var d = p.times.length; for (let e = 0; e < d; ++e) { const n = e * h + t; if ("quaternion" === s) m.multiplyQuaternionsFlat(p.values, n, i, 0, p.values, n); else { const r = h - 2 * t; for (let e = 0; e < r; ++e)p.values[n + e] -= i[e] } } } } } return r.blendMode = 2501, r } }; class ul { constructor(e, t, i, r) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {} } evaluate(t) { var i = this.parameterPositions; let r = this._cachedIndex, n = i[r], a = i[r - 1]; e: { t: { let e; i: { r: if (!(t < n)) { for (var o = r + 2; ;) { if (void 0 === n) { if (t < a) break r; return r = i.length, this._cachedIndex = r, this.afterEnd_(r - 1, t, a) } if (r === o) break; if (a = n, t < (n = i[++r])) break t } e = i.length; break i } if (t >= a) break e; var s = i[1]; t < s && (r = 2, a = s); for (var l = r - 2; ;) { if (void 0 === a) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (r === l) break; if (n = a, t >= (a = i[--r - 1])) break t } e = r, r = 0 } for (; r < e;) { const n = r + e >>> 1; t < i[n] ? e = n : r = 1 + n } if (n = i[r], void 0 === (a = i[r - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (void 0 === n) return r = i.length, this._cachedIndex = r, this.afterEnd_(r - 1, a, t) } this._cachedIndex = r, this.intervalChanged_(r, a, n) } return this.interpolate_(r, a, t, n) } getSettings_() { return this.settings || this.DefaultSettings_ } copySampleValue_(e) { const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = e * r; for (let e = 0; e !== r; ++e)t[e] = i[n + e]; return t } interpolate_() { throw new Error("call to abstract method") } intervalChanged_() { } } ul.prototype.beforeStart_ = ul.prototype.copySampleValue_, ul.prototype.afterEnd_ = ul.prototype.copySampleValue_; class dl extends ul { constructor(e, t, i, r) { super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 } } intervalChanged_(e, t, i) { var r = this.parameterPositions; let n = e - 2, a = e + 1, o = r[n], s = r[a]; if (void 0 === o) switch (this.getSettings_().endingStart) { case 2401: n = e, o = 2 * t - i; break; case 2402: n = r.length - 2, o = t + r[n] - r[n + 1]; break; default: n = e, o = i }if (void 0 === s) switch (this.getSettings_().endingEnd) { case 2401: a = e, s = 2 * i - t; break; case 2402: a = 1, s = i + r[1] - r[0]; break; default: a = e - 1, s = t }var l = .5 * (i - t), c = this.valueSize; this._weightPrev = l / (t - o), this._weightNext = l / (s - i), this._offsetPrev = n * c, this._offsetNext = a * c } interpolate_(e, t, i, r) { const n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (i - t) / (r - t), f = p * p, m = f * p, v = -u * m + 2 * u * f - u * p, g = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, x = (-1 - d) * m + (1.5 + d) * f + .5 * p, y = d * m - d * f; for (let e = 0; e !== o; ++e)n[e] = v * a[c + e] + g * a[l + e] + x * a[s + e] + y * a[h + e]; return n } } class pl extends ul { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e, t, i, r) { const n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (i - t) / (r - t), h = 1 - c; for (let e = 0; e !== o; ++e)n[e] = a[l + e] * h + a[s + e] * c; return n } } class fl extends ul { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e) { return this.copySampleValue_(e - 1) } } class ml { constructor(e, t, i, r) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = b.convertArray(t, this.TimeBufferType), this.values = b.convertArray(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON(e) { const t = e.constructor; let i; if (t.toJSON !== this.toJSON) i = t.toJSON(e); else { i = { name: e.name, times: b.convertArray(e.times, Array), values: b.convertArray(e.values, Array) }; const t = e.getInterpolation(); t !== e.DefaultInterpolation && (i.interpolation = t) } return i.type = e.ValueTypeName, i } InterpolantFactoryMethodDiscrete(e) { return new fl(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodLinear(e) { return new pl(this.times, this.values, this.getValueSize(), e) } InterpolantFactoryMethodSmooth(e) { return new dl(this.times, this.values, this.getValueSize(), e) } setInterpolation(e) { let t; switch (e) { case 2300: t = this.InterpolantFactoryMethodDiscrete; break; case 2301: t = this.InterpolantFactoryMethodLinear; break; case 2302: t = this.InterpolantFactoryMethodSmooth }if (void 0 !== t) return this.createInterpolant = t, this; { const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(t); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", t), this } } getInterpolation() { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } } getValueSize() { return this.values.length / this.times.length } shift(i) { if (0 !== i) { const r = this.times; for (let e = 0, t = r.length; e !== t; ++e)r[e] += i } return this } scale(i) { if (1 !== i) { const r = this.times; for (let e = 0, t = r.length; e !== t; ++e)r[e] *= i } return this } trim(e, t) { var i = this.times, r = i.length; let n = 0, a = r - 1; for (; n !== r && i[n] < e;)++n; for (; -1 !== a && i[a] > t;)--a; if (++a, 0 !== n || a !== r) { n >= a && (a = Math.max(a, 1), n = a - 1); const e = this.getValueSize(); this.times = b.arraySlice(i, n, a), this.values = b.arraySlice(this.values, n * e, a * e) } return this } validate() { let i = !0; var e = this.getValueSize(); e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), i = !1); const r = this.times, n = this.values, t = r.length; 0 === t && (console.error("THREE.KeyframeTrack: Track is empty.", this), i = !1); let a = null; for (let e = 0; e !== t; e++) { const n = r[e]; if ("number" == typeof n && isNaN(n)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, n), i = !1; break } if (null !== a && a > n) { console.error("THREE.KeyframeTrack: Out of order keys.", this, e, n, a), i = !1; break } a = n } if (void 0 !== n && b.isTypedArray(n)) for (let e = 0, t = n.length; e !== t; ++e) { const r = n[e]; if (isNaN(r)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, r), i = !1; break } } return i } optimize() { const i = b.arraySlice(this.times), r = b.arraySlice(this.values), n = this.getValueSize(), a = 2302 === this.getInterpolation(), o = i.length - 1; let s = 1; for (let e = 1; e < o; ++e) { let t = !1; var l = i[e]; if (l !== i[e + 1] && (1 !== e || l !== i[0])) if (a) t = !0; else { const i = e * n, a = i - n, s = i + n; for (let e = 0; e !== n; ++e) { const n = r[i + e]; if (n !== r[a + e] || n !== r[s + e]) { t = !0; break } } } if (t) { if (e !== s) { i[s] = i[e]; const a = e * n, o = s * n; for (let e = 0; e !== n; ++e)r[o + e] = r[a + e] } ++s } } if (0 < o) { i[s] = i[o]; for (let e = o * n, t = s * n, i = 0; i !== n; ++i)r[t + i] = r[e + i]; ++s } return s !== i.length ? (this.times = b.arraySlice(i, 0, s), this.values = b.arraySlice(r, 0, s * n)) : (this.times = i, this.values = r), this } clone() { const e = b.arraySlice(this.times, 0), t = b.arraySlice(this.values, 0), i = new this.constructor(this.name, e, t); return i.createInterpolant = this.createInterpolant, i } } ml.prototype.TimeBufferType = Float32Array, ml.prototype.ValueBufferType = Float32Array, ml.prototype.DefaultInterpolation = 2301; class vl extends ml { } vl.prototype.ValueTypeName = "bool", vl.prototype.ValueBufferType = Array, vl.prototype.DefaultInterpolation = 2300, vl.prototype.InterpolantFactoryMethodLinear = void 0, vl.prototype.InterpolantFactoryMethodSmooth = void 0; class gl extends ml { } gl.prototype.ValueTypeName = "color"; class xl extends ml { } xl.prototype.ValueTypeName = "number"; class yl extends ul { constructor(e, t, i, r) { super(e, t, i, r) } interpolate_(e, t, i, r) { var n = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (i - t) / (r - t); let l = e * o; for (var c = l + o; l !== c; l += 4)m.slerpFlat(n, 0, a, l - o, a, l, s); return n } } class _l extends ml { InterpolantFactoryMethodLinear(e) { return new yl(this.times, this.values, this.getValueSize(), e) } } _l.prototype.ValueTypeName = "quaternion", _l.prototype.DefaultInterpolation = 2301, _l.prototype.InterpolantFactoryMethodSmooth = void 0; class bl extends ml { } bl.prototype.ValueTypeName = "string", bl.prototype.ValueBufferType = Array, bl.prototype.DefaultInterpolation = 2300, bl.prototype.InterpolantFactoryMethodLinear = void 0, bl.prototype.InterpolantFactoryMethodSmooth = void 0; class wl extends ml { } class El { constructor(e, t = -1, i, r = 2500) { this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = pe(), this.duration < 0 && this.resetDuration() } static parse(e) { const i = [], r = e.tracks, n = 1 / (e.fps || 1); for (let e = 0, t = r.length; e !== t; ++e)i.push(function (e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); const t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return xl; case "vector": case "vector2": case "vector3": case "vector4": return wl; case "color": return gl; case "quaternion": return _l; case "bool": case "boolean": return vl; case "string": return bl }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { const t = [], i = []; b.flattenJSON(e.keys, t, i, "value"), e.times = t, e.values = i } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) }(r[e]).scale(n)); const t = new this(e.name, e.duration, i, e.blendMode); return t.uuid = e.uuid, t } static toJSON(e) { const i = [], r = e.tracks, t = { name: e.name, duration: e.duration, tracks: i, uuid: e.uuid, blendMode: e.blendMode }; for (let e = 0, t = r.length; e !== t; ++e)i.push(ml.toJSON(r[e])); return t } static CreateFromMorphTargetSequence(e, r, n, a) { const o = r.length, s = []; for (let i = 0; i < o; i++) { let e = [], t = []; e.push((i + o - 1) % o, i, (i + 1) % o), t.push(0, 1, 0); var l = b.getKeyframeOrder(e); e = b.sortedArray(e, 1, l), t = b.sortedArray(t, 1, l), a || 0 !== e[0] || (e.push(o), t.push(t[0])), s.push(new xl(".morphTargetInfluences[" + r[i].name + "]", e, t).scale(1 / n)) } return new this(e, -1, s) } static findByName(e, t) { let i = e; if (!Array.isArray(e)) { const t = e; i = t.geometry && t.geometry.animations || t.animations } for (let e = 0; e < i.length; e++)if (i[e].name === t) return i[e]; return null } static CreateClipsFromMorphTargetSequences(i, e, r) { const n = {}, a = /^([\w-]*?)([\d]+)$/; for (let e = 0, t = i.length; e < t; e++) { const r = i[e], o = r.name.match(a); if (o && 1 < o.length) { const i = o[1]; let e = n[i]; e || (n[i] = e = []), e.push(r) } } const o = []; for (const i in n) o.push(this.CreateFromMorphTargetSequence(i, n[i], e, r)); return o } static parseAnimation(i, t) { if (!i) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; const r = function (e, t, i, r, n) { var a, o; 0 !== i.length && (a = [], o = [], b.flattenJSON(i, a, o, r), 0 !== a.length && n.push(new e(t, a, o))) }, n = [], a = i.name || "default", o = i.fps || 30, e = i.blendMode; let s = i.length || -1; var l = i.hierarchy || []; for (let e = 0; e < l.length; e++) { const a = l[e].keys; if (a && 0 !== a.length) if (a[0].morphTargets) { const i = {}; let t; for (t = 0; t < a.length; t++)if (a[t].morphTargets) for (let e = 0; e < a[t].morphTargets.length; e++)i[a[t].morphTargets[e]] = -1; for (const r in i) { const i = [], o = []; for (let e = 0; e !== a[t].morphTargets.length; ++e) { const n = a[t]; i.push(n.time), o.push(n.morphTarget === r ? 1 : 0) } n.push(new xl(".morphTargetInfluence[" + r + "]", i, o)) } s = i.length * (o || 1) } else { const o = ".bones[" + t[e].name + "]"; r(wl, o + ".position", a, "pos", n), r(_l, o + ".quaternion", a, "rot", n), r(wl, o + ".scale", a, "scl", n) } } return 0 === n.length ? null : new this(a, s, n, e) } resetDuration() { let i = 0; for (let e = 0, t = this.tracks.length; e !== t; ++e) { var r = this.tracks[e]; i = Math.max(i, r.times[r.times.length - 1]) } return this.duration = i, this } trim() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this } validate() { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t } optimize() { for (let e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this } clone() { const t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new this.constructor(this.name, this.duration, t, this.blendMode) } toJSON() { return this.constructor.toJSON(this) } } const Tl = { enabled: !(wl.prototype.ValueTypeName = "vector"), files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; class Sl { constructor(e, t, i) { const r = this; let n, a = !1, o = 0, s = 0; const l = []; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) { s++, !1 === a && void 0 !== r.onStart && r.onStart(e, o, s), a = !0 }, this.itemEnd = function (e) { o++, void 0 !== r.onProgress && r.onProgress(e, o, s), o === s && (a = !1, void 0 !== r.onLoad && r.onLoad()) }, this.itemError = function (e) { void 0 !== r.onError && r.onError(e) }, this.resolveURL = function (e) { return n ? n(e) : e }, this.setURLModifier = function (e) { return n = e, this }, this.addHandler = function (e, t) { return l.push(e, t), this }, this.removeHandler = function (e) { return -1 !== (e = l.indexOf(e)) && l.splice(e, 2), this }, this.getHandler = function (i) { for (let e = 0, t = l.length; e < t; e += 2) { const r = l[e], n = l[e + 1]; if (r.global && (r.lastIndex = 0), r.test(i)) return n } return null } } } const Ml = new Sl; class l { constructor(e) { this.manager = void 0 !== e ? e : Ml, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load() { } loadAsync(i, r) { const n = this; return new Promise(function (e, t) { n.load(i, e, r, t) }) } parse() { } setCrossOrigin(e) { return this.crossOrigin = e, this } setWithCredentials(e) { return this.withCredentials = e, this } setPath(e) { return this.path = e, this } setResourcePath(e) { return this.resourcePath = e, this } setRequestHeader(e) { return this.requestHeader = e, this } } const Al = {}; class Rl extends l { constructor(e) { super(e) } load(a, i, r, n) { void 0 === a && (a = ""), void 0 !== this.path && (a = this.path + a), a = this.manager.resolveURL(a); const o = this, s = Tl.get(a); if (void 0 !== s) return o.manager.itemStart(a), setTimeout(function () { i && i(s), o.manager.itemEnd(a) }, 0), s; if (void 0 === Al[a]) { var l = a.match(/^data:(.*?)(;base64)?,(.*)$/); let e; if (l) { const r = l[1], s = !!l[2]; let t = l[3]; t = decodeURIComponent(t), s && (t = atob(t)); try { let e; const s = (this.responseType || "").toLowerCase(); switch (s) { case "arraybuffer": case "blob": const a = new Uint8Array(t.length); for (let e = 0; e < t.length; e++)a[e] = t.charCodeAt(e); e = "blob" === s ? new Blob([a.buffer], { type: r }) : a.buffer; break; case "document": const i = new DOMParser; e = i.parseFromString(t, r); break; case "json": e = JSON.parse(t); break; default: e = t }setTimeout(function () { i && i(e), o.manager.itemEnd(a) }, 0) } catch (i) { setTimeout(function () { n && n(i), o.manager.itemError(a), o.manager.itemEnd(a) }, 0) } } else { Al[a] = [], Al[a].push({ onLoad: i, onProgress: r, onError: n }), (e = new XMLHttpRequest).open("GET", a, !0), e.addEventListener("load", function (i) { const r = this.response, n = Al[a]; if (delete Al[a], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Tl.add(a, r); for (let e = 0, t = n.length; e < t; e++) { const i = n[e]; i.onLoad && i.onLoad(r) } o.manager.itemEnd(a) } else { for (let e = 0, t = n.length; e < t; e++) { const r = n[e]; r.onError && r.onError(i) } o.manager.itemError(a), o.manager.itemEnd(a) } }, !1), e.addEventListener("progress", function (i) { var r = Al[a]; for (let e = 0, t = r.length; e < t; e++) { const n = r[e]; n.onProgress && n.onProgress(i) } }, !1), e.addEventListener("error", function (i) { var r = Al[a]; delete Al[a]; for (let e = 0, t = r.length; e < t; e++) { const n = r[e]; n.onError && n.onError(i) } o.manager.itemError(a), o.manager.itemEnd(a) }, !1), e.addEventListener("abort", function (i) { var r = Al[a]; delete Al[a]; for (let e = 0, t = r.length; e < t; e++) { const n = r[e]; n.onError && n.onError(i) } o.manager.itemError(a), o.manager.itemEnd(a) }, !1), void 0 !== this.responseType && (e.responseType = this.responseType), void 0 !== this.withCredentials && (e.withCredentials = this.withCredentials), e.overrideMimeType && e.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"); for (const a in this.requestHeader) e.setRequestHeader(a, this.requestHeader[a]); e.send(null) } return o.manager.itemStart(a), e } Al[a].push({ onLoad: i, onProgress: r, onError: n }) } setResponseType(e) { return this.responseType = e, this } setMimeType(e) { return this.mimeType = e, this } } class Ll extends l { constructor(e) { super(e) } load(t, e, i, r) { void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const n = this, a = Tl.get(t); if (void 0 !== a) return n.manager.itemStart(t), setTimeout(function () { e && e(a), n.manager.itemEnd(t) }, 0), a; const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function s() { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), Tl.add(t, this), e && e(this), n.manager.itemEnd(t) } function l(e) { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), r && r(e), n.manager.itemError(t), n.manager.itemEnd(t) } return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), n.manager.itemStart(t), o.src = t, o } } class Pl extends l { constructor(e) { super(e) } load(i, r, e, n) { const a = new ji, o = new Ll(this.manager); o.setCrossOrigin(this.crossOrigin), o.setPath(this.path); let s = 0; for (let e = 0; e < i.length; ++e)!function (t) { o.load(i[t], function (e) { a.images[t] = e, 6 == ++s && (a.needsUpdate = !0, r && r(a)) }, void 0, n) }(e); return a } } class Cl extends l { constructor(e) { super(e) } load(e, t, i, r) { const n = this, a = new fo, o = new Rl(this.manager); return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(n.withCredentials), o.load(e, function (e) { (e = n.parse(e)) && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width, a.image.height = e.height, a.image.data = e.data), a.wrapS = void 0 !== e.wrapS ? e.wrapS : Ce, a.wrapT = void 0 !== e.wrapT ? e.wrapT : Ce, a.magFilter = void 0 !== e.magFilter ? e.magFilter : U, a.minFilter = void 0 !== e.minFilter ? e.minFilter : U, a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1, void 0 !== e.encoding && (a.encoding = e.encoding), void 0 !== e.flipY && (a.flipY = e.flipY), void 0 !== e.format && (a.format = e.format), void 0 !== e.type && (a.type = e.type), void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps, a.minFilter = Fe), 1 === e.mipmapCount && (a.minFilter = U), void 0 !== e.generateMipmaps && (a.generateMipmaps = e.generateMipmaps), a.needsUpdate = !0, t && t(a, e)) }, i, r), a } } class Fl extends l { constructor(e) { super(e) } load(t, i, e, r) { const n = new h, a = new Ll(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function (e) { n.image = e, e = 0 < t.search(/\.jpe?g($|\?)/i) || 0 === t.search(/^data\:image\/jpeg/), n.format = e ? Z : He, n.needsUpdate = !0, void 0 !== i && i(n) }, e, r), n } } class Dl extends es { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add(e) { this.curves.push(e) } closePath() { const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new fs(t, e)) } getPoint(e) { var t = e * this.getLength(), i = this.getCurveLengths(); let r = 0; for (; r < i.length;) { if (i[r] >= t) { const e = i[r] - t, n = this.curves[r], a = n.getLength(), o = 0 === a ? 0 : 1 - e / a; return n.getPointAt(o) } r++ } return null } getLength() { var e = this.getCurveLengths(); return e[e.length - 1] } updateArcLengths() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; const i = []; let r = 0; for (let e = 0, t = this.curves.length; e < t; e++)r += this.curves[e].getLength(), i.push(r); return this.cacheLengths = i } getSpacedPoints(t = 40) { const i = []; for (let e = 0; e <= t; e++)i.push(this.getPoint(e / t)); return this.autoClose && i.push(i[0]), i } getPoints(i = 12) { const r = []; let n; for (let e = 0, t = this.curves; e < t.length; e++) { const o = t[e], s = o && o.isEllipseCurve ? 2 * i : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? i * o.points.length : i, l = o.getPoints(s); for (let e = 0; e < l.length; e++) { var a = l[e]; n && n.equals(a) || (r.push(a), n = a) } } return this.autoClose && 1 < r.length && !r[r.length - 1].equals(r[0]) && r.push(r[0]), r } copy(i) { super.copy(i), this.curves = []; for (let e = 0, t = i.curves.length; e < t; e++) { const r = i.curves[e]; this.curves.push(r.clone()) } return this.autoClose = i.autoClose, this } toJSON() { const i = super.toJSON(); i.autoClose = this.autoClose, i.curves = []; for (let e = 0, t = this.curves.length; e < t; e++) { const r = this.curves[e]; i.curves.push(r.toJSON()) } return i } fromJSON(i) { super.fromJSON(i), this.autoClose = i.autoClose, this.curves = []; for (let e = 0, t = i.curves.length; e < t; e++) { var r = i.curves[e]; this.curves.push((new ys[r.type]).fromJSON(r)) } return this } } class Il extends Dl { constructor(e) { super(), this.type = "Path", this.currentPoint = new k, e && this.setFromPoints(e) } setFromPoints(i) { this.moveTo(i[0].x, i[0].y); for (let e = 1, t = i.length; e < t; e++)this.lineTo(i[e].x, i[e].y); return this } moveTo(e, t) { return this.currentPoint.set(e, t), this } lineTo(e, t) { var i = new fs(this.currentPoint.clone(), new k(e, t)); return this.curves.push(i), this.currentPoint.set(e, t), this } quadraticCurveTo(e, t, i, r) { return e = new vs(this.currentPoint.clone(), new k(e, t), new k(i, r)), this.curves.push(e), this.currentPoint.set(i, r), this } bezierCurveTo(e, t, i, r, n, a) { return e = new ds(this.currentPoint.clone(), new k(e, t), new k(i, r), new k(n, a)), this.curves.push(e), this.currentPoint.set(n, a), this } splineThru(e) { var t = [this.currentPoint.clone()].concat(e), t = new xs(t); return this.curves.push(t), this.currentPoint.copy(e[e.length - 1]), this } arc(e, t, i, r, n, a) { var o = this.currentPoint.x, s = this.currentPoint.y; return this.absarc(e + o, t + s, i, r, n, a), this } absarc(e, t, i, r, n, a) { return this.absellipse(e, t, i, i, r, n, a), this } ellipse(e, t, i, r, n, a, o, s) { var l = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(e + l, t + c, i, r, n, a, o, s), this } absellipse(e, t, i, r, n, a, o, s) { const l = new ts(e, t, i, r, n, a, o, s); if (0 < this.curves.length) { const e = l.getPoint(0); e.equals(this.currentPoint) || this.lineTo(e.x, e.y) } return this.curves.push(l), e = l.getPoint(1), this.currentPoint.copy(e), this } copy(e) { return super.copy(e), this.currentPoint.copy(e.currentPoint), this } toJSON() { const e = super.toJSON(); return e.currentPoint = this.currentPoint.toArray(), e } fromJSON(e) { return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this } } class Nl extends Il { constructor(e) { super(e), this.uuid = pe(), this.type = "Shape", this.holes = [] } getPointsHoles(i) { const r = []; for (let e = 0, t = this.holes.length; e < t; e++)r[e] = this.holes[e].getPoints(i); return r } extractPoints(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } } copy(i) { super.copy(i), this.holes = []; for (let e = 0, t = i.holes.length; e < t; e++) { const r = i.holes[e]; this.holes.push(r.clone()) } return this } toJSON() { const i = super.toJSON(); i.uuid = this.uuid, i.holes = []; for (let e = 0, t = this.holes.length; e < t; e++) { const r = this.holes[e]; i.holes.push(r.toJSON()) } return i } fromJSON(i) { super.fromJSON(i), this.uuid = i.uuid, this.holes = []; for (let e = 0, t = i.holes.length; e < t; e++) { var r = i.holes[e]; this.holes.push((new Il).fromJSON(r)) } return this } } class Hl extends u { constructor(e, t = 1) { super(), this.type = "Light", this.color = new y(e), this.intensity = t } dispose() { } copy(e) { return super.copy(e), this.color.copy(e.color), this.intensity = e.intensity, this } toJSON(e) { const t = super.toJSON(e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } } Hl.prototype.isLight = !0; class Bl extends Hl { constructor(e, t, i) { super(e, i), this.type = "HemisphereLight", this.position.copy(u.DefaultUp), this.updateMatrix(), this.groundColor = new y(t) } copy(e) { return Hl.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } } Bl.prototype.isHemisphereLight = !0; const Ul = new Pe, zl = new Le, Ol = new Le; class Vl { constructor(e) { this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new k(512, 512), this.map = null, this.mapPass = null, this.matrix = new Pe, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new $i, this._frameExtents = new k(1, 1), this._viewportCount = 1, this._viewports = [new Re(0, 0, 1, 1)] } getViewportCount() { return this._viewportCount } getFrustum() { return this._frustum } updateMatrices(e) { const t = this.camera, i = this.matrix; zl.setFromMatrixPosition(e.matrixWorld), t.position.copy(zl), Ol.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Ol), t.updateMatrixWorld(), Ul.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ul), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(t.projectionMatrix), i.multiply(t.matrixWorldInverse) } getViewport(e) { return this._viewports[e] } getFrameExtents() { return this._frameExtents } dispose() { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = {}; return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } } class kl extends Vl { constructor() { super(new C(50, 1, .5, 500)), this.focus = 1 } updateMatrices(e) { const t = this.camera, i = 2 * de * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, n = e.distance || t.far; i === t.fov && r === t.aspect && n === t.far || (t.fov = i, t.aspect = r, t.far = n, t.updateProjectionMatrix()), super.updateMatrices(e) } copy(e) { return super.copy(e), this.focus = e.focus, this } } kl.prototype.isSpotLightShadow = !0; class Gl extends Hl { constructor(e, t, i = 0, r = Math.PI / 3, n = 0, a = 1) { super(e, t), this.type = "SpotLight", this.position.copy(u.DefaultUp), this.updateMatrix(), this.target = new u, this.distance = i, this.angle = r, this.penumbra = n, this.decay = a, this.shadow = new kl } get power() { return this.intensity * Math.PI } set power(e) { this.intensity = e / Math.PI } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } Gl.prototype.isSpotLight = !0; const Wl = new Pe, jl = new Le, Xl = new Le; class ql extends Vl { constructor() { super(new C(90, 1, .5, 500)), this._frameExtents = new k(4, 2), this._viewportCount = 6, this._viewports = [new Re(2, 1, 1, 1), new Re(0, 1, 1, 1), new Re(3, 1, 1, 1), new Re(1, 1, 1, 1), new Re(3, 0, 1, 1), new Re(1, 0, 1, 1)], this._cubeDirections = [new Le(1, 0, 0), new Le(-1, 0, 0), new Le(0, 0, 1), new Le(0, 0, -1), new Le(0, 1, 0), new Le(0, -1, 0)], this._cubeUps = [new Le(0, 1, 0), new Le(0, 1, 0), new Le(0, 1, 0), new Le(0, 1, 0), new Le(0, 0, 1), new Le(0, 0, -1)] } updateMatrices(e, t = 0) { const i = this.camera, r = this.matrix, n = e.distance || i.far; n !== i.far && (i.far = n, i.updateProjectionMatrix()), jl.setFromMatrixPosition(e.matrixWorld), i.position.copy(jl), Xl.copy(i.position), Xl.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(Xl), i.updateMatrixWorld(), r.makeTranslation(-jl.x, -jl.y, -jl.z), Wl.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Wl) } } ql.prototype.isPointLightShadow = !0; class Yl extends Hl { constructor(e, t, i = 0, r = 1) { super(e, t), this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new ql } get power() { return 4 * this.intensity * Math.PI } set power(e) { this.intensity = e / (4 * Math.PI) } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } } Yl.prototype.isPointLight = !0; class Ql extends Vl { constructor() { super(new hr(-5, 5, 5, -5, .5, 500)) } } Ql.prototype.isDirectionalLightShadow = !0; class Zl extends Hl { constructor(e, t) { super(e, t), this.type = "DirectionalLight", this.position.copy(u.DefaultUp), this.updateMatrix(), this.target = new u, this.shadow = new Ql } dispose() { this.shadow.dispose() } copy(e) { return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } } Zl.prototype.isDirectionalLight = !0; class Jl extends Hl { constructor(e, t) { super(e, t), this.type = "AmbientLight" } } Jl.prototype.isAmbientLight = !0; class Kl extends Hl { constructor(e, t, i = 10, r = 10) { super(e, t), this.type = "RectAreaLight", this.width = i, this.height = r } copy(e) { return super.copy(e), this.width = e.width, this.height = e.height, this } toJSON(e) { const t = super.toJSON(e); return t.object.width = this.width, t.object.height = this.height, t } } Kl.prototype.isRectAreaLight = !0; class $l { constructor() { this.coefficients = []; for (let e = 0; e < 9; e++)this.coefficients.push(new Le) } set(t) { for (let e = 0; e < 9; e++)this.coefficients[e].copy(t[e]); return this } zero() { for (let e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this } getAt(e, t) { var i = e.x, r = e.y, e = e.z, n = this.coefficients; return t.copy(n[0]).multiplyScalar(.282095), t.addScaledVector(n[1], .488603 * r), t.addScaledVector(n[2], .488603 * e), t.addScaledVector(n[3], .488603 * i), t.addScaledVector(n[4], i * r * 1.092548), t.addScaledVector(n[5], r * e * 1.092548), t.addScaledVector(n[6], .315392 * (3 * e * e - 1)), t.addScaledVector(n[7], i * e * 1.092548), t.addScaledVector(n[8], .546274 * (i * i - r * r)), t } getIrradianceAt(e, t) { var i = e.x, r = e.y, e = e.z, n = this.coefficients; return t.copy(n[0]).multiplyScalar(.886227), t.addScaledVector(n[1], 1.023328 * r), t.addScaledVector(n[2], 1.023328 * e), t.addScaledVector(n[3], 1.023328 * i), t.addScaledVector(n[4], .858086 * i * r), t.addScaledVector(n[5], .858086 * r * e), t.addScaledVector(n[6], .743125 * e * e - .247708), t.addScaledVector(n[7], .858086 * i * e), t.addScaledVector(n[8], .429043 * (i * i - r * r)), t } add(t) { for (let e = 0; e < 9; e++)this.coefficients[e].add(t.coefficients[e]); return this } addScaledSH(t, i) { for (let e = 0; e < 9; e++)this.coefficients[e].addScaledVector(t.coefficients[e], i); return this } scale(t) { for (let e = 0; e < 9; e++)this.coefficients[e].multiplyScalar(t); return this } lerp(t, i) { for (let e = 0; e < 9; e++)this.coefficients[e].lerp(t.coefficients[e], i); return this } equals(t) { for (let e = 0; e < 9; e++)if (!this.coefficients[e].equals(t.coefficients[e])) return !1; return !0 } copy(e) { return this.set(e.coefficients) } clone() { return (new this.constructor).copy(this) } fromArray(t, i = 0) { const r = this.coefficients; for (let e = 0; e < 9; e++)r[e].fromArray(t, i + 3 * e); return this } toArray(t = [], i = 0) { const r = this.coefficients; for (let e = 0; e < 9; e++)r[e].toArray(t, i + 3 * e); return t } static getBasisAt(e, t) { var i = e.x, r = e.y, e = e.z; t[0] = .282095, t[1] = .488603 * r, t[2] = .488603 * e, t[3] = .488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * e, t[6] = .315392 * (3 * e * e - 1), t[7] = 1.092548 * i * e, t[8] = .546274 * (i * i - r * r) } } $l.prototype.isSphericalHarmonics3 = !0; class ec extends Hl { constructor(e = new $l, t = 1) { super(void 0, t), this.sh = e } copy(e) { return super.copy(e), this.sh.copy(e.sh), this } fromJSON(e) { return this.intensity = e.intensity, this.sh.fromArray(e.sh), this } toJSON(e) { const t = super.toJSON(e); return t.object.sh = this.sh.toArray(), t } } ec.prototype.isLightProbe = !0; class tc extends l { constructor(e) { super(e), this.textures = {} } load(t, i, e, r) { const n = this, a = new Rl(n.manager); a.setPath(n.path), a.setRequestHeader(n.requestHeader), a.setWithCredentials(n.withCredentials), a.load(t, function (e) { try { i(n.parse(JSON.parse(e))) } catch (e) { r ? r(e) : console.error(e), n.manager.itemError(t) } }, e, r) } parse(t) { const i = this.textures; function e(e) { return void 0 === i[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), i[e] } const r = new hl[t.type]; if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && void 0 !== r.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.sheen && (r.sheen = (new y).setHex(t.sheen)), void 0 !== t.emissive && void 0 !== r.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== r.specular && r.specular.setHex(t.specular), void 0 !== t.specularIntensity && (r.specularIntensity = t.specularIntensity), void 0 !== t.specularTint && void 0 !== r.specularTint && r.specularTint.setHex(t.specularTint), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (r.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.transmission && (r.transmission = t.transmission), void 0 !== t.thickness && (r.thickness = t.thickness), void 0 !== t.attenuationDistance && (r.attenuationDistance = t.attenuationDistance), void 0 !== t.attenuationTint && void 0 !== r.attenuationTint && r.attenuationTint.setHex(t.attenuationTint), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.shadowSide && (r.shadowSide = t.shadowSide), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (r.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (r.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.alphaToCoverage && (r.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (r.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? r.vertexColors = 0 < t.vertexColors : r.vertexColors = t.vertexColors), void 0 !== t.uniforms) for (const i in t.uniforms) { var n = t.uniforms[i]; switch (r.uniforms[i] = {}, n.type) { case "t": r.uniforms[i].value = e(n.value); break; case "c": r.uniforms[i].value = (new y).setHex(n.value); break; case "v2": r.uniforms[i].value = (new k).fromArray(n.value); break; case "v3": r.uniforms[i].value = (new Le).fromArray(n.value); break; case "v4": r.uniforms[i].value = (new Re).fromArray(n.value); break; case "m3": r.uniforms[i].value = (new g).fromArray(n.value); break; case "m4": r.uniforms[i].value = (new Pe).fromArray(n.value); break; default: r.uniforms[i].value = n.value } } if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (const i in t.extensions) r.extensions[i] = t.extensions[i]; if (void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = e(t.map)), void 0 !== t.matcap && (r.matcap = e(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap)), void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) { let e = t.normalScale; !1 === Array.isArray(e) && (e = [e, e]), r.normalScale = (new k).fromArray(e) } return void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)), void 0 !== t.specularIntensityMap && (r.specularIntensityMap = e(t.specularIntensityMap)), void 0 !== t.specularTintMap && (r.specularTintMap = e(t.specularTintMap)), void 0 !== t.envMap && (r.envMap = e(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)), void 0 !== t.clearcoatMap && (r.clearcoatMap = e(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = e(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (r.clearcoatNormalMap = e(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (r.clearcoatNormalScale = (new k).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmissionMap && (r.transmissionMap = e(t.transmissionMap)), void 0 !== t.thicknessMap && (r.thicknessMap = e(t.thicknessMap)), r } setTextures(e) { return this.textures = e, this } } class ic { static decodeText(i) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(i); let r = ""; for (let e = 0, t = i.length; e < t; e++)r += String.fromCharCode(i[e]); try { return decodeURIComponent(escape(r)) } catch (i) { return r } } static extractUrlBase(e) { var t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } } class rc extends S { constructor() { super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy(e) { return super.copy(e), this.instanceCount = e.instanceCount, this } clone() { return (new this.constructor).copy(this) } toJSON() { const e = super.toJSON(this); return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e } } rc.prototype.isInstancedBufferGeometry = !0; class nc extends P { constructor(e, t, i, r = 1) { "number" == typeof i && (r = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, i), this.meshPerAttribute = r } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } toJSON() { const e = super.toJSON(); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } } nc.prototype.isInstancedBufferAttribute = !0; class ac extends l { constructor(e) { super(e) } load(t, i, e, r) { const n = this, a = new Rl(n.manager); a.setPath(n.path), a.setRequestHeader(n.requestHeader), a.setWithCredentials(n.withCredentials), a.load(t, function (e) { try { i(n.parse(JSON.parse(e))) } catch (e) { r ? r(e) : console.error(e), n.manager.itemError(t) } }, e, r) } parse(i) { const s = {}, l = {}; function r(e, t) { if (void 0 !== s[t]) return s[t]; const i = e.interleavedBuffers[t], r = (o = i.buffer, void 0 !== l[o] ? l[o] : (e = e.arrayBuffers[o], e = new Uint32Array(e).buffer, l[o] = e)), n = fi(i.type, r), a = new za(n, i.stride); var o; return a.uuid = i.uuid, s[t] = a } const n = new (i.isInstancedBufferGeometry ? rc : S), a = i.data.index; if (void 0 !== a) { const i = fi(a.type, a.array); n.setIndex(new P(i, 1)) } var t = i.data.attributes; for (const s in t) { const l = t[s]; let e; if (l.isInterleavedBufferAttribute) { const s = r(i.data, l.data); e = new Oa(s, l.itemSize, l.offset, l.normalized) } else { const i = fi(l.type, l.array); e = new (l.isInstancedBufferAttribute ? nc : P)(i, l.itemSize, l.normalized) } void 0 !== l.name && (e.name = l.name), void 0 !== l.usage && e.setUsage(l.usage), void 0 !== l.updateRange && (e.updateRange.offset = l.updateRange.offset, e.updateRange.count = l.updateRange.count), n.setAttribute(s, e) } var e = i.data.morphAttributes; if (e) for (const s in e) { const l = e[s], a = []; for (let t = 0, e = l.length; t < e; t++) { const n = l[t]; let e; if (n.isInterleavedBufferAttribute) { const s = r(i.data, n.data); e = new Oa(s, n.itemSize, n.offset, n.normalized) } else { const i = fi(n.type, n.array); e = new P(i, n.itemSize, n.normalized) } void 0 !== n.name && (e.name = n.name), a.push(e) } n.morphAttributes[s] = a } i.data.morphTargetsRelative && (n.morphTargetsRelative = !0); var o = i.data.groups || i.data.drawcalls || i.data.offsets; if (void 0 !== o) for (let e = 0, t = o.length; e !== t; ++e) { const s = o[e]; n.addGroup(s.start, s.count, s.materialIndex) } var c = i.data.boundingSphere; if (void 0 !== c) { const i = new Le; void 0 !== c.center && i.fromArray(c.center), n.boundingSphere = new at(i, c.radius) } return i.name && (n.name = i.name), i.userData && (n.userData = i.userData), n } } const oc = { UVMapping: 300, CubeReflectionMapping: A, CubeRefractionMapping: R, EquirectangularReflectionMapping: L, EquirectangularRefractionMapping: F, CubeUVReflectionMapping: D, CubeUVRefractionMapping: I }, sc = { RepeatWrapping: z, ClampToEdgeWrapping: Ce, MirroredRepeatWrapping: O }, lc = { NearestFilter: Ae, NearestMipmapNearestFilter: V, NearestMipmapLinearFilter: W, LinearFilter: U, LinearMipmapNearestFilter: j, LinearMipmapLinearFilter: Fe }; class cc extends l { constructor(e) { super(e), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" } } setOptions(e) { return this.options = e, this } load(t, i, e, r) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); const n = this, a = Tl.get(t); if (void 0 !== a) return n.manager.itemStart(t), setTimeout(function () { i && i(a), n.manager.itemEnd(t) }, 0), a; const o = {}; o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then(function (e) { return e.blob() }).then(function (e) { return createImageBitmap(e, Object.assign(n.options, { colorSpaceConversion: "none" })) }).then(function (e) { Tl.add(t, e), i && i(e), n.manager.itemEnd(t) }).catch(function (e) { r && r(e), n.manager.itemError(t), n.manager.itemEnd(t) }), n.manager.itemStart(t) } } class hc { constructor() { this.type = "ShapePath", this.color = new y, this.subPaths = [], this.currentPath = null } moveTo(e, t) { return this.currentPath = new Il, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this } lineTo(e, t) { return this.currentPath.lineTo(e, t), this } quadraticCurveTo(e, t, i, r) { return this.currentPath.quadraticCurveTo(e, t, i, r), this } bezierCurveTo(e, t, i, r, n, a) { return this.currentPath.bezierCurveTo(e, t, i, r, n, a), this } splineThru(e) { return this.currentPath.splineThru(e), this } toShapes(i, a) { function e(i) { const r = []; for (let e = 0, t = i.length; e < t; e++) { const n = i[e], a = new Nl; a.curves = n.curves, r.push(a) } return r } const o = Ns.isClockWise, r = this.subPaths; if (0 === r.length) return []; if (!0 === a) return e(r); let s, n, l; const t = []; if (1 === r.length) return n = r[0], (l = new Nl).curves = n.curves, t.push(l), t; let c = !o(r[0].getPoints()); c = i ? !c : c; const h = [], u = []; let d, p, f = [], m = 0; u[m] = void 0, f[m] = []; for (let e = 0, t = r.length; e < t; e++)d = (n = r[e]).getPoints(), s = o(d), (s = i ? !s : s) ? (!c && u[m] && m++, u[m] = { s: new Nl, p: d }, u[m].s.curves = n.curves, c && m++, f[m] = []) : f[m].push({ h: n, p: d[0] }); if (!u[0]) return e(r); if (1 < u.length) { let n = !1; const a = []; for (let e = 0, t = u.length; e < t; e++)h[e] = []; for (let r = 0, e = u.length; r < e; r++) { const o = f[r]; for (let i = 0; i < o.length; i++) { const s = o[i]; let t = !0; for (let e = 0; e < u.length; e++)!function (o, s) { var e = s.length; let l = !1; for (let n = e - 1, a = 0; a < e; n = a++) { let e = s[n], t = s[a], i = t.x - e.x, r = t.y - e.y; if (Math.abs(r) > Number.EPSILON) { if (r < 0 && (e = s[a], i = -i, t = s[n], r = -r), !(o.y < e.y || o.y > t.y)) if (o.y === e.y) { if (o.x === e.x) return 1 } else { const s = r * (o.x - e.x) - i * (o.y - e.y); if (0 == s) return 1; s < 0 || (l = !l) } } else if (o.y === e.y && (t.x <= o.x && o.x <= e.x || e.x <= o.x && o.x <= t.x)) return 1 } return l }(s.p, u[e].p) || (r !== e && a.push({ froms: r, tos: e, hole: i }), t ? (t = !1, h[e].push(s)) : n = !0); t && h[r].push(s) } } 0 < a.length && (n || (f = h)) } for (let i = 0, e = u.length; i < e; i++) { l = u[i].s, t.push(l); for (let e = 0, t = (p = f[i]).length; e < t; e++)l.holes.push(p[e].h) } return t } } class uc { constructor(e) { this.type = "Font", this.data = e } generateShapes(e, t = 100) { const i = [], r = function (t, i, r) { const n = Array.from(t), a = i / r.resolution, o = (r.boundingBox.yMax - r.boundingBox.yMin + r.underlineThickness) * a, s = []; let l = 0, c = 0; for (let e = 0; e < n.length; e++) { const i = n[e]; if ("\n" === i) l = 0, c -= o; else { const t = function (h, u, d, p, e) { const t = e.glyphs[h] || e.glyphs["?"]; if (t) { const f = new hc; let i, r, n, a, o, s, l, c; if (t.o) { const h = t._cachedOutline || (t._cachedOutline = t.o.split(" ")); for (let e = 0, t = h.length; e < t;)switch (h[e++]) { case "m": i = h[e++] * u + d, r = h[e++] * u + p, f.moveTo(i, r); break; case "l": i = h[e++] * u + d, r = h[e++] * u + p, f.lineTo(i, r); break; case "q": n = h[e++] * u + d, a = h[e++] * u + p, o = h[e++] * u + d, s = h[e++] * u + p, f.quadraticCurveTo(o, s, n, a); break; case "b": n = h[e++] * u + d, a = h[e++] * u + p, o = h[e++] * u + d, s = h[e++] * u + p, l = h[e++] * u + d, c = h[e++] * u + p, f.bezierCurveTo(o, s, l, c, n, a) } } return { offsetX: t.ha * u, path: f } } console.error('THREE.Font: character "' + h + '" does not exists in font family ' + e.familyName + ".") }(i, a, l, c, r); l += t.offsetX, s.push(t.path) } } return s }(e, t, this.data); for (let e = 0, t = r.length; e < t; e++)Array.prototype.push.apply(i, r[e].toShapes()); return i } } uc.prototype.isFont = cc.prototype.isImageBitmapLoader = !0; let dc; const pc = { getContext: function () { return dc = void 0 === dc ? new (window.AudioContext || window.webkitAudioContext) : dc }, setContext: function (e) { dc = e } }; class fc extends l { constructor(e) { super(e) } load(t, i, e, r) { const n = this, a = new Rl(this.manager); a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function (e) { try { const t = e.slice(0); pc.getContext().decodeAudioData(t, function (e) { i(e) }) } catch (e) { r ? r(e) : console.error(e), n.manager.itemError(t) } }, e, r) } } class mc extends ec { constructor(e, t, i = 1) { super(void 0, i); var i = (new y).set(e), e = (new y).set(t), t = new Le(i.r, i.g, i.b), i = new Le(e.r, e.g, e.b), r = (e = Math.sqrt(Math.PI)) * Math.sqrt(.75); this.sh.coefficients[0].copy(t).add(i).multiplyScalar(e), this.sh.coefficients[1].copy(t).sub(i).multiplyScalar(r) } } class vc extends ec { constructor(e, t = 1) { super(void 0, t), t = (new y).set(e), this.sh.coefficients[0].set(t.r, t.g, t.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } } vc.prototype.isAmbientLightProbe = mc.prototype.isHemisphereLightProbe = !0; const gc = new Pe, xc = new Pe; class yc { constructor(e = !0) { this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start() { this.startTime = _c(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime() { return this.getDelta(), this.elapsedTime } getDelta() { let e = 0; return this.autoStart && !this.running ? (this.start(), 0) : (this.running && (t = _c(), e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e), e); var t } } function _c() { return ("undefined" == typeof performance ? Date : performance).now() } const bc = new Le, wc = new m, Ec = new Le, Tc = new Le; class Sc extends u { constructor(e) { super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [] } getOutput() { return this.gain } setNodeSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this } setMediaElementSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this } setMediaStreamSource(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this } setBuffer(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this } play(e = 0) { if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else { if (!1 !== this.hasPlaybackControl) { this._startedAt = this.context.currentTime + e; const t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } console.warn("THREE.Audio: this Audio has no playback control.") } } pause() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") } stop() { if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") } connect() { if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this._connected = !0, this } disconnect() { if (0 < this.filters.length) { this.source.disconnect(this.filters[0]); for (let e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this._connected = !1, this } getFilters() { return this.filters } setFilters(e) { return e = e || [], !0 === this._connected ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this } setDetune(e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this } getDetune() { return this.detune } getFilter() { return this.getFilters()[0] } setFilter(e) { return this.setFilters(e ? [e] : []) } setPlaybackRate(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") } getPlaybackRate() { return this.playbackRate } onEnded() { this.isPlaying = !1 } getLoop() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop } setLoop(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") } setLoopStart(e) { return this.loopStart = e, this } setLoopEnd(e) { return this.loopEnd = e, this } getVolume() { return this.gain.gain.value } setVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } } const Mc = new Le, Ac = new m, Rc = new Le, Lc = new Le; class Pc { constructor(e, t = 2048) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } getFrequencyData() { return this.analyser.getByteFrequencyData(this.data), this.data } getAverageFrequency() { let t = 0; var i = this.getFrequencyData(); for (let e = 0; e < i.length; e++)t += i[e]; return t / i.length } } class Cc { constructor(e, t, i) { let r, n, a; switch (this.binding = e, this.valueSize = i, t) { case "quaternion": r = this._slerp, n = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * i), this._workIndex = 5; break; case "string": case "bool": r = this._select, n = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(5 * i); break; default: r = this._lerp, n = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * i) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = n, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate(e, t) { const i = this.buffer, r = this.valueSize, n = e * r + r; let a = this.cumulativeWeight; if (0 === a) { for (let e = 0; e !== r; ++e)i[n + e] = i[e]; a = t } else { const e = t / (a += t); this._mixBufferRegion(i, n, 0, e, r) } this.cumulativeWeight = a } accumulateAdditive(e) { var t = this.buffer, i = this.valueSize, r = i * this._addIndex; 0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e } apply(e) { const i = this.valueSize, r = this.buffer, n = e * i + i, t = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, t < 1) { const e = i * this._origIndex; this._mixBufferRegion(r, n, e, 1 - t, i) } 0 < a && this._mixBufferRegionAdditive(r, n, this._addIndex * i, 1, i); for (let e = i, t = i + i; e !== t; ++e)if (r[e] !== r[e + i]) { o.setValue(r, n); break } } saveOriginalState() { const e = this.binding, i = this.buffer, r = this.valueSize, n = r * this._origIndex; e.getValue(i, n); for (let e = r, t = n; e !== t; ++e)i[e] = i[n + e % r]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState() { var e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) } _setAdditiveIdentityNumeric() { var t = this._addIndex * this.valueSize, i = t + this.valueSize; for (let e = t; e < i; e++)this.buffer[e] = 0 } _setAdditiveIdentityQuaternion() { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther() { var t = this._origIndex * this.valueSize, i = this._addIndex * this.valueSize; for (let e = 0; e < this.valueSize; e++)this.buffer[i + e] = this.buffer[t + e] } _select(t, i, r, e, n) { if (.5 <= e) for (let e = 0; e !== n; ++e)t[i + e] = t[r + e] } _slerp(e, t, i, r) { m.slerpFlat(e, t, e, t, e, i, r) } _slerpAdditive(e, t, i, r, n) { n = this._workIndex * n, m.multiplyQuaternionsFlat(e, n, e, t, e, i), m.slerpFlat(e, t, e, t, e, n, r) } _lerp(t, i, r, n, a) { var o = 1 - n; for (let e = 0; e !== a; ++e) { const a = i + e; t[a] = t[a] * o + t[r + e] * n } } _lerpAdditive(t, i, r, n, a) { for (let e = 0; e !== a; ++e) { const a = i + e; t[a] = t[a] + t[r + e] * n } } } const Fc = new RegExp("[\\[\\]\\.:\\/]", "g"), Dc = "[^\\[\\]\\.:\\/]", Ic = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Nc = /((?:WC+[\/:])*)/.source.replace("WC", Dc), Hc = /(WCOD+)?/.source.replace("WCOD", Ic), Bc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Dc), Uc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Dc), zc = new RegExp("^" + Nc + Hc + Bc + Uc + "$"), Oc = ["material", "materials", "bones"]; class w { constructor(e, t, i) { this.path = t, this.parsedPath = i || w.parseTrackName(t), this.node = w.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create(e, t, i) { return new (e && e.isAnimationObjectGroup ? w.Composite : w)(e, t, i) } static sanitizeNodeName(e) { return e.replace(/\s/g, "_").replace(Fc, "") } static parseTrackName(e) { var t = zc.exec(e); if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = i.nodeName && i.nodeName.lastIndexOf("."); if (void 0 !== r && -1 !== r) { const e = i.nodeName.substring(r + 1); -1 !== Oc.indexOf(e) && (i.nodeName = i.nodeName.substring(0, r), i.objectName = e) } if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return i } static findNode(e, r) { if (!r || "" === r || "." === r || -1 === r || r === e.name || r === e.uuid) return e; if (e.skeleton) { var t = e.skeleton.getBoneByName(r); if (void 0 !== t) return t } if (e.children) { const n = function (t) { for (let e = 0; e < t.length; e++) { var i = t[e]; if (i.name === r || i.uuid === r) return i; if (i = n(i.children)) return i } return null }, i = n(e.children); if (i) return i } return null } _getValue_unavailable() { } _setValue_unavailable() { } _getValue_direct(e, t) { e[t] = this.node[this.propertyName] } _getValue_array(i, r) { var n = this.resolvedProperty; for (let e = 0, t = n.length; e !== t; ++e)i[r++] = n[e] } _getValue_arrayElement(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray(e, t) { this.resolvedProperty.toArray(e, t) } _setValue_direct(e, t) { this.targetObject[this.propertyName] = e[t] } _setValue_direct_setNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array(i, r) { const n = this.resolvedProperty; for (let e = 0, t = n.length; e !== t; ++e)n[e] = i[r++] } _setValue_array_setNeedsUpdate(i, r) { const n = this.resolvedProperty; for (let e = 0, t = n.length; e !== t; ++e)n[e] = i[r++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate(i, r) { const n = this.resolvedProperty; for (let e = 0, t = n.length; e !== t; ++e)n[e] = i[r++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] } _setValue_arrayElement_setNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray(e, t) { this.resolvedProperty.fromArray(e, t) } _setValue_fromArray_setNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound(e, t) { this.bind(), this.getValue(e, t) } _setValue_unbound(e, t) { this.bind(), this.setValue(e, t) } bind() { let i = this.node; const e = this.parsedPath, r = e.objectName, n = e.propertyName; let a = e.propertyIndex; if (i || (i = w.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = i), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, i) { if (r) { let t = e.objectIndex; switch (r) { case "materials": if (!i.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!i.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); i = i.material.materials; break; case "bones": if (!i.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); i = i.skeleton.bones; for (let e = 0; e < i.length; e++)if (i[e].name === t) { t = e; break } break; default: if (void 0 === i[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); i = i[r] }if (void 0 !== t) { if (void 0 === i[t]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, i); i = i[t] } } var o = i[n]; if (void 0 === o) { const r = e.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + r + "." + n + " but it wasn't found.", i) } else { let e = this.Versioning.None, t = (void 0 !== (this.targetObject = i).needsUpdate ? e = this.Versioning.NeedsUpdate : void 0 !== i.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate), this.BindingType.Direct); if (void 0 !== a) { if ("morphTargetInfluences" === n) { if (!i.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (!i.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this); if (!i.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); void 0 !== i.morphTargetDictionary[a] && (a = i.morphTargetDictionary[a]) } t = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = a } else void 0 !== o.fromArray && void 0 !== o.toArray ? (t = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (t = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n; this.getValue = this.GetterByBindingType[t], this.setValue = this.SetterByBindingTypeAndVersioning[t][e] } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") } unbind() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } } w.Composite = class { constructor(e, t, i) { i = i || w.parseTrackName(t), this._targetGroup = e, this._bindings = e.subscribe_(t, i) } getValue(e, t) { this.bind(); const i = this._targetGroup.nCachedObjects_, r = this._bindings[i]; void 0 !== r && r.getValue(e, t) } setValue(i, r) { const n = this._bindings; for (let e = this._targetGroup.nCachedObjects_, t = n.length; e !== t; ++e)n[e].setValue(i, r) } bind() { const i = this._bindings; for (let e = this._targetGroup.nCachedObjects_, t = i.length; e !== t; ++e)i[e].bind() } unbind() { const i = this._bindings; for (let e = this._targetGroup.nCachedObjects_, t = i.length; e !== t; ++e)i[e].unbind() } }, w.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, w.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, w.prototype.GetterByBindingType = [w.prototype._getValue_direct, w.prototype._getValue_array, w.prototype._getValue_arrayElement, w.prototype._getValue_toArray], w.prototype.SetterByBindingTypeAndVersioning = [[w.prototype._setValue_direct, w.prototype._setValue_direct_setNeedsUpdate, w.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [w.prototype._setValue_array, w.prototype._setValue_array_setNeedsUpdate, w.prototype._setValue_array_setMatrixWorldNeedsUpdate], [w.prototype._setValue_arrayElement, w.prototype._setValue_arrayElement_setNeedsUpdate, w.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [w.prototype._setValue_fromArray, w.prototype._setValue_fromArray_setNeedsUpdate, w.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; class Vc { constructor() { this.uuid = pe(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; const i = {}; this._indicesByUUID = i; for (let e = 0, t = arguments.length; e !== t; ++e)i[arguments[e].uuid] = e; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; const e = this; this.stats = { objects: { get total() { return e._objects.length }, get inUse() { return this.total - e.nCachedObjects_ } }, get bindingsPerObject() { return e._bindings.length } } } add() { const r = this._objects, n = this._indicesByUUID, a = this._paths, o = this._parsedPaths, s = this._bindings, l = s.length; let c, h = r.length, u = this.nCachedObjects_; for (let e = 0, t = arguments.length; e !== t; ++e) { var d = arguments[e], p = d.uuid; let i = n[p]; if (void 0 === i) { i = h++, n[p] = i, r.push(d); for (let e = 0, t = l; e !== t; ++e)s[e].push(new w(d, a[e], o[e])) } else if (i < u) { c = r[i]; const h = --u, f = r[h]; n[f.uuid] = i, r[i] = f, n[p] = h, r[h] = d; for (let t = 0, e = l; t !== e; ++t) { const n = s[t], l = n[h]; let e = n[i]; n[i] = l, void 0 === e && (e = new w(d, a[t], o[t])), n[h] = e } } else r[i] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = u } remove() { const i = this._objects, r = this._indicesByUUID, n = this._bindings, a = n.length; let o = this.nCachedObjects_; for (let e = 0, t = arguments.length; e !== t; ++e) { var s = arguments[e], l = s.uuid, c = r[l]; if (void 0 !== c && c >= o) { var h = o++, u = i[h]; r[u.uuid] = c, i[c] = u, r[l] = h, i[h] = s; for (let e = 0, t = a; e !== t; ++e) { const r = n[e], a = r[h], o = r[c]; r[c] = a, r[h] = o } } } this.nCachedObjects_ = o } uncache() { const i = this._objects, r = this._indicesByUUID, n = this._bindings, a = n.length; let o = this.nCachedObjects_, s = i.length; for (let e = 0, t = arguments.length; e !== t; ++e) { var l = arguments[e].uuid, c = r[l]; if (void 0 !== c) if (delete r[l], c < o) { var h = --o, l = i[h], u = --s, d = i[u]; r[l.uuid] = c, i[c] = l, r[d.uuid] = h, i[h] = d, i.pop(); for (let e = 0, t = a; e !== t; ++e) { const r = n[e], a = r[h], o = r[u]; r[c] = a, r[h] = o, r.pop() } } else { const o = --s, p = i[o]; 0 < o && (r[p.uuid] = c), i[c] = p, i.pop(); for (let e = 0, t = a; e !== t; ++e) { const r = n[e]; r[c] = r[o], r.pop() } } } this.nCachedObjects_ = o } subscribe_(i, r) { const e = this._bindingsIndicesByPath; let n = e[i]; const t = this._bindings; if (void 0 !== n) return t[n]; const a = this._paths, o = this._parsedPaths, s = this._objects, l = s.length, c = this.nCachedObjects_, h = new Array(l); n = t.length, e[i] = n, a.push(i), o.push(r), t.push(h); for (let e = c, t = s.length; e !== t; ++e) { const n = s[e]; h[e] = new w(n, i, r) } return h } unsubscribe_(e) { const t = this._bindingsIndicesByPath, i = t[e]; if (void 0 !== i) { const r = this._paths, n = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o]; t[e[o]] = i, a[i] = s, a.pop(), n[i] = n[o], n.pop(), r[i] = r[o], r.pop() } } } Vc.prototype.isAnimationObjectGroup = !0; class kc { constructor(e, t, i = null, r = t.blendMode) { this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r; const n = t.tracks, a = n.length, o = new Array(a), s = { endingStart: 2400, endingEnd: 2400 }; for (let e = 0; e !== a; ++e) { const t = n[e].createInterpolant(null); (o[e] = t).settings = s } this._interpolantSettings = s, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play() { return this._mixer._activateAction(this), this } stop() { return this._mixer._deactivateAction(this), this.reset() } reset() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) } isScheduled() { return this._mixer._isActiveAction(this) } startAt(e) { return this._startTime = e, this } setLoop(e, t) { return this.loop = e, this.repetitions = t, this } setEffectiveWeight(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() } getEffectiveWeight() { return this._effectiveWeight } fadeIn(e) { return this._scheduleFading(e, 0, 1) } fadeOut(e) { return this._scheduleFading(e, 1, 0) } crossFadeFrom(e, t, i) { if (e.fadeOut(t), this.fadeIn(t), i) { const i = this._clip.duration, r = e._clip.duration, n = r / i, a = i / r; e.warp(1, n, t), this.warp(a, 1, t) } return this } crossFadeTo(e, t, i) { return e.crossFadeFrom(this, t, i) } stopFading() { var e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } setEffectiveTimeScale(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() } getEffectiveTimeScale() { return this._effectiveTimeScale } setDuration(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() } syncWith(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() } halt(e) { return this.warp(this._effectiveTimeScale, 0, e) } warp(e, t, i) { const r = this._mixer, n = r.time, a = this.timeScale; let o = this._timeScaleInterpolant; null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o); const s = o.parameterPositions, l = o.sampleValues; return s[0] = n, s[1] = n + i, l[0] = e / a, l[1] = t / a, this } stopWarping() { var e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this } getMixer() { return this._mixer } getClip() { return this._clip } getRoot() { return this._localRoot || this._mixer._root } _update(i, r, e, n) { if (this.enabled) { var t = this._startTime; if (null !== t) { const n = (i - t) * e; if (n < 0 || 0 === e) return; this._startTime = null, r = e * n } r *= this._updateTimeScale(i); var a = this._updateTime(r), o = this._updateWeight(i); if (0 < o) { const i = this._interpolants, r = this._propertyBindings; if (2501 === this.blendMode) for (let e = 0, t = i.length; e !== t; ++e)i[e].evaluate(a), r[e].accumulateAdditive(o); else for (let e = 0, t = i.length; e !== t; ++e)i[e].evaluate(a), r[e].accumulate(n, o) } } else this._updateWeight(i) } _updateWeight(e) { let t = 0; if (this.enabled) { t = this.weight; const r = this._weightInterpolant; var i; null !== r && (i = r.evaluate(e)[0], t *= i, e > r.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))) } return this._effectiveWeight = t } _updateTimeScale(e) { let t = 0; if (!this.paused) { t = this.timeScale; const i = this._timeScaleInterpolant; null !== i && (t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)) } return this._effectiveTimeScale = t } _updateTime(e) { const t = this._clip.duration, i = this.loop; let r = this.time + e, n = this._loopCount; var a = 2202 === i; if (0 === e) return -1 !== n && a && 1 == (1 & n) ? t - r : r; if (2200 === i) { -1 === n && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else { if (!(r < 0)) { this.time = r; break e } r = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === n && (0 <= e ? (n = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), r >= t || r < 0) { const i = Math.floor(r / t); r -= t * i, n += Math.abs(i); var o = this.repetitions - n; if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = 0 < e ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < e ? 1 : -1 }); else { if (1 == o) { const t = e < 0; this._setEndings(t, !t, a) } else this._setEndings(!1, !1, a); this._loopCount = n, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i }) } } else this.time = r; if (a && 1 == (1 & n)) return t - r } return r } _setEndings(e, t, i) { const r = this._interpolantSettings; i ? (r.endingStart = 2401, r.endingEnd = 2401) : (r.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, r.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402) } _scheduleFading(e, t, i) { const r = this._mixer, n = r.time; let a = this._weightInterpolant; null === a && (a = r._lendControlInterpolant(), this._weightInterpolant = a); const o = a.parameterPositions, s = a.sampleValues; return o[0] = n, s[0] = t, o[1] = n + e, s[1] = i, this } } class Gc extends ce { constructor(e) { super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction(e, i) { const r = e._localRoot || this._root, n = e._clip.tracks, a = n.length, o = e._propertyBindings, s = e._interpolants, l = r.uuid, c = this._bindingsByRootAndName; let h = c[l]; void 0 === h && (h = {}, c[l] = h); for (let t = 0; t !== a; ++t) { const a = n[t], c = a.name; let e = h[c]; if (void 0 !== e) o[t] = e; else { if (void 0 !== (e = o[t])) { null === e._cacheIndex && (++e.referenceCount, this._addInactiveBinding(e, l, c)); continue } const n = i && i._propertyBindings[t].binding.parsedPath; ++(e = new Cc(w.create(r, c, n), a.ValueTypeName, a.getValueSize())).referenceCount, this._addInactiveBinding(e, l, c), o[t] = e } s[t].resultBuffer = e.buffer } } _activateAction(e) { if (!this._isActiveAction(e)) { null === e._cacheIndex && (t = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i], this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, i, t)); var t, i, r, n = e._propertyBindings; for (let e = 0, t = n.length; e !== t; ++e) { const a = n[e]; 0 == a.useCount++ && (this._lendBinding(a), a.saveOriginalState()) } this._lendAction(e) } } _deactivateAction(e) { if (this._isActiveAction(e)) { var i = e._propertyBindings; for (let e = 0, t = i.length; e !== t; ++e) { const r = i[e]; 0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r)) } this._takeBackAction(e) } } _initMemoryManager() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; const e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } } _isActiveAction(e) { return null !== (e = e._cacheIndex) && e < this._nActiveActions } _addInactiveAction(e, t, i) { const r = this._actions, n = this._actionsByClip; let a = n[t]; if (void 0 === a) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, n[t] = a; else { const t = a.knownActions; e._byClipCacheIndex = t.length, t.push(e) } e._cacheIndex = r.length, r.push(e), a.actionByRoot[i] = e } _removeInactiveAction(e) { const t = this._actions, i = t[t.length - 1], r = e._cacheIndex, n = (i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null, e._clip.uuid), a = this._actionsByClip, o = a[n], s = o.knownActions, l = s[s.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[n], this._removeInactiveBindingsForAction(e) } _removeInactiveBindingsForAction(e) { var i = e._propertyBindings; for (let e = 0, t = i.length; e !== t; ++e) { const r = i[e]; 0 == --r.referenceCount && this._removeInactiveBinding(r) } } _lendAction(e) { const t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _takeBackAction(e) { const t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _addInactiveBinding(e, t, i) { const r = this._bindingsByRootAndName, n = this._bindings; let a = r[t]; void 0 === a && (a = {}, r[t] = a), (a[i] = e)._cacheIndex = n.length, n.push(e) } _removeInactiveBinding(e) { const t = this._bindings, i = e.binding, r = i.rootNode.uuid, n = i.path, a = this._bindingsByRootAndName, o = a[r], s = t[t.length - 1], l = e._cacheIndex; s._cacheIndex = l, t[l] = s, t.pop(), delete o[n], 0 === Object.keys(o).length && delete a[r] } _lendBinding(e) { const t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _takeBackBinding(e) { const t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, n = t[r]; e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n } _lendControlInterpolant() { const e = this._controlInterpolants, t = this._nActiveControlInterpolants++; let i = e[t]; return void 0 === i && ((i = new pl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = i), i } _takeBackControlInterpolant(e) { const t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, n = t[r]; e.__cacheIndex = r, t[r] = e, n.__cacheIndex = i, t[i] = n } clipAction(e, t, i) { var r = (a = t || this._root).uuid; let n = "string" == typeof e ? El.findByName(a, e) : e; var a = null !== n ? n.uuid : e, o = this._actionsByClip[a]; let s = null; if (void 0 === i && (i = null !== n ? n.blendMode : 2500), void 0 !== o) { const e = o.actionByRoot[r]; if (void 0 !== e && e.blendMode === i) return e; s = o.knownActions[0], null === n && (n = s._clip) } return null === n ? null : (e = new kc(this, n, t, i), this._bindAction(e, s), this._addInactiveAction(e, a, r), e) } existingAction(e, t) { var i = (t = t || this._root).uuid, t = (t = "string" == typeof e ? El.findByName(t, e) : e) ? t.uuid : e; return void 0 !== (e = this._actionsByClip[t]) && e.actionByRoot[i] || null } stopAllAction() { const t = this._actions; for (let e = this._nActiveActions - 1; 0 <= e; --e)t[e].stop(); return this } update(t) { t *= this.timeScale; const i = this._actions, r = this._nActiveActions, n = this.time += t, a = Math.sign(t), o = this._accuIndex ^= 1; for (let e = 0; e !== r; ++e)i[e]._update(n, t, a, o); const s = this._bindings, l = this._nActiveBindings; for (let e = 0; e !== l; ++e)s[e].apply(o); return this } setTime(e) { for (let e = this.time = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(e) } getRoot() { return this._root } uncacheClip(i) { const r = this._actions, e = i.uuid, n = this._actionsByClip, a = n[e]; if (void 0 !== a) { const i = a.knownActions; for (let e = 0, t = i.length; e !== t; ++e) { const n = i[e], a = (this._deactivateAction(n), n._cacheIndex), o = r[r.length - 1]; n._cacheIndex = null, n._byClipCacheIndex = null, o._cacheIndex = a, r[a] = o, r.pop(), this._removeInactiveBindingsForAction(n) } delete n[e] } } uncacheRoot(e) { const t = e.uuid, i = this._actionsByClip; for (const e in i) { const r = i[e].actionByRoot[t]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } const r = this._bindingsByRootAndName[t]; if (void 0 !== r) for (const e in r) { const t = r[e]; t.restoreOriginalState(), this._removeInactiveBinding(t) } } uncacheAction(e, t) { null !== (e = this.existingAction(e, t)) && (this._deactivateAction(e), this._removeInactiveAction(e)) } } Gc.prototype._controlInterpolantsResultBuffer = new Float32Array(1); class Wc { constructor(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e } clone() { return new Wc(void 0 === this.value.clone ? this.value : this.value.clone()) } } class jc extends za { constructor(e, t, i = 1) { super(e, t), this.meshPerAttribute = i } copy(e) { return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this } clone(e) { const t = super.clone(e); return t.meshPerAttribute = this.meshPerAttribute, t } toJSON(e) { const t = super.toJSON(e); return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t } } class Xc { constructor(e, t, i, r, n) { this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = n, this.version = 0 } set needsUpdate(e) { !0 === e && this.version++ } setBuffer(e) { return this.buffer = e, this } setType(e, t) { return this.type = e, this.elementSize = t, this } setItemSize(e) { return this.itemSize = e, this } setCount(e) { return this.count = e, this } } function qc(e, t) { return e.distance - t.distance } function Yc(e, i, r, n) { if (e.layers.test(i.layers) && e.raycast(i, r), !0 === n) { const n = e.children; for (let e = 0, t = n.length; e < t; e++)Yc(n[e], i, r, !0) } } Xc.prototype.isGLBufferAttribute = jc.prototype.isInstancedInterleavedBuffer = !0; const Qc = new k; class Zc { constructor(e = new k(1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0)) { this.min = e, this.max = t } set(e, t) { return this.min.copy(e), this.max.copy(t), this } setFromPoints(i) { this.makeEmpty(); for (let e = 0, t = i.length; e < t; e++)this.expandByPoint(i[e]); return this } setFromCenterAndSize(e, t) { return t = Qc.copy(t).multiplyScalar(.5), this.min.copy(e).sub(t), this.max.copy(e).add(t), this } clone() { return (new this.constructor).copy(this) } copy(e) { return this.min.copy(e.min), this.max.copy(e.max), this } makeEmpty() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty() { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter(e) { return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) } getSize(e) { return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) } expandByPoint(e) { return this.min.min(e), this.max.max(e), this } expandByVector(e) { return this.min.sub(e), this.max.add(e), this } expandByScalar(e) { return this.min.addScalar(-e), this.max.addScalar(e), this } containsPoint(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) } containsBox(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y } getParameter(e, t) { return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) } clampPoint(e, t) { return t.copy(e).clamp(this.min, this.max) } distanceToPoint(e) { return Qc.copy(e).clamp(this.min, this.max).sub(e).length() } intersect(e) { return this.min.max(e.min), this.max.min(e.max), this } union(e) { return this.min.min(e.min), this.max.max(e.max), this } translate(e) { return this.min.add(e), this.max.add(e), this } equals(e) { return e.min.equals(this.min) && e.max.equals(this.max) } } Zc.prototype.isBox2 = !0; const Jc = new Le, Kc = new Le; class $c { constructor(e = new Le, t = new Le) { this.start = e, this.end = t } set(e, t) { return this.start.copy(e), this.end.copy(t), this } copy(e) { return this.start.copy(e.start), this.end.copy(e.end), this } getCenter(e) { return e.addVectors(this.start, this.end).multiplyScalar(.5) } delta(e) { return e.subVectors(this.end, this.start) } distanceSq() { return this.start.distanceToSquared(this.end) } distance() { return this.start.distanceTo(this.end) } at(e, t) { return this.delta(t).multiplyScalar(e).add(this.start) } closestPointToPointParameter(e, t) { Jc.subVectors(e, this.start), Kc.subVectors(this.end, this.start), e = Kc.dot(Kc); let i = Kc.dot(Jc) / e; return i = t ? f(i, 0, 1) : i } closestPointToPoint(e, t, i) { return e = this.closestPointToPointParameter(e, t), this.delta(i).multiplyScalar(e).add(this.start) } applyMatrix4(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this } equals(e) { return e.start.equals(this.start) && e.end.equals(this.end) } clone() { return (new this.constructor).copy(this) } } class eh extends u { constructor(e) { super(), this.material = e, this.render = function () { }, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0 } } eh.prototype.isImmediateRenderObject = !0; const th = new Le, ih = new Le, rh = new Pe, nh = new Pe; class ah extends Co { constructor(e) { const t = function t(i) { const r = []; i && i.isBone && r.push(i); for (let e = 0; e < i.children.length; e++)r.push.apply(r, t(i.children[e])); return r }(e), i = new S, r = [], n = [], a = new y(0, 0, 1), o = new y(0, 1, 0); for (let e = 0; e < t.length; e++) { const i = t[e]; i.parent && i.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), n.push(a.r, a.g, a.b), n.push(o.r, o.g, o.b)) } i.setAttribute("position", new G(r, 3)), i.setAttribute("color", new G(n, 3)), super(i, new v({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } updateMatrixWorld(e) { const i = this.bones, t = this.geometry, r = t.getAttribute("position"); nh.copy(this.root.matrixWorld).invert(); for (let e = 0, t = 0; e < i.length; e++) { var n = i[e]; n.parent && n.parent.isBone && (rh.multiplyMatrices(nh, n.matrixWorld), ih.setFromMatrixPosition(rh), r.setXYZ(t, ih.x, ih.y, ih.z), rh.multiplyMatrices(nh, n.parent.matrixWorld), ih.setFromMatrixPosition(rh), r.setXYZ(t + 1, ih.x, ih.y, ih.z), t += 2) } t.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e) } } const oh = new Le, sh = new y, lh = new y; class ch extends Co { constructor(e = 10, r = 10, n = 4473924, a = 8947848) { n = new y(n), a = new y(a); const o = r / 2, s = e / r, l = e / 2, c = [], h = []; for (let e = 0, t = 0, i = -l; e <= r; e++, i += s) { c.push(-l, 0, i, l, 0, i), c.push(i, 0, -l, i, 0, l); const r = e === o ? n : a; r.toArray(h, t), t += 3, r.toArray(h, t), t += 3, r.toArray(h, t), t += 3, r.toArray(h, t), t += 3 } const t = new S; t.setAttribute("position", new G(c, 3)), t.setAttribute("color", new G(h, 3)), super(t, new v({ vertexColors: !0, toneMapped: !1 })), this.type = "GridHelper" } } const hh = new Le, uh = new Le, dh = new Le, ph = new Le, d = new Gi; function p(i, e, t, r, n, a, o) { ph.set(n, a, o).unproject(r); var s = e[i]; if (void 0 !== s) { const i = t.getAttribute("position"); for (let e = 0, t = s.length; e < t; e++)i.setXYZ(s[e], ph.x, ph.y, ph.z) } } const fh = new Oe; class mh extends Co { constructor(e, t = 16776960) { const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), n = new S; n.setIndex(new P(i, 1)), n.setAttribute("position", new P(r, 3)), super(n, new v({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update() } update(e) { if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && fh.setFromObject(this.object), !fh.isEmpty()) { const t = fh.min, i = fh.max, r = this.geometry.attributes.position, n = r.array; n[0] = i.x, n[1] = i.y, n[2] = i.z, n[3] = t.x, n[4] = i.y, n[5] = i.z, n[6] = t.x, n[7] = t.y, n[8] = i.z, n[9] = i.x, n[10] = t.y, n[11] = i.z, n[12] = i.x, n[13] = i.y, n[14] = t.z, n[15] = t.x, n[16] = i.y, n[17] = t.z, n[18] = t.x, n[19] = t.y, n[20] = t.z, n[21] = i.x, n[22] = t.y, n[23] = t.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } } setFromObject(e) { return this.object = e, this.update(), this } copy(e) { return Co.prototype.copy.call(this, e), this.object = e.object, this } } const vh = new Le; let gh, xh; class yh extends Co { constructor(e = 1) { const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = new S; i.setAttribute("position", new G(t, 3)), i.setAttribute("color", new G([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(i, new v({ vertexColors: !0, toneMapped: !1 })), this.type = "AxesHelper" } setColors(e, t, i) { const r = new y, n = this.geometry.attributes.color.array; return r.set(e), r.toArray(n, 0), r.toArray(n, 3), r.set(t), r.toArray(n, 6), r.toArray(n, 9), r.set(i), r.toArray(n, 12), r.toArray(n, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose() { this.geometry.dispose(), this.material.dispose() } } const _h = new Float32Array(1), bh = new Int32Array(_h.buffer); es.create = function (e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(es.prototype), (e.prototype.constructor = e).prototype.getPoint = t, e }, Il.prototype.fromPoints = function (e) { return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) }, ch.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, ah.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, l.prototype.extractUrlBase = function (e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ic.extractUrlBase(e) }, l.Handlers = { add: function () { console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.") }, get: function () { console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.") } }, Zc.prototype.center = function (e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Zc.prototype.empty = function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Zc.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Zc.prototype.size = function (e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) }, Oe.prototype.center = function (e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Oe.prototype.empty = function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, Oe.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, Oe.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, Oe.prototype.size = function (e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) }, at.prototype.empty = function () { return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, $i.prototype.setFromMatrix = function (e) { return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e) }, $c.prototype.center = function (e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, g.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, g.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, g.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, g.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, g.prototype.applyToVector3Array = function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") }, g.prototype.getInverse = function (e) { return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, Pe.prototype.extractPosition = function (e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, Pe.prototype.flattenToArrayOffset = function (e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, Pe.prototype.getPosition = function () { return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Le).setFromMatrixColumn(this, 3) }, Pe.prototype.setRotationFromQuaternion = function (e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, Pe.prototype.multiplyToArray = function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, Pe.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Pe.prototype.multiplyVector4 = function (e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Pe.prototype.multiplyVector3Array = function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, Pe.prototype.rotateAxis = function (e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, Pe.prototype.crossVector = function (e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Pe.prototype.translate = function () { console.error("THREE.Matrix4: .translate() has been removed.") }, Pe.prototype.rotateX = function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, Pe.prototype.rotateY = function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, Pe.prototype.rotateZ = function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, Pe.prototype.rotateByAxis = function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, Pe.prototype.applyToBufferAttribute = function (e) { return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, Pe.prototype.applyToVector3Array = function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, Pe.prototype.makeFrustum = function (e, t, i, r, n, a) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, r, i, n, a) }, Pe.prototype.getInverse = function (e) { return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e).invert() }, Zi.prototype.isIntersectionLine = function (e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, m.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, m.prototype.inverse = function () { return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert() }, pt.prototype.isIntersectionBox = function (e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, pt.prototype.isIntersectionPlane = function (e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, pt.prototype.isIntersectionSphere = function (e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, x.prototype.area = function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, x.prototype.barycoordFromPoint = function (e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, x.prototype.midpoint = function (e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, x.prototypenormal = function (e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, x.prototype.plane = function (e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) }, x.barycoordFromPoint = function (e, t, i, r, n) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), x.getBarycoord(e, t, i, r, n) }, x.normal = function (e, t, i, r) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), x.getNormal(e, t, i, r) }, Nl.prototype.extractAllPoints = function (e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, Nl.prototype.extrude = function (e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Us(this, e) }, Nl.prototype.makeGeometry = function (e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new js(this, e) }, k.prototype.fromAttribute = function (e, t, i) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, k.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, k.prototype.lengthManhattan = function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Le.prototype.setEulerFromRotationMatrix = function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, Le.prototype.setEulerFromQuaternion = function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, Le.prototype.getPositionFromMatrix = function (e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, Le.prototype.getScaleFromMatrix = function (e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, Le.prototype.getColumnFromMatrix = function (e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, Le.prototype.applyProjection = function (e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, Le.prototype.fromAttribute = function (e, t, i) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, Le.prototype.distanceToManhattan = function (e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, Le.prototype.lengthManhattan = function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, Re.prototype.fromAttribute = function (e, t, i) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, Re.prototype.lengthManhattan = function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() }, u.prototype.getChildByName = function (e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, u.prototype.renderDepth = function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, u.prototype.translate = function (e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, u.prototype.getWorldRotation = function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") }, u.prototype.applyMatrix = function (e) { return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(u.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), M.prototype.setDrawMode = function () { console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") }, Object.defineProperties(M.prototype, { drawMode: { get: function () { return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0 }, set: function () { console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.") } } }), uo.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, C.prototype.setLens = function (e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(Hl.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function (e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function (e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function (e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function (e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function (e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function (e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function (e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(P.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, dynamic: { get: function () { return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === se }, set: function () { console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(se) } } }), P.prototype.setDynamic = function (e) { return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? se : oe), this }, P.prototype.copyIndicesArray = function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") }, P.prototype.setArray = function () { console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, S.prototype.addIndex = function (e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, S.prototype.addAttribute = function (e, t) { return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e, new P(t, arguments[2]))) }, S.prototype.addDrawCall = function (e, t, i) { void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, S.prototype.clearDrawCalls = function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, S.prototype.computeOffsets = function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") }, S.prototype.removeAttribute = function (e) { return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e) }, S.prototype.applyMatrix = function (e) { return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e) }, Object.defineProperties(S.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), za.prototype.setDynamic = function (e) { return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === e ? se : oe), this }, za.prototype.setArray = function () { console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers") }, Us.prototype.getArrays = function () { console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.") }, Us.prototype.addShapeList = function () { console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.") }, Us.prototype.addShape = function () { console.error("THREE.ExtrudeGeometry: .addShape() has been removed.") }, Ua.prototype.dispose = function () { console.error("THREE.Scene: .dispose() has been removed.") }, Wc.prototype.onUpdate = function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this }, Object.defineProperties(t.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new y } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e } }, stencilMask: { get: function () { return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask }, set: function (e) { console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e } }, vertexTangents: { get: function () { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") }, set: function () { console.warn("THREE." + this.type + ": .vertexTangents has been removed.") } } }), Object.defineProperties(ki.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), o.prototype.clearTarget = function (e, t, i, r) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, r) }, o.prototype.animate = function (e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, o.prototype.getCurrentRenderTarget = function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, o.prototype.getMaxAnisotropy = function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, o.prototype.getPrecision = function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, o.prototype.resetGLState = function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, o.prototype.supportsFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, o.prototype.supportsHalfFloatTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, o.prototype.supportsStandardDerivatives = function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, o.prototype.supportsCompressedTextureS3TC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, o.prototype.supportsCompressedTexturePVRTC = function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, o.prototype.supportsBlendMinMax = function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, o.prototype.supportsVertexTextures = function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, o.prototype.supportsInstancedArrays = function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, o.prototype.enableScissorTest = function (e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, o.prototype.initMaterial = function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, o.prototype.addPrePlugin = function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, o.prototype.addPostPlugin = function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, o.prototype.updateShadowMap = function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, o.prototype.setFaceCulling = function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, o.prototype.allocTextureUnit = function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, o.prototype.setTexture = function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, o.prototype.setTexture2D = function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, o.prototype.setTextureCube = function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") }, o.prototype.getActiveMipMapLevel = function () { return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel() }, Object.defineProperties(o.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } }, context: { get: function () { return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext() } }, vr: { get: function () { return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr } }, gammaInput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1 }, set: function () { console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.") } }, gammaOutput: { get: function () { return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1 }, set: function (e) { console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === e ? 3001 : Be } }, toneMappingWhitePoint: { get: function () { return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1 }, set: function () { console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.") } } }), Object.defineProperties(Sa.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Ue.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), Sc.prototype.load = function (e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); const t = this; return (new fc).load(e, function (e) { t.setBuffer(e) }), this }, Pc.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Wi.prototype.updateCubeMap = function (e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }, Wi.prototype.clear = function (e, t, i, r) { return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e, t, i, r) }, be.crossOrigin = void 0, be.loadTexture = function (e, t, i, r) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); const n = new Fl, a = (n.setCrossOrigin(this.crossOrigin), n.load(e, i, void 0, r)); return t && (a.mapping = t), a }, be.loadTextureCube = function (e, t, i, r) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); const n = new Pl, a = (n.setCrossOrigin(this.crossOrigin), n.load(e, i, void 0, r)); return t && (a.mapping = t), a }, be.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, be.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; var wh = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js") } }; "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "131" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "131"), e.ACESFilmicToneMapping = 4, e.AddEquation = X, e.AddOperation = 2, e.AdditiveAnimationBlendMode = 2501, e.AdditiveBlending = 2, e.AlphaFormat = 1021, e.AlwaysDepth = 1, e.AlwaysStencilFunc = 519, e.AmbientLight = Jl, e.AmbientLightProbe = vc, e.AnimationClip = El, e.AnimationLoader = class extends l { constructor(e) { super(e) } load(t, i, e, r) { const n = this, a = new Rl(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function (e) { try { i(n.parse(JSON.parse(e))) } catch (e) { r ? r(e) : console.error(e), n.manager.itemError(t) } }, e, r) } parse(t) { const i = []; for (let e = 0; e < t.length; e++) { var r = El.parse(t[e]); i.push(r) } return i } }, e.AnimationMixer = Gc, e.AnimationObjectGroup = Vc, e.AnimationUtils = b, e.ArcCurve = is, e.ArrayCamera = La, e.ArrowHelper = class extends u { constructor(e = new Le(0, 0, 1), t = new Le(0, 0, 0), i = 1, r = 16776960, n = .2 * i, a = .2 * n) { super(), this.type = "ArrowHelper", void 0 === gh && ((gh = new S).setAttribute("position", new G([0, 0, 0, 0, 1, 0], 3)), (xh = new jo(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Ro(gh, new v({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new M(xh, new ti({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, n, a) } setDirection(e) { .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (vh.set(e.z, 0, -e.x).normalize(), e = Math.acos(e.y), this.quaternion.setFromAxisAngle(vh, e)) } setLength(e, t = .2 * e, i = .2 * t) { this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix() } setColor(e) { this.line.material.color.set(e), this.cone.material.color.set(e) } copy(e) { return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this } }, e.Audio = Sc, e.AudioAnalyser = Pc, e.AudioContext = pc, e.AudioListener = class extends u { constructor() { super(), this.type = "AudioListener", this.context = pc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new yc } getInput() { return this.gain } removeFilter() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this } getFilter() { return this.filter } setFilter(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this } getMasterVolume() { return this.gain.gain.value } setMasterVolume(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } updateMatrixWorld(e) { super.updateMatrixWorld(e); const t = this.context.listener, i = this.up; if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(bc, wc, Ec), Tc.set(0, 0, -1).applyQuaternion(wc), t.positionX) { const e = this.context.currentTime + this.timeDelta; t.positionX.linearRampToValueAtTime(bc.x, e), t.positionY.linearRampToValueAtTime(bc.y, e), t.positionZ.linearRampToValueAtTime(bc.z, e), t.forwardX.linearRampToValueAtTime(Tc.x, e), t.forwardY.linearRampToValueAtTime(Tc.y, e), t.forwardZ.linearRampToValueAtTime(Tc.z, e), t.upX.linearRampToValueAtTime(i.x, e), t.upY.linearRampToValueAtTime(i.y, e), t.upZ.linearRampToValueAtTime(i.z, e) } else t.setPosition(bc.x, bc.y, bc.z), t.setOrientation(Tc.x, Tc.y, Tc.z, i.x, i.y, i.z) } }, e.AudioLoader = fc, e.AxesHelper = yh, e.AxisHelper = function (e) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new yh(e) }, e.BackSide = 1, e.BasicDepthPacking = 3200, e.BasicShadowMap = 0, e.BinaryTextureLoader = function (e) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Cl(e) }, e.Bone = po, e.BooleanKeyframeTrack = vl, e.BoundingBoxHelper = function (e, t) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new mh(e, t) }, e.Box2 = Zc, e.Box3 = Oe, e.Box3Helper = class extends Co { constructor(e, t = 16776960) { const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new S; r.setIndex(new P(i, 1)), r.setAttribute("position", new G([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new v({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld(e) { const t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e)) } }, e.BoxBufferGeometry = zi, e.BoxGeometry = zi, e.BoxHelper = mh, e.BufferAttribute = P, e.BufferGeometry = S, e.BufferGeometryLoader = ac, e.ByteType = 1010, e.Cache = Tl, e.Camera = Gi, e.CameraHelper = class extends Co { constructor(e) { const t = new S, i = new v({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], n = [], a = {}, o = new y(16755200), s = new y(16711680), l = new y(43775), c = new y(16777215), h = new y(3355443); function u(e, t, i) { d(e, i), d(t, i) } function d(e, t) { r.push(0, 0, 0), n.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(r.length / 3 - 1) } u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), t.setAttribute("position", new G(r, 3)), t.setAttribute("color", new G(n, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update() } update() { const e = this.geometry, t = this.pointMap; d.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), p("c", t, e, d, 0, 0, -1), p("t", t, e, d, 0, 0, 1), p("n1", t, e, d, -1, -1, -1), p("n2", t, e, d, 1, -1, -1), p("n3", t, e, d, -1, 1, -1), p("n4", t, e, d, 1, 1, -1), p("f1", t, e, d, -1, -1, 1), p("f2", t, e, d, 1, -1, 1), p("f3", t, e, d, -1, 1, 1), p("f4", t, e, d, 1, 1, 1), p("u1", t, e, d, .7, 1.1, -1), p("u2", t, e, d, -.7, 1.1, -1), p("u3", t, e, d, 0, 2, -1), p("cf1", t, e, d, -1, 0, 1), p("cf2", t, e, d, 1, 0, 1), p("cf3", t, e, d, 0, -1, 1), p("cf4", t, e, d, 0, 1, 1), p("cn1", t, e, d, -1, 0, -1), p("cn2", t, e, d, 1, 0, -1), p("cn3", t, e, d, 0, -1, -1), p("cn4", t, e, d, 0, 1, -1), e.getAttribute("position").needsUpdate = !0 } dispose() { this.geometry.dispose(), this.material.dispose() } }, e.CanvasRenderer = function () { console.error("THREE.CanvasRenderer has been removed") }, e.CanvasTexture = ko, e.CatmullRomCurve3 = ls, e.CineonToneMapping = 3, e.CircleBufferGeometry = Wo, e.CircleGeometry = Wo, e.ClampToEdgeWrapping = Ce, e.Clock = yc, e.Color = y, e.ColorKeyframeTrack = gl, e.CompressedTexture = Vo, e.CompressedTextureLoader = class extends l { constructor(e) { super(e) } load(i, r, n, a) { const o = this, s = [], l = new Vo, c = new Rl(this.manager); c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(o.withCredentials); let h = 0; if (Array.isArray(i)) for (let e = 0, t = i.length; e < t; ++e)!function (t) { c.load(i[t], function (e) { e = o.parse(e, !0), s[t] = { width: e.width, height: e.height, format: e.format, mipmaps: e.mipmaps }, 6 === (h += 1) && (1 === e.mipmapCount && (l.minFilter = U), l.image = s, l.format = e.format, l.needsUpdate = !0, r && r(l)) }, n, a) }(e); else c.load(i, function (e) { var i = o.parse(e, !0); if (i.isCubemap) { const e = i.mipmaps.length / i.mipmapCount; for (let t = 0; t < e; t++) { s[t] = { mipmaps: [] }; for (let e = 0; e < i.mipmapCount; e++)s[t].mipmaps.push(i.mipmaps[t * i.mipmapCount + e]), s[t].format = i.format, s[t].width = i.width, s[t].height = i.height } l.image = s } else l.image.width = i.width, l.image.height = i.height, l.mipmaps = i.mipmaps; 1 === i.mipmapCount && (l.minFilter = U), l.format = i.format, l.needsUpdate = !0, r && r(l) }, n, a); return l } }, e.ConeBufferGeometry = Xo, e.ConeGeometry = Xo, e.CubeCamera = Wi, e.CubeReflectionMapping = A, e.CubeRefractionMapping = R, e.CubeTexture = ji, e.CubeTextureLoader = Pl, e.CubeUVReflectionMapping = D, e.CubeUVRefractionMapping = I, e.CubicBezierCurve = ds, e.CubicBezierCurve3 = ps, e.CubicInterpolant = dl, e.CullFaceBack = 1, e.CullFaceFront = 2, e.CullFaceFrontBack = 3, e.CullFaceNone = 0, e.Curve = es, e.CurvePath = Dl, e.CustomBlending = 5, e.CustomToneMapping = 5, e.CylinderBufferGeometry = jo, e.CylinderGeometry = jo, e.Cylindrical = class { constructor(e = 1, t = 0, i = 0) { return this.radius = e, this.theta = t, this.y = i, this } set(e, t, i) { return this.radius = e, this.theta = t, this.y = i, this } copy(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this } clone() { return (new this.constructor).copy(this) } }, e.DataTexture = fo, e.DataTexture2DArray = Wr, e.DataTexture3D = jr, e.DataTextureLoader = Cl, e.DataUtils = class { static toHalfFloat(e) { _h[0] = e; let t = (e = bh[0]) >> 16 & 32768, i = e >> 12 & 2047; var r = e >> 23 & 255; return r < 103 || (142 < r ? t = 31744 | t | ((255 == r ? 0 : 1) && 8388607 & e) : r < 113 ? (i |= 2048, t |= (i >> 114 - r) + (i >> 113 - r & 1)) : t = (t |= r - 112 << 10 | i >> 1) + (1 & i)), t } }, e.DecrementStencilOp = 7683, e.DecrementWrapStencilOp = 34056, e.DefaultLoadingManager = Ml, e.DepthFormat = J, e.DepthStencilFormat = K, e.DepthTexture = Go, e.DirectionalLight = Zl, e.DirectionalLightHelper = class extends u { constructor(e, t, i) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1); let r = new S; r.setAttribute("position", new G([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)), e = new v({ fog: !1, toneMapped: !1 }), this.lightPlane = new Ro(r, e), this.add(this.lightPlane), (r = new S).setAttribute("position", new G([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ro(r, e), this.add(this.targetLine), this.update() } dispose() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update() { hh.setFromMatrixPosition(this.light.matrixWorld), uh.setFromMatrixPosition(this.light.target.matrixWorld), dh.subVectors(uh, hh), this.lightPlane.lookAt(uh), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(uh), this.targetLine.scale.z = dh.length() } }, e.DiscreteInterpolant = fl, e.DodecahedronBufferGeometry = Yo, e.DodecahedronGeometry = Yo, e.DoubleSide = 2, e.DstAlphaFactor = 206, e.DstColorFactor = 208, e.DynamicBufferAttribute = function (e, t) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new P(e, t).setUsage(se) }, e.DynamicCopyUsage = 35050, e.DynamicDrawUsage = se, e.DynamicReadUsage = 35049, e.EdgesGeometry = $o, e.EdgesHelper = function (e, t) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Co(new $o(e.geometry), new v({ color: void 0 !== t ? t : 16777215 })) }, e.EllipseCurve = ts, e.EqualDepth = 4, e.EqualStencilFunc = 514, e.EquirectangularReflectionMapping = L, e.EquirectangularRefractionMapping = F, e.Euler = Et, e.EventDispatcher = ce, e.ExtrudeBufferGeometry = Us, e.ExtrudeGeometry = Us, e.FaceColors = 1, e.FileLoader = Rl, e.FlatShading = 1, e.Float16BufferAttribute = hi, e.Float32Attribute = function (e, t) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new G(e, t) }, e.Float32BufferAttribute = G, e.Float64Attribute = function (e, t) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ui(e, t) }, e.Float64BufferAttribute = ui, e.FloatType = Ie, e.Fog = Ba, e.FogExp2 = Ha, e.Font = uc, e.FontLoader = class extends l { constructor(e) { super(e) } load(e, r, t, i) { const n = this, a = new Rl(this.manager); a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(n.withCredentials), a.load(e, function (t) { let i; try { i = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2)) } t = n.parse(i), r && r(t) }, t, i) } parse(e) { return new uc(e) } }, e.FrontSide = 0, e.Frustum = $i, e.GLBufferAttribute = Xc, e.GLSL1 = "100", e.GLSL3 = le, e.GammaEncoding = 3007, e.GreaterDepth = 6, e.GreaterEqualDepth = 5, e.GreaterEqualStencilFunc = 518, e.GreaterStencilFunc = 516, e.GridHelper = ch, e.Group = Pa, e.HalfFloatType = Ne, e.HemisphereLight = Bl, e.HemisphereLightHelper = class extends u { constructor(e, t, i) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i; const r = new ks(t); r.rotateY(.5 * Math.PI), this.material = new ti({ wireframe: !0, fog: !1, toneMapped: !1 }), void 0 === this.color && (this.material.vertexColors = !0), e = r.getAttribute("position"), i = new Float32Array(3 * e.count), r.setAttribute("color", new P(i, 3)), this.add(new M(r, this.material)), this.update() } dispose() { this.children[0].geometry.dispose(), this.children[0].material.dispose() } update() { const e = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { const r = e.geometry.getAttribute("color"); sh.copy(this.light.color), lh.copy(this.light.groundColor); for (let e = 0, t = r.count; e < t; e++) { var i = e < t / 2 ? sh : lh; r.setXYZ(e, i.r, i.g, i.b) } r.needsUpdate = !0 } e.lookAt(oh.setFromMatrixPosition(this.light.matrixWorld).negate()) } }, e.HemisphereLightProbe = mc, e.IcosahedronBufferGeometry = Os, e.IcosahedronGeometry = Os, e.ImageBitmapLoader = cc, e.ImageLoader = Ll, e.ImageUtils = be, e.ImmediateRenderObject = eh, e.IncrementStencilOp = 7682, e.IncrementWrapStencilOp = 34055, e.InstancedBufferAttribute = nc, e.InstancedBufferGeometry = rc, e.InstancedInterleavedBuffer = jc, e.InstancedMesh = wo, e.Int16Attribute = function (e, t) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new oi(e, t) }, e.Int16BufferAttribute = oi, e.Int32Attribute = function (e, t) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new li(e, t) }, e.Int32BufferAttribute = li, e.Int8Attribute = function (e, t) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new ri(e, t) }, e.Int8BufferAttribute = ri, e.IntType = 1013, e.InterleavedBuffer = za, e.InterleavedBufferAttribute = Oa, e.Interpolant = ul, e.InterpolateDiscrete = 2300, e.InterpolateLinear = 2301, e.InterpolateSmooth = 2302, e.InvertStencilOp = 5386, e.JSONLoader = function () { console.error("THREE.JSONLoader has been removed.") }, e.KeepStencilOp = 7680, e.KeyframeTrack = ml, e.LOD = ao, e.LatheBufferGeometry = Vs, e.LatheGeometry = Vs, e.Layers = Tt, e.LensFlare = function () { console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js") }, e.LessDepth = 2, e.LessEqualDepth = 3, e.LessEqualStencilFunc = 515, e.LessStencilFunc = 513, e.Light = Hl, e.LightProbe = ec, e.Line = Ro, e.Line3 = $c, e.LineBasicMaterial = v, e.LineCurve = fs, e.LineCurve3 = ms, e.LineDashedMaterial = cl, e.LineLoop = Fo, e.LinePieces = 1, e.LineSegments = Co, e.LineStrip = 0, e.LinearEncoding = Be, e.LinearFilter = U, e.LinearInterpolant = pl, e.LinearMipMapLinearFilter = 1008, e.LinearMipMapNearestFilter = 1007, e.LinearMipmapLinearFilter = Fe, e.LinearMipmapNearestFilter = j, e.LinearToneMapping = 1, e.Loader = l, e.LoaderUtils = ic, e.LoadingManager = Sl, e.LogLuvEncoding = 3003, e.LoopOnce = 2200, e.LoopPingPong = 2202, e.LoopRepeat = 2201, e.LuminanceAlphaFormat = 1025, e.LuminanceFormat = 1024, e.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, e.Material = t, e.MaterialLoader = tc, e.Math = ye, e.MathUtils = ye, e.Matrix3 = g, e.Matrix4 = Pe, e.MaxEquation = 104, e.Mesh = M, e.MeshBasicMaterial = ti, e.MeshDepthMaterial = Ea, e.MeshDistanceMaterial = Ta, e.MeshFaceMaterial = function (e) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e }, e.MeshLambertMaterial = sl, e.MeshMatcapMaterial = ll, e.MeshNormalMaterial = ol, e.MeshPhongMaterial = nl, e.MeshPhysicalMaterial = rl, e.MeshStandardMaterial = il, e.MeshToonMaterial = al, e.MinEquation = 103, e.MirroredRepeatWrapping = O, e.MixOperation = 1, e.MultiMaterial = function (e = []) { return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, (e.materials = e).clone = function () { return e.slice() }, e }, e.MultiplyBlending = 4, e.MultiplyOperation = 0, e.NearestFilter = Ae, e.NearestMipMapLinearFilter = 1005, e.NearestMipMapNearestFilter = 1004, e.NearestMipmapLinearFilter = W, e.NearestMipmapNearestFilter = V, e.NeverDepth = 0, e.NeverStencilFunc = 512, e.NoBlending = 0, e.NoColors = 0, e.NoToneMapping = 0, e.NormalAnimationBlendMode = 2500, e.NormalBlending = 1, e.NotEqualDepth = 7, e.NotEqualStencilFunc = 517, e.NumberKeyframeTrack = xl, e.Object3D = u, e.ObjectLoader = class extends l { constructor(e) { super(e) } load(r, n, e, a) { const o = this, t = "" === this.path ? ic.extractUrlBase(r) : this.path, i = (this.resourcePath = this.resourcePath || t, new Rl(this.manager)); i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(r, function (e) { let t = null; try { t = JSON.parse(e) } catch (e) { return void 0 !== a && a(e), void console.error("THREE:ObjectLoader: Can't parse " + r + ".", e.message) } const i = t.metadata; void 0 !== i && void 0 !== i.type && "geometry" !== i.type.toLowerCase() ? o.parse(t, n) : console.error("THREE.ObjectLoader: Can't load " + r) }, e, a) } async loadAsync(e, t) { var i = "" === this.path ? ic.extractUrlBase(e) : this.path; this.resourcePath = this.resourcePath || i; const r = new Rl(this.manager), n = (r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), await r.loadAsync(e, t)), a = JSON.parse(n), o = a.metadata; if (void 0 === o || void 0 === o.type || "geometry" === o.type.toLowerCase()) throw new Error("THREE.ObjectLoader: Can't load " + e); return this.parseAsync(a) } parse(e, t) { const i = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), n = this.parseGeometries(e.geometries, r), a = this.parseImages(e.images, function () { void 0 !== t && t(l) }), o = this.parseTextures(e.textures, a), s = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, n, s, o, i), c = this.parseSkeletons(e.skeletons, l); if (this.bindSkeletons(l, c), void 0 !== t) { let e = !1; for (const t in a) if (a[t] instanceof HTMLImageElement) { e = !0; break } !1 === e && t(l) } return l } async parseAsync(e) { var t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, i), r = await this.parseImagesAsync(e.images), r = this.parseTextures(e.textures, r), n = this.parseMaterials(e.materials, r), i = this.parseObject(e.object, i, n, r, t), n = this.parseSkeletons(e.skeletons, i); return this.bindSkeletons(i, n), i } parseShapes(i) { const r = {}; if (void 0 !== i) for (let e = 0, t = i.length; e < t; e++) { var n = (new Nl).fromJSON(i[e]); r[n.uuid] = n } return r } parseSkeletons(i, e) { const r = {}, n = {}; if (e.traverse(function (e) { e.isBone && (n[e.uuid] = e) }), void 0 !== i) for (let e = 0, t = i.length; e < t; e++) { var a = (new go).fromJSON(i[e], n); r[a.uuid] = a } return r } parseGeometries(i, r) { const n = {}; if (void 0 !== i) { const o = new ac; for (let t = 0, e = i.length; t < e; t++) { let e; var a = i[t]; switch (a.type) { case "BufferGeometry": case "InstancedBufferGeometry": e = o.parse(a); break; case "Geometry": console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported."); break; default: a.type in el ? e = el[a.type].fromJSON(a, r) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`) }e.uuid = a.uuid, void 0 !== a.name && (e.name = a.name), !0 === e.isBufferGeometry && void 0 !== a.userData && (e.userData = a.userData), n[a.uuid] = e } } return n } parseMaterials(i, e) { const r = {}, n = {}; if (void 0 !== i) { const o = new tc; o.setTextures(e); for (let e = 0, t = i.length; e < t; e++) { var a = i[e]; if ("MultiMaterial" === a.type) { const i = []; for (let e = 0; e < a.materials.length; e++) { const n = a.materials[e]; void 0 === r[n.uuid] && (r[n.uuid] = o.parse(n)), i.push(r[n.uuid]) } n[a.uuid] = i } else void 0 === r[a.uuid] && (r[a.uuid] = o.parse(a)), n[a.uuid] = r[a.uuid] } } return n } parseAnimations(t) { const i = {}; if (void 0 !== t) for (let e = 0; e < t.length; e++) { var r = t[e], r = El.parse(r); i[r.uuid] = r } return i } parseImages(i, r) { const n = this, a = {}; let o; function s(e) { var t, i; return "string" == typeof e ? (i = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(t = e) ? t : n.resourcePath + t, n.manager.itemStart(i), o.load(i, function () { n.manager.itemEnd(i) }, void 0, function () { n.manager.itemError(i), n.manager.itemEnd(i) })) : e.data ? { data: fi(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== i && 0 < i.length) { const n = new Sl(r); (o = new Ll(n)).setCrossOrigin(this.crossOrigin); for (let e = 0, t = i.length; e < t; e++) { const n = i[e], o = n.url; if (Array.isArray(o)) { a[n.uuid] = []; for (let e = 0, t = o.length; e < t; e++) { const r = s(o[e]); null !== r && (r instanceof HTMLImageElement ? a[n.uuid].push(r) : a[n.uuid].push(new fo(r.data, r.width, r.height))) } } else { const i = s(n.url); null !== i && (a[n.uuid] = i) } } } return a } async parseImagesAsync(i) { const r = this, n = {}; let a; async function o(e) { var t; return "string" == typeof e ? (t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(t = e) ? t : r.resourcePath + t, a.loadAsync(t)) : e.data ? { data: fi(e.type, e.data), width: e.width, height: e.height } : null } if (void 0 !== i && 0 < i.length) { (a = new Ll(this.manager)).setCrossOrigin(this.crossOrigin); for (let e = 0, t = i.length; e < t; e++) { const a = i[e], s = a.url; if (Array.isArray(s)) { n[a.uuid] = []; for (let e = 0, t = s.length; e < t; e++) { const r = s[e], l = await o(r); null !== l && (l instanceof HTMLImageElement ? n[a.uuid].push(l) : n[a.uuid].push(new fo(l.data, l.width, l.height))) } } else { const i = await o(a.url); null !== i && (n[a.uuid] = i) } } } return n } parseTextures(i, r) { function n(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } const a = {}; if (void 0 !== i) for (let t = 0, e = i.length; t < e; t++) { var o = i[t]; let e; void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === r[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image); var s = r[o.image]; Array.isArray(s) ? (e = new ji(s), 6 === s.length && (e.needsUpdate = !0)) : (e = s && s.data ? new fo(s.data, s.width, s.height) : new h(s), s && (e.needsUpdate = !0)), e.uuid = o.uuid, void 0 !== o.name && (e.name = o.name), void 0 !== o.mapping && (e.mapping = n(o.mapping, oc)), void 0 !== o.offset && e.offset.fromArray(o.offset), void 0 !== o.repeat && e.repeat.fromArray(o.repeat), void 0 !== o.center && e.center.fromArray(o.center), void 0 !== o.rotation && (e.rotation = o.rotation), void 0 !== o.wrap && (e.wrapS = n(o.wrap[0], sc), e.wrapT = n(o.wrap[1], sc)), void 0 !== o.format && (e.format = o.format), void 0 !== o.type && (e.type = o.type), void 0 !== o.encoding && (e.encoding = o.encoding), void 0 !== o.minFilter && (e.minFilter = n(o.minFilter, lc)), void 0 !== o.magFilter && (e.magFilter = n(o.magFilter, lc)), void 0 !== o.anisotropy && (e.anisotropy = o.anisotropy), void 0 !== o.flipY && (e.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (e.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (e.unpackAlignment = o.unpackAlignment), a[o.uuid] = e } return a } parseObject(e, t, a, i, r) { let n, o, s; function l(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] } function c(i) { if (void 0 !== i) { if (Array.isArray(i)) { const n = []; for (let e = 0, t = i.length; e < t; e++) { var r = i[e]; void 0 === a[r] && console.warn("THREE.ObjectLoader: Undefined material", r), n.push(a[r]) } return n } return void 0 === a[i] && console.warn("THREE.ObjectLoader: Undefined material", i), a[i] } } function h(e) { return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined texture", e), i[e] } switch (e.type) { case "Scene": n = new Ua, void 0 !== e.background && (Number.isInteger(e.background) ? n.background = new y(e.background) : n.background = h(e.background)), void 0 !== e.environment && (n.environment = h(e.environment)), void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new Ba(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new Ha(e.fog.color, e.fog.density))); break; case "PerspectiveCamera": n = new C(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (n.focus = e.focus), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset), void 0 !== e.view && (n.view = Object.assign({}, e.view)); break; case "OrthographicCamera": n = new hr(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.view && (n.view = Object.assign({}, e.view)); break; case "AmbientLight": n = new Jl(e.color, e.intensity); break; case "DirectionalLight": n = new Zl(e.color, e.intensity); break; case "PointLight": n = new Yl(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": n = new Kl(e.color, e.intensity, e.width, e.height); break; case "SpotLight": n = new Gl(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": n = new Bl(e.color, e.groundColor, e.intensity); break; case "LightProbe": n = (new ec).fromJSON(e); break; case "SkinnedMesh": o = l(e.geometry), s = c(e.material), n = new uo(o, s), void 0 !== e.bindMode && (n.bindMode = e.bindMode), void 0 !== e.bindMatrix && n.bindMatrix.fromArray(e.bindMatrix), void 0 !== e.skeleton && (n.skeleton = e.skeleton); break; case "Mesh": o = l(e.geometry), s = c(e.material), n = new M(o, s); break; case "InstancedMesh": o = l(e.geometry), s = c(e.material); const t = e.count, a = e.instanceMatrix, i = e.instanceColor; (n = new wo(o, s, t)).instanceMatrix = new P(new Float32Array(a.array), 16), void 0 !== i && (n.instanceColor = new P(new Float32Array(i.array), i.itemSize)); break; case "LOD": n = new ao; break; case "Line": n = new Ro(l(e.geometry), c(e.material)); break; case "LineLoop": n = new Fo(l(e.geometry), c(e.material)); break; case "LineSegments": n = new Co(l(e.geometry), c(e.material)); break; case "PointCloud": case "Points": n = new Uo(l(e.geometry), c(e.material)); break; case "Sprite": n = new to(c(e.material)); break; case "Group": n = new Pa; break; case "Bone": n = new po; break; default: n = new u }if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.castShadow && (n.castShadow = e.castShadow), void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias), void 0 !== e.shadow.normalBias && (n.shadow.normalBias = e.shadow.normalBias), void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.layers && (n.layers.mask = e.layers), void 0 !== e.children) { const o = e.children; for (let e = 0; e < o.length; e++)n.add(this.parseObject(o[e], t, a, i, r)) } if (void 0 !== e.animations) { const t = e.animations; for (let e = 0; e < t.length; e++) { const a = t[e]; n.animations.push(r[a]) } } if ("LOD" === e.type) { void 0 !== e.autoUpdate && (n.autoUpdate = e.autoUpdate); const t = e.levels; for (let e = 0; e < t.length; e++) { const a = t[e], i = n.getObjectByProperty("uuid", a.object); void 0 !== i && n.addLevel(i, a.distance) } } return n } bindSkeletons(e, i) { 0 !== Object.keys(i).length && e.traverse(function (e) { var t; !0 === e.isSkinnedMesh && void 0 !== e.skeleton && (void 0 === (t = i[e.skeleton]) ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(t, e.bindMatrix)) }) } setTexturePath(e) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e) } }, e.ObjectSpaceNormalMap = 1, e.OctahedronBufferGeometry = ks, e.OctahedronGeometry = ks, e.OneFactor = 201, e.OneMinusDstAlphaFactor = 207, e.OneMinusDstColorFactor = 209, e.OneMinusSrcAlphaFactor = 205, e.OneMinusSrcColorFactor = 203, e.OrthographicCamera = hr, e.PCFShadowMap = 1, e.PCFSoftShadowMap = 2, e.PMREMGenerator = Rr, e.ParametricBufferGeometry = Gs, e.ParametricGeometry = Gs, e.Particle = function (e) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new to(e) }, e.ParticleBasicMaterial = function (e) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Do(e) }, e.ParticleSystem = function (e, t) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Uo(e, t) }, e.ParticleSystemMaterial = function (e) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Do(e) }, e.Path = Il, e.PerspectiveCamera = C, e.Plane = Zi, e.PlaneBufferGeometry = ir, e.PlaneGeometry = ir, e.PlaneHelper = class extends Ro { constructor(e, t = 1, i = 16776960) { const r = i, n = new S, a = (n.setAttribute("position", new G([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), n.computeBoundingSphere(), super(n, new v({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t, new S); a.setAttribute("position", new G([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new M(a, new ti({ color: r, opacity: .2, transparent: !0, depthWrite: !1, toneMapped: !1 }))) } updateMatrixWorld(e) { let t = -this.plane.constant; Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? 1 : 0, this.lookAt(this.plane.normal), super.updateMatrixWorld(e) } }, e.PointCloud = function (e, t) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Uo(e, t) }, e.PointCloudMaterial = function (e) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Do(e) }, e.PointLight = Yl, e.PointLightHelper = class extends M { constructor(e, t, i) { super(new Xs(t, 4, 2), new ti({ wireframe: !0, fog: !1, toneMapped: !1 })), this.light = e, this.light.updateMatrixWorld(), this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose() { this.geometry.dispose(), this.material.dispose() } update() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } }, e.Points = Uo, e.PointsMaterial = Do, e.PolarGridHelper = class extends Co { constructor(t = 10, i = 16, r = 8, n = 64, a = 4473924, o = 8947848) { a = new y(a), o = new y(o); const s = [], l = []; for (let e = 0; e <= i; e++) { const n = e / i * (2 * Math.PI), p = Math.sin(n) * t, f = Math.cos(n) * t; s.push(0, 0, 0), s.push(p, 0, f); var c = 1 & e ? a : o; l.push(c.r, c.g, c.b), l.push(c.r, c.g, c.b) } for (let e = 0; e <= r; e++) { const p = 1 & e ? a : o, m = t - t / r * e; for (let e = 0; e < n; e++) { var h = e / n * (2 * Math.PI), u = Math.sin(h) * m, d = Math.cos(h) * m; s.push(u, 0, d), l.push(p.r, p.g, p.b), h = (e + 1) / n * (2 * Math.PI), u = Math.sin(h) * m, d = Math.cos(h) * m, s.push(u, 0, d), l.push(p.r, p.g, p.b) } } const p = new S; p.setAttribute("position", new G(s, 3)), p.setAttribute("color", new G(l, 3)), super(p, new v({ vertexColors: !0, toneMapped: !1 })), this.type = "PolarGridHelper" } }, e.PolyhedronBufferGeometry = qo, e.PolyhedronGeometry = qo, e.PositionalAudio = class extends Sc { constructor(e) { super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } getOutput() { return this.panner } getRefDistance() { return this.panner.refDistance } setRefDistance(e) { return this.panner.refDistance = e, this } getRolloffFactor() { return this.panner.rolloffFactor } setRolloffFactor(e) { return this.panner.rolloffFactor = e, this } getDistanceModel() { return this.panner.distanceModel } setDistanceModel(e) { return this.panner.distanceModel = e, this } getMaxDistance() { return this.panner.maxDistance } setMaxDistance(e) { return this.panner.maxDistance = e, this } setDirectionalCone(e, t, i) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this } updateMatrixWorld(e) { if (super.updateMatrixWorld(e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) { this.matrixWorld.decompose(Mc, Ac, Rc), Lc.set(0, 0, 1).applyQuaternion(Ac); const t = this.panner; if (t.positionX) { const e = this.context.currentTime + this.listener.timeDelta; t.positionX.linearRampToValueAtTime(Mc.x, e), t.positionY.linearRampToValueAtTime(Mc.y, e), t.positionZ.linearRampToValueAtTime(Mc.z, e), t.orientationX.linearRampToValueAtTime(Lc.x, e), t.orientationY.linearRampToValueAtTime(Lc.y, e), t.orientationZ.linearRampToValueAtTime(Lc.z, e) } else t.setPosition(Mc.x, Mc.y, Mc.z), t.setOrientation(Lc.x, Lc.y, Lc.z) } } }, e.PropertyBinding = w, e.PropertyMixer = Cc, e.QuadraticBezierCurve = vs, e.QuadraticBezierCurve3 = gs, e.Quaternion = m, e.QuaternionKeyframeTrack = _l, e.QuaternionLinearInterpolant = yl, e.REVISION = "131", e.RGBADepthPacking = 3201, e.RGBAFormat = He, e.RGBAIntegerFormat = 1033, e.RGBA_ASTC_10x10_Format = 37819, e.RGBA_ASTC_10x5_Format = 37816, e.RGBA_ASTC_10x6_Format = 37817, e.RGBA_ASTC_10x8_Format = 37818, e.RGBA_ASTC_12x10_Format = 37820, e.RGBA_ASTC_12x12_Format = 37821, e.RGBA_ASTC_4x4_Format = 37808, e.RGBA_ASTC_5x4_Format = 37809, e.RGBA_ASTC_5x5_Format = 37810, e.RGBA_ASTC_6x5_Format = 37811, e.RGBA_ASTC_6x6_Format = 37812, e.RGBA_ASTC_8x5_Format = 37813, e.RGBA_ASTC_8x6_Format = 37814, e.RGBA_ASTC_8x8_Format = 37815, e.RGBA_BPTC_Format = 36492, e.RGBA_ETC2_EAC_Format = ae, e.RGBA_PVRTC_2BPPV1_Format = re, e.RGBA_PVRTC_4BPPV1_Format = ie, e.RGBA_S3TC_DXT1_Format = H, e.RGBA_S3TC_DXT3_Format = B, e.RGBA_S3TC_DXT5_Format = $, e.RGBDEncoding = 3006, e.RGBEEncoding = 3002, e.RGBEFormat = 1023, e.RGBFormat = Z, e.RGBIntegerFormat = 1032, e.RGBM16Encoding = 3005, e.RGBM7Encoding = 3004, e.RGB_ETC1_Format = 36196, e.RGB_ETC2_Format = ne, e.RGB_PVRTC_2BPPV1_Format = te, e.RGB_PVRTC_4BPPV1_Format = ee, e.RGB_S3TC_DXT1_Format = N, e.RGFormat = 1030, e.RGIntegerFormat = 1031, e.RawShaderMaterial = ur, e.Ray = pt, e.Raycaster = class { constructor(e, t, i = 0, r = 1 / 0) { this.ray = new pt(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new Tt, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set(e, t) { this.ray.set(e, t) } setFromCamera(e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type) } intersectObject(e, t = !1, i = []) { return Yc(e, this, i, t), i.sort(qc), i } intersectObjects(i, r = !1, n = []) { for (let e = 0, t = i.length; e < t; e++)Yc(i[e], this, n, r); return n.sort(qc), n } }, e.RectAreaLight = Kl, e.RedFormat = 1028, e.RedIntegerFormat = 1029, e.ReinhardToneMapping = 2, e.RepeatWrapping = z, e.ReplaceStencilOp = 7681, e.ReverseSubtractEquation = 102, e.RingBufferGeometry = Ws, e.RingGeometry = Ws, e.SRGB8_ALPHA8_ASTC_10x10_Format = 37851, e.SRGB8_ALPHA8_ASTC_10x5_Format = 37848, e.SRGB8_ALPHA8_ASTC_10x6_Format = 37849, e.SRGB8_ALPHA8_ASTC_10x8_Format = 37850, e.SRGB8_ALPHA8_ASTC_12x10_Format = 37852, e.SRGB8_ALPHA8_ASTC_12x12_Format = 37853, e.SRGB8_ALPHA8_ASTC_4x4_Format = 37840, e.SRGB8_ALPHA8_ASTC_5x4_Format = 37841, e.SRGB8_ALPHA8_ASTC_5x5_Format = 37842, e.SRGB8_ALPHA8_ASTC_6x5_Format = 37843, e.SRGB8_ALPHA8_ASTC_6x6_Format = 37844, e.SRGB8_ALPHA8_ASTC_8x5_Format = 37845, e.SRGB8_ALPHA8_ASTC_8x6_Format = 37846, e.SRGB8_ALPHA8_ASTC_8x8_Format = 37847, e.Scene = Ua, e.SceneUtils = wh, e.ShaderChunk = E, e.ShaderLib = rr, e.ShaderMaterial = ki, e.ShadowMaterial = tl, e.Shape = Nl, e.ShapeBufferGeometry = js, e.ShapeGeometry = js, e.ShapePath = hc, e.ShapeUtils = Ns, e.ShortType = 1011, e.Skeleton = go, e.SkeletonHelper = ah, e.SkinnedMesh = uo, e.SmoothShading = 2, e.Sphere = at, e.SphereBufferGeometry = Xs, e.SphereGeometry = Xs, e.Spherical = class { constructor(e = 1, t = 0, i = 0) { return this.radius = e, this.phi = t, this.theta = i, this } set(e, t, i) { return this.radius = e, this.phi = t, this.theta = i, this } copy(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this } makeSafe() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) } setFromCartesianCoords(e, t, i) { return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(f(t / this.radius, -1, 1))), this } clone() { return (new this.constructor).copy(this) } }, e.SphericalHarmonics3 = $l, e.SplineCurve = xs, e.SpotLight = Gl, e.SpotLightHelper = class extends u { constructor(e, t) { super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t; const i = new S, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let e = 0, t = 1; e < 32; e++, t++) { const n = e / 32 * Math.PI * 2, a = t / 32 * Math.PI * 2; r.push(Math.cos(n), Math.sin(n), 1, Math.cos(a), Math.sin(a), 1) } i.setAttribute("position", new G(r, 3)); const n = new v({ fog: !1, toneMapped: !1 }); this.cone = new Co(i, n), this.add(this.cone), this.update() } dispose() { this.cone.geometry.dispose(), this.cone.material.dispose() } update() { this.light.updateMatrixWorld(); var e = this.light.distance || 1e3, t = e * Math.tan(this.light.angle); this.cone.scale.set(t, t, e), th.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(th), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } }, e.Sprite = to, e.SpriteMaterial = Va, e.SrcAlphaFactor = 204, e.SrcAlphaSaturateFactor = 210, e.SrcColorFactor = 202, e.StaticCopyUsage = 35046, e.StaticDrawUsage = oe, e.StaticReadUsage = 35045, e.StereoCamera = class { constructor() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new C, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new C, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null } } update(e) { const t = this._cache; if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) { t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep; const n = e.projectionMatrix.clone(), a = t.eyeSep / 2, o = a * t.near / t.focus, s = t.near * Math.tan(ue * t.fov * .5) / t.zoom; var i, r; xc.elements[12] = -a, gc.elements[12] = a, i = -s * t.aspect + o, r = s * t.aspect + o, n.elements[0] = 2 * t.near / (r - i), n.elements[8] = (r + i) / (r - i), this.cameraL.projectionMatrix.copy(n), i = -s * t.aspect - o, r = s * t.aspect - o, n.elements[0] = 2 * t.near / (r - i), n.elements[8] = (r + i) / (r - i), this.cameraR.projectionMatrix.copy(n) } this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(xc), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(gc) } }, e.StreamCopyUsage = 35042, e.StreamDrawUsage = 35040, e.StreamReadUsage = 35041, e.StringKeyframeTrack = bl, e.SubtractEquation = 101, e.SubtractiveBlending = 3, e.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, e.TangentSpaceNormalMap = 0, e.TetrahedronBufferGeometry = qs, e.TetrahedronGeometry = qs, e.TextBufferGeometry = Ys, e.TextGeometry = Ys, e.Texture = h, e.TextureLoader = Fl, e.TorusBufferGeometry = Qs, e.TorusGeometry = Qs, e.TorusKnotBufferGeometry = Zs, e.TorusKnotGeometry = Zs, e.Triangle = x, e.TriangleFanDrawMode = 2, e.TriangleStripDrawMode = 1, e.TrianglesDrawMode = 0, e.TubeBufferGeometry = Js, e.TubeGeometry = Js, e.UVMapping = 300, e.Uint16Attribute = function (e, t) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new si(e, t) }, e.Uint16BufferAttribute = si, e.Uint32Attribute = function (e, t) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new ci(e, t) }, e.Uint32BufferAttribute = ci, e.Uint8Attribute = function (e, t) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new ni(e, t) }, e.Uint8BufferAttribute = ni, e.Uint8ClampedAttribute = function (e, t) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new ai(e, t) }, e.Uint8ClampedBufferAttribute = ai, e.Uniform = Wc, e.UniformsLib = T, e.UniformsUtils = Vi, e.UnsignedByteType = De, e.UnsignedInt248Type = Q, e.UnsignedIntType = Y, e.UnsignedShort4444Type = 1017, e.UnsignedShort5551Type = 1018, e.UnsignedShort565Type = 1019, e.UnsignedShortType = q, e.VSMShadowMap = 3, e.Vector2 = k, e.Vector3 = Le, e.Vector4 = Re, e.VectorKeyframeTrack = wl, e.Vertex = function (e, t, i) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Le(e, t, i) }, e.VertexColors = 2, e.VideoTexture = Oo, e.WebGL1Renderer = Na, e.WebGLCubeRenderTarget = Xi, e.WebGLMultipleRenderTargets = Te, e.WebGLMultisampleRenderTarget = ze, e.WebGLRenderTarget = Ue, e.WebGLRenderTargetCube = function (e, t, i) { return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Xi(e, i) }, e.WebGLRenderer = o, e.WebGLUtils = Ra, e.WireframeGeometry = Ks, e.WireframeHelper = function (e, t) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Co(new Ks(e.geometry), new v({ color: void 0 !== t ? t : 16777215 })) }, e.WrapAroundEnding = 2402, e.XHRLoader = function (e) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Rl(e) }, e.ZeroCurvatureEnding = 2400, e.ZeroFactor = 200, e.ZeroSlopeEnding = 2401, e.ZeroStencilOp = 0, e.sRGBEncoding = 3001, Object.defineProperty(e, "__esModule", { value: !0 })
}), void 0 === Date.now && (Date.now = function () { return (new Date).valueOf() }); var TWEEN = TWEEN || function () { var i = []; return { REVISION: "13", getAll: function () { return i }, removeAll: function () { i = [] }, add: function (e) { i.push(e) }, remove: function (e) { -1 !== (e = i.indexOf(e)) && i.splice(e, 1) }, update: function (e) { if (0 === i.length) return !1; for (var t = 0, e = void 0 !== e ? e : ("undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance : Date).now(); t < i.length;)i[t].update(e) ? t++ : i.splice(t, 1); return !0 } } }(), EARTH = (TWEEN.Tween = function (o) { var e, s = {}, l = {}, c = {}, h = 1e3, u = 0, d = !1, i = !1, p = 0, f = null, m = TWEEN.Easing.Linear.None, v = TWEEN.Interpolation.Linear, g = [], x = null, y = !1, _ = null, b = null, t = null; for (e in o) s[e] = parseFloat(o[e], 10); this.to = function (e, t) { return void 0 !== t && (h = t), l = e, this }, this.start = function (e) { for (var t in TWEEN.add(this), y = !(i = !0), f = void 0 !== e ? e : ("undefined" != typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance : Date).now(), f += p, l) { if (l[t] instanceof Array) { if (0 === l[t].length) continue; l[t] = [o[t]].concat(l[t]) } s[t] = o[t], 0 == s[t] instanceof Array && (s[t] *= 1), c[t] = s[t] || 0 } return this }, this.stop = function () { return i && (TWEEN.remove(this), i = !1, null !== t && t.call(o), this.stopChainedTweens()), this }, this.stopChainedTweens = function () { for (var e = 0, t = g.length; e < t; e++)g[e].stop() }, this.delay = function (e) { return p = e, this }, this.repeat = function (e) { return u = e, this }, this.yoyo = function (e) { return d = e, this }, this.easing = function (e) { return m = e, this }, this.interpolation = function (e) { return v = e, this }, this.chain = function () { return g = arguments, this }, this.onStart = function (e) { return x = e, this }, this.onUpdate = function (e) { return _ = e, this }, this.onComplete = function (e) { return b = e, this }, this.onStop = function (e) { return t = e, this }, this.update = function (e) { if (e < f) return !0; !1 === y && (null !== x && x.call(o), y = !0); var t, i = (e - f) / h, r = m(i = 1 < i ? 1 : i); for (t in l) { var n = s[t] || 0, a = l[t]; a instanceof Array ? o[t] = v(a, r) : "number" == typeof (a = "string" == typeof a ? n + parseFloat(a, 10) : a) && (o[t] = n + (a - n) * r) } if (null !== _ && _.call(o, r), 1 == i) { if (!(0 < u)) { for (null !== b && b.call(o), t = 0, i = g.length; t < i; t++)g[t].start(e); return !1 } for (t in isFinite(u) && u--, c) "string" == typeof l[t] && (c[t] += parseFloat(l[t], 10)), d && (i = c[t], c[t] = l[t], l[t] = i), s[t] = c[t]; f = e + p } return !0 } }, TWEEN.Easing = { Linear: { None: function (e) { return e } }, Quadratic: { In: function (e) { return e * e }, Out: function (e) { return e * (2 - e) }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1) } }, Cubic: { In: function (e) { return e * e * e }, Out: function (e) { return --e * e * e + 1 }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2) } }, Quartic: { In: function (e) { return e * e * e * e }, Out: function (e) { return 1 - --e * e * e * e }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2) } }, Quintic: { In: function (e) { return e * e * e * e * e }, Out: function (e) { return --e * e * e * e * e + 1 }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2) } }, Sinusoidal: { In: function (e) { return 1 - Math.cos(e * Math.PI / 2) }, Out: function (e) { return Math.sin(e * Math.PI / 2) }, InOut: function (e) { return .5 * (1 - Math.cos(Math.PI * e)) } }, Exponential: { In: function (e) { return 0 === e ? 0 : Math.pow(1024, e - 1) }, Out: function (e) { return 1 === e ? 1 : 1 - Math.pow(2, -10 * e) }, InOut: function (e) { return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1))) } }, Circular: { In: function (e) { return 1 - Math.sqrt(1 - e * e) }, Out: function (e) { return Math.sqrt(1 - --e * e) }, InOut: function (e) { return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1) } }, Elastic: { In: function (e) { var t, i = .1; return 0 === e ? 0 : 1 === e ? 1 : (t = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * --e) * Math.sin(2 * (e - t) * Math.PI / .4))) }, Out: function (e) { var t, i = .1; return 0 === e ? 0 : 1 === e ? 1 : (t = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * e) * Math.sin(2 * (e - t) * Math.PI / .4) + 1) }, InOut: function (e) { var t, i = .1; return 0 === e ? 0 : 1 === e ? 1 : (t = !i || i < 1 ? (i = 1, .1) : .4 * Math.asin(1 / i) / (2 * Math.PI), (e *= 2) < 1 ? -.5 * i * Math.pow(2, 10 * --e) * Math.sin(2 * (e - t) * Math.PI / .4) : .5 * i * Math.pow(2, -10 * --e) * Math.sin(2 * (e - t) * Math.PI / .4) + 1) } }, Back: { In: function (e) { return e * e * (2.70158 * e - 1.70158) }, Out: function (e) { return --e * e * (2.70158 * e + 1.70158) + 1 }, InOut: function (e) { return (e *= 2) < 1 ? .5 * e * e * (3.5949095 * e - 2.5949095) : .5 * ((e -= 2) * e * (3.5949095 * e + 2.5949095) + 2) } }, Bounce: { In: function (e) { return 1 - TWEEN.Easing.Bounce.Out(1 - e) }, Out: function (e) { return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375 }, InOut: function (e) { return e < .5 ? .5 * TWEEN.Easing.Bounce.In(2 * e) : .5 * TWEEN.Easing.Bounce.Out(2 * e - 1) + .5 } } }, TWEEN.Interpolation = { Linear: function (e, t) { var i = e.length - 1, r = i * t, n = Math.floor(r), a = TWEEN.Interpolation.Utils.Linear; return t < 0 ? a(e[0], e[1], r) : 1 < t ? a(e[i], e[i - 1], i - r) : a(e[n], e[i < n + 1 ? i : n + 1], r - n) }, Bezier: function (e, t) { for (var i = 0, r = e.length - 1, n = Math.pow, a = TWEEN.Interpolation.Utils.Bernstein, o = 0; o <= r; o++)i += n(1 - t, r - o) * n(t, o) * e[o] * a(r, o); return i }, CatmullRom: function (e, t) { var i = e.length - 1, r = i * t, n = Math.floor(r), a = TWEEN.Interpolation.Utils.CatmullRom; return e[0] === e[i] ? a(e[((n = t < 0 ? Math.floor(r = i * (1 + t)) : n) - 1 + i) % i], e[n], e[(n + 1) % i], e[(n + 2) % i], r - n) : t < 0 ? e[0] - (a(e[0], e[0], e[1], e[1], -r) - e[0]) : 1 < t ? e[i] - (a(e[i], e[i], e[i - 1], e[i - 1], r - i) - e[i]) : a(e[n ? n - 1 : 0], e[n], e[i < n + 1 ? i : n + 1], e[i < n + 2 ? i : n + 2], r - n) }, Utils: { Linear: function (e, t, i) { return (t - e) * i + e }, Bernstein: function (e, t) { var i = TWEEN.Interpolation.Utils.Factorial; return i(e) / i(t) / i(e - t) }, Factorial: function () { var r = [1]; return function (e) { var t, i = 1; if (r[e]) return r[e]; for (t = e; 1 < t; t--)i *= t; return r[e] = i } }(), CatmullRom: function (e, t, i, r, n) { var a = n * n; return (2 * t - 2 * i + (e = .5 * (i - e)) + (r = .5 * (r - t))) * n * a + (-3 * t + 3 * i - 2 * e - r) * a + e * n + t } } }, function () { const Y = { type: "change" }, Q = { type: "start" }, Z = { type: "end" }; class e extends THREE.EventDispatcher { constructor(e, t) { super(), void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'), t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new THREE.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN }, this.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function () { return p.phi }, this.getAzimuthalAngle = function () { return p.theta }, this.getDistance = function () { return this.object.position.distanceTo(this.target) }, this.listenToKeyEvents = function (e) { e.addEventListener("keydown", W), this._domElementKeyEvents = e }, this.saveState = function () { c.target0.copy(c.target), c.position0.copy(c.object.position), c.zoom0 = c.object.zoom }, this.reset = function () { c.target.copy(c.target0), c.object.position.copy(c.position0), c.object.zoom = c.zoom0, c.object.updateProjectionMatrix(), c.dispatchEvent(Y), c.update(), u = h.NONE }, this.update = function () { const r = new THREE.Vector3, n = (new THREE.Quaternion).setFromUnitVectors(e.up, new THREE.Vector3(0, 1, 0)), a = n.clone().invert(), o = new THREE.Vector3, s = new THREE.Quaternion, l = 2 * Math.PI; return function () { const e = c.object.position; r.copy(e).sub(c.target), r.applyQuaternion(n), p.setFromVector3(r), c.autoRotate && u === h.NONE && T(2 * Math.PI / 60 / 60 * c.autoRotateSpeed), c.enableDamping ? (p.theta += f.theta * c.dampingFactor, p.phi += f.phi * c.dampingFactor) : (p.theta += f.theta, p.phi += f.phi); let t = c.minAzimuthAngle, i = c.maxAzimuthAngle; return isFinite(t) && isFinite(i) && (t < -Math.PI ? t += l : t > Math.PI && (t -= l), i < -Math.PI ? i += l : i > Math.PI && (i -= l), t <= i ? p.theta = Math.max(t, Math.min(i, p.theta)) : p.theta = p.theta > (t + i) / 2 ? Math.max(t, p.theta) : Math.min(i, p.theta)), p.phi = Math.max(c.minPolarAngle, Math.min(c.maxPolarAngle, p.phi)), p.makeSafe(), p.radius *= m, p.radius = Math.max(c.minDistance, Math.min(c.maxDistance, p.radius)), !0 === c.enableDamping ? c.target.addScaledVector(v, c.dampingFactor) : c.target.add(v), r.setFromSpherical(p), r.applyQuaternion(a), e.copy(c.target).add(r), c.object.lookAt(c.target), !0 === c.enableDamping ? (f.theta *= 1 - c.dampingFactor, f.phi *= 1 - c.dampingFactor, v.multiplyScalar(1 - c.dampingFactor)) : (f.set(0, 0, 0), v.set(0, 0, 0)), m = 1, !(!(g || o.distanceToSquared(c.object.position) > d || 8 * (1 - s.dot(c.object.quaternion)) > d) || (c.dispatchEvent(Y), o.copy(c.object.position), s.copy(c.object.quaternion), g = !1)) } }(), this.dispose = function () { c.domElement.removeEventListener("contextmenu", j), c.domElement.removeEventListener("pointerdown", V), c.domElement.removeEventListener("pointercancel", k), c.domElement.removeEventListener("wheel", G), c.domElement.removeEventListener("pointermove", I), c.domElement.removeEventListener("pointerup", N), null !== c._domElementKeyEvents && c._domElementKeyEvents.removeEventListener("keydown", W) }; const c = this, h = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_PAN: 4, TOUCH_DOLLY_PAN: 5, TOUCH_DOLLY_ROTATE: 6 }; let u = h.NONE; const d = 1e-6, p = new THREE.Spherical, f = new THREE.Spherical; let m = 1; const v = new THREE.Vector3; let g = !1; const a = new THREE.Vector2, o = new THREE.Vector2, s = new THREE.Vector2, l = new THREE.Vector2, x = new THREE.Vector2, y = new THREE.Vector2, _ = new THREE.Vector2, b = new THREE.Vector2, w = new THREE.Vector2, n = [], i = {}; function E() { return Math.pow(.95, c.zoomSpeed) } function T(e) { f.theta -= e } function S(e) { f.phi -= e } const M = function () { const i = new THREE.Vector3; return function (e, t) { i.setFromMatrixColumn(t, 0), i.multiplyScalar(-e), v.add(i) } }(), A = function () { const i = new THREE.Vector3; return function (e, t) { !0 === c.screenSpacePanning ? i.setFromMatrixColumn(t, 1) : (i.setFromMatrixColumn(t, 0), i.crossVectors(c.object.up, i)), i.multiplyScalar(e), v.add(i) } }(), R = function () { const n = new THREE.Vector3; return function (e, t) { var i, r = c.domElement; c.object.isPerspectiveCamera ? (i = c.object.position, n.copy(i).sub(c.target), i = n.length(), i *= Math.tan(c.object.fov / 2 * Math.PI / 180), M(2 * e * i / r.clientHeight, c.object.matrix), A(2 * t * i / r.clientHeight, c.object.matrix)) : c.object.isOrthographicCamera ? (M(e * (c.object.right - c.object.left) / c.object.zoom / r.clientWidth, c.object.matrix), A(t * (c.object.top - c.object.bottom) / c.object.zoom / r.clientHeight, c.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), c.enablePan = !1) } }(); function L(e) { c.object.isPerspectiveCamera ? m /= e : c.object.isOrthographicCamera ? (c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom * e)), c.object.updateProjectionMatrix(), g = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), c.enableZoom = !1) } function P(e) { c.object.isPerspectiveCamera ? m *= e : c.object.isOrthographicCamera ? (c.object.zoom = Math.max(c.minZoom, Math.min(c.maxZoom, c.object.zoom / e)), c.object.updateProjectionMatrix(), g = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), c.enableZoom = !1) } function C(e) { a.set(e.clientX, e.clientY) } function F(e) { l.set(e.clientX, e.clientY) } function D() { var e, t; 1 === n.length ? a.set(n[0].pageX, n[0].pageY) : (e = .5 * (n[0].pageX + n[1].pageX), t = .5 * (n[0].pageY + n[1].pageY), a.set(e, t)) } function H() { var e, t; 1 === n.length ? l.set(n[0].pageX, n[0].pageY) : (e = .5 * (n[0].pageX + n[1].pageX), t = .5 * (n[0].pageY + n[1].pageY), l.set(e, t)) } function B() { var e = n[0].pageX - n[1].pageX, t = n[0].pageY - n[1].pageY, e = Math.sqrt(e * e + t * t); _.set(0, e) } function U(e) { 1 == n.length ? o.set(e.pageX, e.pageY) : (i = r(e), t = .5 * (e.pageX + i.x), e = .5 * (e.pageY + i.y), o.set(t, e)), s.subVectors(o, a).multiplyScalar(c.rotateSpeed); var t, i = c.domElement; T(2 * Math.PI * s.x / i.clientHeight), S(2 * Math.PI * s.y / i.clientHeight), a.copy(o) } function z(e) { var t, i; 1 === n.length ? x.set(e.pageX, e.pageY) : (t = r(e), i = .5 * (e.pageX + t.x), e = .5 * (e.pageY + t.y), x.set(i, e)), y.subVectors(x, l).multiplyScalar(c.panSpeed), R(y.x, y.y), l.copy(x) } function O(e) { var t = r(e), i = e.pageX - t.x, e = e.pageY - t.y, t = Math.sqrt(i * i + e * e); b.set(0, t), w.set(0, Math.pow(b.y / _.y, c.zoomSpeed)), L(w.y), _.copy(b) } function V(t) { var e, i; if (!1 !== c.enabled) if (0 === n.length && (c.domElement.setPointerCapture(t.pointerId), c.domElement.addEventListener("pointermove", I), c.domElement.addEventListener("pointerup", N)), e = t, n.push(e), "touch" !== t.pointerType) { var r = t; let e; switch (r.button) { case 0: e = c.mouseButtons.LEFT; break; case 1: e = c.mouseButtons.MIDDLE; break; case 2: e = c.mouseButtons.RIGHT; break; default: e = -1 }switch (e) { case THREE.MOUSE.DOLLY: if (!1 === c.enableZoom) return; i = r, _.set(i.clientX, i.clientY), u = h.DOLLY; break; case THREE.MOUSE.ROTATE: if (r.ctrlKey || r.metaKey || r.shiftKey) { if (!1 === c.enablePan) return; F(r), u = h.PAN } else { if (!1 === c.enableRotate) return; C(r), u = h.ROTATE } break; case THREE.MOUSE.PAN: if (r.ctrlKey || r.metaKey || r.shiftKey) { if (!1 === c.enableRotate) return; C(r), u = h.ROTATE } else { if (!1 === c.enablePan) return; F(r), u = h.PAN } break; default: u = h.NONE }u !== h.NONE && c.dispatchEvent(Q) } else { switch (q(t), n.length) { case 1: switch (c.touches.ONE) { case THREE.TOUCH.ROTATE: if (!1 === c.enableRotate) return; D(), u = h.TOUCH_ROTATE; break; case THREE.TOUCH.PAN: if (!1 === c.enablePan) return; H(), u = h.TOUCH_PAN; break; default: u = h.NONE }break; case 2: switch (c.touches.TWO) { case THREE.TOUCH.DOLLY_PAN: if (!1 === c.enableZoom && !1 === c.enablePan) return; c.enableZoom && B(), c.enablePan && H(), u = h.TOUCH_DOLLY_PAN; break; case THREE.TOUCH.DOLLY_ROTATE: if (!1 === c.enableZoom && !1 === c.enableRotate) return; c.enableZoom && B(), c.enableRotate && D(), u = h.TOUCH_DOLLY_ROTATE; break; default: u = h.NONE }break; default: u = h.NONE }u !== h.NONE && c.dispatchEvent(Q) } } function I(e) { if (!1 !== c.enabled) if ("touch" === e.pointerType) { var t = e; switch (q(t), u) { case h.TOUCH_ROTATE: if (!1 === c.enableRotate) return; U(t), c.update(); break; case h.TOUCH_PAN: if (!1 === c.enablePan) return; z(t), c.update(); break; case h.TOUCH_DOLLY_PAN: if (!1 === c.enableZoom && !1 === c.enablePan) return; n = t, c.enableZoom && O(n), c.enablePan && z(n), c.update(); break; case h.TOUCH_DOLLY_ROTATE: if (!1 === c.enableZoom && !1 === c.enableRotate) return; n = t, c.enableZoom && O(n), c.enableRotate && U(n), c.update(); break; default: u = h.NONE } } else { var i = e; if (!1 !== c.enabled) switch (u) { case h.ROTATE: if (!1 === c.enableRotate) return; r = i, o.set(r.clientX, r.clientY), s.subVectors(o, a).multiplyScalar(c.rotateSpeed), r = c.domElement, T(2 * Math.PI * s.x / r.clientHeight), S(2 * Math.PI * s.y / r.clientHeight), a.copy(o), c.update(); break; case h.DOLLY: if (!1 === c.enableZoom) return; r = i, b.set(r.clientX, r.clientY), w.subVectors(b, _), 0 < w.y ? L(E()) : w.y < 0 && P(E()), _.copy(b), c.update(); break; case h.PAN: if (!1 === c.enablePan) return; r = i, x.set(r.clientX, r.clientY), y.subVectors(x, l).multiplyScalar(c.panSpeed), R(y.x, y.y), l.copy(x), c.update() } } var r, n } function N(e) { !1 !== c.enabled && (u = (e.pointerType, c.dispatchEvent(Z), h.NONE), X(e), 0 === n.length && (c.domElement.releasePointerCapture(e.pointerId), c.domElement.removeEventListener("pointermove", I), c.domElement.removeEventListener("pointerup", N))) } function k(e) { X(e) } function G(e) { !1 === c.enabled || !1 === c.enableZoom || u !== h.NONE && u !== h.ROTATE || (e.preventDefault(), c.dispatchEvent(Q), e.deltaY < 0 ? P(E()) : 0 < e.deltaY && L(E()), c.update(), c.dispatchEvent(Z)) } function W(t) { if (!1 !== c.enabled && !1 !== c.enablePan) { let e = !1; switch (t.code) { case c.keys.UP: R(0, c.keyPanSpeed), e = !0; break; case c.keys.BOTTOM: R(0, -c.keyPanSpeed), e = !0; break; case c.keys.LEFT: R(c.keyPanSpeed, 0), e = !0; break; case c.keys.RIGHT: R(-c.keyPanSpeed, 0), e = !0 }e && (t.preventDefault(), c.update()) } } function j(e) { !1 !== c.enabled && e.preventDefault() } function X(t) { delete i[t.pointerId]; for (let e = 0; e < n.length; e++)if (n[e].pointerId == t.pointerId) return n.splice(e, 1) } function q(e) { let t = i[e.pointerId]; void 0 === t && (t = new THREE.Vector2, i[e.pointerId] = t), t.set(e.pageX, e.pageY) } function r(e) { return e = e.pointerId === n[0].pointerId ? n[1] : n[0], i[e.pointerId] } c.domElement.addEventListener("contextmenu", j), c.domElement.addEventListener("pointerdown", V), c.domElement.addEventListener("pointercancel", k), c.domElement.addEventListener("wheel", G, { passive: !1 }), this.update() } } THREE.MapControls = class extends e { constructor(e, t) { super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = THREE.MOUSE.PAN, this.mouseButtons.RIGHT = THREE.MOUSE.ROTATE, this.touches.ONE = THREE.TOUCH.PAN, this.touches.TWO = THREE.TOUCH.DOLLY_ROTATE } }, THREE.OrbitControls = e }(), function () { const o = new THREE.Vector3; class e extends THREE.InstancedBufferGeometry { constructor() { super(), this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new THREE.Float32BufferAttribute([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new THREE.Float32BufferAttribute([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2)) } applyMatrix4(e) { const t = this.attributes.instanceStart, i = this.attributes.instanceEnd; return void 0 !== t && (t.applyMatrix4(e), i.applyMatrix4(e), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } setPositions(e) { let t; return e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e)), e = new THREE.InstancedInterleavedBuffer(t, 6, 1), this.setAttribute("instanceStart", new THREE.InterleavedBufferAttribute(e, 3, 0)), this.setAttribute("instanceEnd", new THREE.InterleavedBufferAttribute(e, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this } setColors(e) { let t; return e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e)), e = new THREE.InstancedInterleavedBuffer(t, 6, 1), this.setAttribute("instanceColorStart", new THREE.InterleavedBufferAttribute(e, 3, 0)), this.setAttribute("instanceColorEnd", new THREE.InterleavedBufferAttribute(e, 3, 3)), this } fromWireframeGeometry(e) { return this.setPositions(e.attributes.position.array), this } fromEdgesGeometry(e) { return this.setPositions(e.attributes.position.array), this } fromMesh(e) { return this.fromWireframeGeometry(new THREE.WireframeGeometry(e.geometry)), this } fromLineSegments(e) { if (!(e = e.geometry).isGeometry) return e.isBufferGeometry && this.setPositions(e.attributes.position.array), this; console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.") } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new THREE.Box3); var e = this.attributes.instanceStart, t = this.attributes.instanceEnd; void 0 !== e && void 0 !== t && (this.boundingBox.setFromBufferAttribute(e), S.setFromBufferAttribute(t), this.boundingBox.union(S)) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), null === this.boundingBox && this.computeBoundingBox(); var r = this.attributes.instanceStart, n = this.attributes.instanceEnd; if (void 0 !== r && void 0 !== n) { const a = this.boundingSphere.center; this.boundingBox.getCenter(a); let i = 0; for (let e = 0, t = r.count; e < t; e++)o.fromBufferAttribute(r, e), i = Math.max(i, a.distanceToSquared(o)), o.fromBufferAttribute(n, e), i = Math.max(i, a.distanceToSquared(o)); this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this) } } toJSON() { } applyMatrix(e) { return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e) } } e.prototype.isLineSegmentsGeometry = !0, THREE.LineSegmentsGeometry = e; const s = new THREE.Vector3, l = new THREE.Vector3, x = new THREE.Vector4, y = new THREE.Vector4, _ = new THREE.Vector4, b = new THREE.Vector3, w = new THREE.Matrix4, E = new THREE.Line3, T = new THREE.Vector3, S = new THREE.Box3, M = new THREE.Sphere, A = new THREE.Vector4; class t extends THREE.Mesh { constructor(e = new THREE.LineSegmentsGeometry, t = new THREE.LineMaterial({ color: 16777215 * Math.random() })) { super(e, t), this.type = "LineSegments2" } computeLineDistances() { const e = this.geometry; var r = e.attributes.instanceStart, n = e.attributes.instanceEnd; const a = new Float32Array(2 * r.count); for (let e = 0, t = 0, i = r.count; e < i; e++, t += 2)s.fromBufferAttribute(r, e), l.fromBufferAttribute(n, e), a[t] = 0 === t ? 0 : a[t - 1], a[t + 1] = a[t] + s.distanceTo(l); var t = new THREE.InstancedInterleavedBuffer(a, 2, 1); return e.setAttribute("instanceDistanceStart", new THREE.InterleavedBufferAttribute(t, 1, 0)), e.setAttribute("instanceDistanceEnd", new THREE.InterleavedBufferAttribute(t, 1, 1)), this } raycast(e, i) { null === e.camera && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.'); var t = void 0 !== e.params.Line2 && e.params.Line2.threshold || 0; const r = e.ray; var n = e.camera, a = n.projectionMatrix, o = this.matrixWorld; const s = this.geometry; var l = (p = this.material).resolution, c = p.linewidth + t, h = s.attributes.instanceStart, u = s.attributes.instanceEnd, d = -n.near, p = 2 * Math.max(c / l.width, c / l.height), t = (null === s.boundingSphere && s.computeBoundingSphere(), M.copy(s.boundingSphere).applyMatrix4(o), Math.max(n.near, M.distanceToPoint(r.origin))), t = (A.set(0, 0, -t, 1).applyMatrix4(n.projectionMatrix), A.multiplyScalar(1 / A.w), A.applyMatrix4(n.projectionMatrixInverse), .5 * Math.abs(p / A.w)); if (M.radius += t, !1 !== e.ray.intersectsSphere(M)) { null === s.boundingBox && s.computeBoundingBox(), S.copy(s.boundingBox).applyMatrix4(o); var f, m, v, g, t = Math.max(n.near, S.distanceToPoint(r.origin)), t = (A.set(0, 0, -t, 1).applyMatrix4(n.projectionMatrix), A.multiplyScalar(1 / A.w), A.applyMatrix4(n.projectionMatrixInverse), .5 * Math.abs(p / A.w)); if (S.max.x += t, S.max.y += t, S.max.z += t, S.min.x -= t, S.min.y -= t, S.min.z -= t, !1 !== e.ray.intersectsBox(S)) { r.at(1, _), _.w = 1, _.applyMatrix4(n.matrixWorldInverse), _.applyMatrix4(a), _.multiplyScalar(1 / _.w), _.x *= l.x / 2, _.y *= l.y / 2, _.z = 0, b.copy(_), w.multiplyMatrices(n.matrixWorldInverse, o); for (let e = 0, t = h.count; e < t; e++)x.fromBufferAttribute(h, e), y.fromBufferAttribute(u, e), x.w = 1, y.w = 1, x.applyMatrix4(w), y.applyMatrix4(w), x.z > d && y.z > d || (x.z > d ? (f = x.z - y.z, f = (x.z - d) / f, x.lerp(y, f)) : y.z > d && (f = y.z - x.z, m = (y.z - d) / f, y.lerp(x, m)), x.applyMatrix4(a), y.applyMatrix4(a), x.multiplyScalar(1 / x.w), y.multiplyScalar(1 / y.w), x.x *= l.x / 2, x.y *= l.y / 2, y.x *= l.x / 2, y.y *= l.y / 2, E.start.copy(x), E.start.z = 0, E.end.copy(y), E.end.z = 0, m = E.closestPointToPointParameter(b, !0), E.at(m, T), v = -1 <= (v = THREE.MathUtils.lerp(x.z, y.z, m)) && v <= 1, g = b.distanceTo(T) < .5 * c, v && g && (E.start.fromBufferAttribute(h, e), E.end.fromBufferAttribute(u, e), E.start.applyMatrix4(o), E.end.applyMatrix4(o), v = new THREE.Vector3, g = new THREE.Vector3, r.distanceSqToSegment(E.start, E.end, g, v), i.push({ point: g, pointOnLine: v, distance: r.origin.distanceTo(g), object: this, face: null, faceIndex: e, uv: null, uv2: null }))) } } } } t.prototype.LineSegments2 = !0, THREE.LineSegments2 = t; class i extends THREE.LineSegments2 { constructor(e = new THREE.LineGeometry, t = new THREE.LineMaterial({ color: 16777215 * Math.random() })) { super(e, t), this.type = "Line2" } } i.prototype.isLine2 = !0, THREE.Line2 = i }(), function () { const i = new THREE.Box3, o = new THREE.Vector3; class e extends THREE.InstancedBufferGeometry { constructor() { super(), this.type = "LineSegmentsGeometry", this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]), this.setAttribute("position", new THREE.Float32BufferAttribute([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], 3)), this.setAttribute("uv", new THREE.Float32BufferAttribute([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], 2)) } applyMatrix4(e) { const t = this.attributes.instanceStart, i = this.attributes.instanceEnd; return void 0 !== t && (t.applyMatrix4(e), i.applyMatrix4(e), t.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this } setPositions(e) { let t; return e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e)), e = new THREE.InstancedInterleavedBuffer(t, 6, 1), this.setAttribute("instanceStart", new THREE.InterleavedBufferAttribute(e, 3, 0)), this.setAttribute("instanceEnd", new THREE.InterleavedBufferAttribute(e, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this } setColors(e) { let t; return e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e)), e = new THREE.InstancedInterleavedBuffer(t, 6, 1), this.setAttribute("instanceColorStart", new THREE.InterleavedBufferAttribute(e, 3, 0)), this.setAttribute("instanceColorEnd", new THREE.InterleavedBufferAttribute(e, 3, 3)), this } fromWireframeGeometry(e) { return this.setPositions(e.attributes.position.array), this } fromEdgesGeometry(e) { return this.setPositions(e.attributes.position.array), this } fromMesh(e) { return this.fromWireframeGeometry(new THREE.WireframeGeometry(e.geometry)), this } fromLineSegments(e) { if (!(e = e.geometry).isGeometry) return e.isBufferGeometry && this.setPositions(e.attributes.position.array), this; console.error("THREE.LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.") } computeBoundingBox() { null === this.boundingBox && (this.boundingBox = new THREE.Box3); var e = this.attributes.instanceStart, t = this.attributes.instanceEnd; void 0 !== e && void 0 !== t && (this.boundingBox.setFromBufferAttribute(e), i.setFromBufferAttribute(t), this.boundingBox.union(i)) } computeBoundingSphere() { null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere), null === this.boundingBox && this.computeBoundingBox(); var r = this.attributes.instanceStart, n = this.attributes.instanceEnd; if (void 0 !== r && void 0 !== n) { const a = this.boundingSphere.center; this.boundingBox.getCenter(a); let i = 0; for (let e = 0, t = r.count; e < t; e++)o.fromBufferAttribute(r, e), i = Math.max(i, a.distanceToSquared(o)), o.fromBufferAttribute(n, e), i = Math.max(i, a.distanceToSquared(o)); this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this) } } toJSON() { } applyMatrix(e) { return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e) } } e.prototype.isLineSegmentsGeometry = !0, THREE.LineSegmentsGeometry = e; class t extends THREE.LineSegmentsGeometry { constructor() { super(), this.type = "LineGeometry" } setPositions(e) { for (var t = e.length - 3, i = new Float32Array(2 * t), r = 0; r < t; r += 3)i[2 * r] = e[r], i[2 * r + 1] = e[r + 1], i[2 * r + 2] = e[r + 2], i[2 * r + 3] = e[r + 3], i[2 * r + 4] = e[r + 4], i[2 * r + 5] = e[r + 5]; return super.setPositions(i), this } setColors(e) { for (var t = e.length - 3, i = new Float32Array(2 * t), r = 0; r < t; r += 3)i[2 * r] = e[r], i[2 * r + 1] = e[r + 1], i[2 * r + 2] = e[r + 2], i[2 * r + 3] = e[r + 3], i[2 * r + 4] = e[r + 4], i[2 * r + 5] = e[r + 5]; return super.setColors(i), this } fromLine(e) { if (!(e = e.geometry).isGeometry) return e.isBufferGeometry && this.setPositions(e.attributes.position.array), this; console.error("THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead.") } } t.prototype.isLineGeometry = !0, THREE.LineGeometry = t }(), function () {
	THREE.UniformsLib.line = { linewidth: { value: 1 }, resolution: { value: new THREE.Vector2(1, 1) }, dashScale: { value: 1 }, dashSize: { value: 1 }, dashOffset: { value: 0 }, gapSize: { value: 1 }, opacity: { value: 1 } }, THREE.ShaderLib.line = {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.line]), vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}`, fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float dashOffset;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = 1.0;

			#ifdef ALPHA_TO_COVERAGE

			// artifacts appear on some hardware if a derivative is taken within a conditional
			float a = vUv.x;
			float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
			float len2 = a * a + b * b;
			float dlen = fwidth( len2 );

			if ( abs( vUv.y ) > 1.0 ) {

				alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

			}

			#else

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			#endif

			vec4 diffuseColor = vec4( diffuse, opacity * alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = diffuseColor;

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}`}; class e extends THREE.ShaderMaterial { constructor(e) { super({ type: "LineMaterial", uniforms: THREE.UniformsUtils.clone(THREE.ShaderLib.line.uniforms), vertexShader: THREE.ShaderLib.line.vertexShader, fragmentShader: THREE.ShaderLib.line.fragmentShader, clipping: !0 }), Object.defineProperties(this, { color: { enumerable: !0, get: function () { return this.uniforms.diffuse.value }, set: function (e) { this.uniforms.diffuse.value = e } }, linewidth: { enumerable: !0, get: function () { return this.uniforms.linewidth.value }, set: function (e) { this.uniforms.linewidth.value = e } }, dashed: { enumerable: !0, get: function () { return Boolean("USE_DASH" in this.defines) }, set(e) { Boolean(e) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), !0 === e ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH } }, dashScale: { enumerable: !0, get: function () { return this.uniforms.dashScale.value }, set: function (e) { this.uniforms.dashScale.value = e } }, dashSize: { enumerable: !0, get: function () { return this.uniforms.dashSize.value }, set: function (e) { this.uniforms.dashSize.value = e } }, dashOffset: { enumerable: !0, get: function () { return this.uniforms.dashOffset.value }, set: function (e) { this.uniforms.dashOffset.value = e } }, gapSize: { enumerable: !0, get: function () { return this.uniforms.gapSize.value }, set: function (e) { this.uniforms.gapSize.value = e } }, opacity: { enumerable: !0, get: function () { return this.uniforms.opacity.value }, set: function (e) { this.uniforms.opacity.value = e } }, resolution: { enumerable: !0, get: function () { return this.uniforms.resolution.value }, set: function (e) { this.uniforms.resolution.value.copy(e) } }, alphaToCoverage: { enumerable: !0, get: function () { return Boolean("ALPHA_TO_COVERAGE" in this.defines) }, set: function (e) { Boolean(e) !== Boolean("ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), !0 === e ? (this.defines.ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.ALPHA_TO_COVERAGE, this.extensions.derivatives = !1) } } }), this.setValues(e) } } e.prototype.isLineMaterial = !0, THREE.LineMaterial = e
}(), function () { const o = new THREE.Vector3, s = new THREE.Vector3; class e extends THREE.Mesh { constructor(e = new THREE.LineSegmentsGeometry, t = new THREE.LineMaterial({ color: 16777215 * Math.random() })) { super(e, t), this.type = "Wireframe" } computeLineDistances() { const e = this.geometry; var r = e.attributes.instanceStart, n = e.attributes.instanceEnd; const a = new Float32Array(2 * r.count); for (let e = 0, t = 0, i = r.count; e < i; e++, t += 2)o.fromBufferAttribute(r, e), s.fromBufferAttribute(n, e), a[t] = 0 === t ? 0 : a[t - 1], a[t + 1] = a[t] + o.distanceTo(s); var t = new THREE.InstancedInterleavedBuffer(a, 2, 1); return e.setAttribute("instanceDistanceStart", new THREE.InterleavedBufferAttribute(t, 1, 0)), e.setAttribute("instanceDistanceEnd", new THREE.InterleavedBufferAttribute(t, 1, 1)), this } } e.prototype.isWireframe = !0, THREE.Wireframe = e }(), function () { class e extends THREE.LineSegmentsGeometry { constructor(e) { super(), this.type = "WireframeGeometry2", this.fromWireframeGeometry(new THREE.WireframeGeometry(e)) } } e.prototype.isWireframeGeometry2 = !0, THREE.WireframeGeometry2 = e }(), function () { class e extends THREE.Loader { constructor(e) { super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function (e) { return new r(e) }), this.register(function (e) { return new l(e) }), this.register(function (e) { return new c(e) }), this.register(function (e) { return new n(e) }), this.register(function (e) { return new a(e) }), this.register(function (e) { return new o(e) }), this.register(function (e) { return new s(e) }), this.register(function (e) { return new t(e) }), this.register(function (e) { return new h(e) }) } load(t, i, e, r) { const n = this; let a; function o(e) { r ? r(e) : console.error(e), n.manager.itemError(t), n.manager.itemEnd(t) } a = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : THREE.LoaderUtils.extractUrlBase(t), this.manager.itemStart(t); const s = new THREE.FileLoader(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, function (e) { try { n.parse(e, a, function (e) { i(e), n.manager.itemEnd(t) }, o) } catch (e) { o(e) } }, e, o) } setDRACOLoader(e) { return this.dracoLoader = e, this } setDDSLoader() { throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".') } setKTX2Loader(e) { return this.ktx2Loader = e, this } setMeshoptDecoder(e) { return this.meshoptDecoder = e, this } register(e) { return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this } unregister(e) { return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this } parse(e, t, i, r) { let n; const a = {}, o = {}; if ("string" == typeof e) n = e; else if (THREE.LoaderUtils.decodeText(new Uint8Array(e, 0, 4)) === f) { try { a[d.KHR_BINARY_GLTF] = new m(e) } catch (e) { return void (r && r(e)) } n = a[d.KHR_BINARY_GLTF].content } else n = THREE.LoaderUtils.decodeText(new Uint8Array(e)); var s = JSON.parse(n); if (void 0 === s.asset || s.asset.version[0] < 2) r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")); else { const h = new k(s, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder }); h.fileLoader.setRequestHeader(this.requestHeader); for (let e = 0; e < this.pluginCallbacks.length; e++) { var l = this.pluginCallbacks[e](h); o[l.name] = l, a[l.name] = !0 } if (s.extensionsUsed) for (let e = 0; e < s.extensionsUsed.length; ++e) { var c = s.extensionsUsed[e]; const u = s.extensionsRequired || []; switch (c) { case d.KHR_MATERIALS_UNLIT: a[c] = new p; break; case d.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: a[c] = new H; break; case d.KHR_DRACO_MESH_COMPRESSION: a[c] = new v(s, this.dracoLoader); break; case d.KHR_TEXTURE_TRANSFORM: a[c] = new g; break; case d.KHR_MESH_QUANTIZATION: a[c] = new B; break; default: 0 <= u.indexOf(c) && void 0 === o[c] && console.warn('THREE.GLTFLoader: Unknown extension "' + c + '".') } } h.setExtensions(a), h.setPlugins(o), h.parse(i, r) } } } function i() { let i = {}; return { get: function (e) { return i[e] }, add: function (e, t) { i[e] = t }, remove: function (e) { delete i[e] }, removeAll: function () { i = {} } } } const d = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" }; class t { constructor(e) { this.parser = e, this.name = d.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} } } _markDefs() { const i = this.parser; var r = this.parser.json.nodes || []; for (let e = 0, t = r.length; e < t; e++) { var n = r[e]; n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && i._addNodeRef(this.cache, n.extensions[this.name].light) } } _loadLight(e) { const t = this.parser; var i = "light:" + e; let r = t.cache.get(i); if (r) return r; var n = t.json; const a = ((n.extensions && n.extensions[this.name] || {}).lights || [])[e]; let o; const s = new THREE.Color(16777215); void 0 !== a.color && s.fromArray(a.color); var l = void 0 !== a.range ? a.range : 0; switch (a.type) { case "directional": (o = new THREE.DirectionalLight(s)).target.position.set(0, 0, -1), o.add(o.target); break; case "point": (o = new THREE.PointLight(s)).distance = l; break; case "spot": (o = new THREE.SpotLight(s)).distance = l, a.spot = a.spot || {}, a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4, o.angle = a.spot.outerConeAngle, o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target); break; default: throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type) }return o.position.set(0, 0, 0), o.decay = 2, void 0 !== a.intensity && (o.intensity = a.intensity), o.name = t.createUniqueName(a.name || "light_" + e), r = Promise.resolve(o), t.cache.add(i, r), r } createNodeAttachment(e) { const t = this, i = this.parser, r = ((e = i.json.nodes[e]).extensions && e.extensions[this.name] || {}).light; return void 0 === r ? null : this._loadLight(r).then(function (e) { return i._getNodeRef(t.cache, r, e) }) } } class p { constructor() { this.name = d.KHR_MATERIALS_UNLIT } getMaterialType() { return THREE.MeshBasicMaterial } extendParams(e, t, i) { const r = []; var n; return e.color = new THREE.Color(1, 1, 1), e.opacity = 1, (t = t.pbrMetallicRoughness) && (Array.isArray(t.baseColorFactor) && (n = t.baseColorFactor, e.color.fromArray(n), e.opacity = n[3]), void 0 !== t.baseColorTexture && r.push(i.assignTexture(e, "map", t.baseColorTexture))), Promise.all(r) } } class r { constructor(e) { this.parser = e, this.name = d.KHR_MATERIALS_CLEARCOAT } getMaterialType(e) { return (e = this.parser.json.materials[e]).extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { const i = this.parser; if (!(e = i.json.materials[e]).extensions || !e.extensions[this.name]) return Promise.resolve(); const r = []; return void 0 !== (e = e.extensions[this.name]).clearcoatFactor && (t.clearcoat = e.clearcoatFactor), void 0 !== e.clearcoatTexture && r.push(i.assignTexture(t, "clearcoatMap", e.clearcoatTexture)), void 0 !== e.clearcoatRoughnessFactor && (t.clearcoatRoughness = e.clearcoatRoughnessFactor), void 0 !== e.clearcoatRoughnessTexture && r.push(i.assignTexture(t, "clearcoatRoughnessMap", e.clearcoatRoughnessTexture)), void 0 !== e.clearcoatNormalTexture && (r.push(i.assignTexture(t, "clearcoatNormalMap", e.clearcoatNormalTexture)), void 0 !== e.clearcoatNormalTexture.scale && (e = e.clearcoatNormalTexture.scale, t.clearcoatNormalScale = new THREE.Vector2(e, -e))), Promise.all(r) } } class n { constructor(e) { this.parser = e, this.name = d.KHR_MATERIALS_TRANSMISSION } getMaterialType(e) { return (e = this.parser.json.materials[e]).extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { const i = this.parser; if (!(e = i.json.materials[e]).extensions || !e.extensions[this.name]) return Promise.resolve(); const r = []; return void 0 !== (e = e.extensions[this.name]).transmissionFactor && (t.transmission = e.transmissionFactor), void 0 !== e.transmissionTexture && r.push(i.assignTexture(t, "transmissionMap", e.transmissionTexture)), Promise.all(r) } } class a { constructor(e) { this.parser = e, this.name = d.KHR_MATERIALS_VOLUME } getMaterialType(e) { return (e = this.parser.json.materials[e]).extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { const i = this.parser; if (!(e = i.json.materials[e]).extensions || !e.extensions[this.name]) return Promise.resolve(); const r = []; return e = e.extensions[this.name], t.thickness = void 0 !== e.thicknessFactor ? e.thicknessFactor : 0, void 0 !== e.thicknessTexture && r.push(i.assignTexture(t, "thicknessMap", e.thicknessTexture)), t.attenuationDistance = e.attenuationDistance || 0, e = e.attenuationColor || [1, 1, 1], t.attenuationTint = new THREE.Color(e[0], e[1], e[2]), Promise.all(r) } } class o { constructor(e) { this.parser = e, this.name = d.KHR_MATERIALS_IOR } getMaterialType(e) { return (e = this.parser.json.materials[e]).extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { return (e = this.parser.json.materials[e]).extensions && e.extensions[this.name] && (e = e.extensions[this.name], t.ior = void 0 !== e.ior ? e.ior : 1.5), Promise.resolve() } } class s { constructor(e) { this.parser = e, this.name = d.KHR_MATERIALS_SPECULAR } getMaterialType(e) { return (e = this.parser.json.materials[e]).extensions && e.extensions[this.name] ? THREE.MeshPhysicalMaterial : null } extendMaterialParams(e, t) { const i = this.parser; if (!(e = i.json.materials[e]).extensions || !e.extensions[this.name]) return Promise.resolve(); const r = []; var e = e.extensions[this.name], n = (t.specularIntensity = void 0 !== e.specularFactor ? e.specularFactor : 1, void 0 !== e.specularTexture && r.push(i.assignTexture(t, "specularIntensityMap", e.specularTexture)), e.specularColorFactor || [1, 1, 1]); return t.specularTint = new THREE.Color(n[0], n[1], n[2]), void 0 !== e.specularColorTexture && r.push(i.assignTexture(t, "specularTintMap", e.specularColorTexture).then(function (e) { e.encoding = THREE.sRGBEncoding })), Promise.all(r) } } class l { constructor(e) { this.parser = e, this.name = d.KHR_TEXTURE_BASISU } loadTexture(e) { const t = this.parser, i = t.json; if (!(r = i.textures[e]).extensions || !r.extensions[this.name]) return null; var r = r.extensions[this.name], r = i.images[r.source], n = t.options.ktx2Loader; if (n) return t.loadTextureImage(e, r, n); if (i.extensionsRequired && 0 <= i.extensionsRequired.indexOf(this.name)) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"); return null } } class c { constructor(e) { this.parser = e, this.name = d.EXT_TEXTURE_WEBP, this.isSupported = null } loadTexture(t) { const i = this.name, r = this.parser, n = r.json; if (!(e = n.textures[t]).extensions || !e.extensions[i]) return null; var e = e.extensions[i]; const a = n.images[e.source]; let o = r.textureLoader; return a.uri && null !== (e = r.options.manager.getHandler(a.uri)) && (o = e), this.detectSupport().then(function (e) { if (e) return r.loadTextureImage(t, a, o); if (n.extensionsRequired && 0 <= n.extensionsRequired.indexOf(i)) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported."); return r.loadTexture(t) }) } detectSupport() { return this.isSupported || (this.isSupported = new Promise(function (e) { const t = new Image; t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () { e(1 === t.height) } })), this.isSupported } } class h { constructor(e) { this.name = d.EXT_MESHOPT_COMPRESSION, this.parser = e } loadBufferView(e) { const t = this.parser.json; if ((e = t.bufferViews[e]).extensions && e.extensions[this.name]) { const o = e.extensions[this.name], s = (e = this.parser.getDependency("buffer", o.buffer), this.parser.options.meshoptDecoder); if (s && s.supported) return Promise.all([e, s.ready]).then(function (e) { var t = o.byteOffset || 0, i = o.byteLength || 0, r = o.count, n = o.byteStride, a = new ArrayBuffer(r * n), e = new Uint8Array(e[0], t, i); return s.decodeGltfBuffer(new Uint8Array(a), r, n, e, o.mode, o.filter), a }); if (t.extensionsRequired && 0 <= t.extensionsRequired.indexOf(this.name)) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"); return null } return null } } const f = "glTF", u = { JSON: 1313821514, BIN: 5130562 }; class m { constructor(e) { this.name = d.KHR_BINARY_GLTF, this.content = null, this.body = null; const t = new DataView(e, 0, 12); if (this.header = { magic: THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== f) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected."); var i = this.header.length - 12; const r = new DataView(e, 12); let n = 0; for (; n < i;) { var a, o = r.getUint32(n, !0), s = (n += 4, r.getUint32(n, !0)); n += 4, s === u.JSON ? (a = new Uint8Array(e, 12 + n, o), this.content = THREE.LoaderUtils.decodeText(a)) : s === u.BIN && (a = 12 + n, this.body = e.slice(a, a + o)), n += o } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } } class v { constructor(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = d.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload() } decodePrimitive(e, t) { var i = this.json; const r = this.dracoLoader; var n = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes; const o = {}, s = {}, l = {}; for (const p in a) { var c = S[p] || p.toLowerCase(); o[c] = a[p] } for (const f in e.attributes) { var h, u, d = S[f] || f.toLowerCase(); void 0 !== a[f] && (h = i.accessors[e.attributes[f]], u = b[h.componentType], l[d] = u, s[d] = !0 === h.normalized) } return t.getDependency("bufferView", n).then(function (e) { return new Promise(function (n) { r.decodeDracoFile(e, function (e) { for (const i in e.attributes) { const r = e.attributes[i]; var t = s[i]; void 0 !== t && (r.normalized = t) } n(e) }, o, l) }) }) } } class g { constructor() { this.name = d.KHR_TEXTURE_TRANSFORM } extendTexture(e, t) { return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e } } class x extends THREE.MeshStandardMaterial { constructor(e) { super(), this.isGLTFSpecularGlossinessMaterial = !0; const i = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), r = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), n = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), a = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), o = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), s = { specular: { value: (new THREE.Color).setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } }; this._extraUniforms = s, this.onBeforeCompile = function (e) { for (const t in s) e.uniforms[t] = s[t]; e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", i).replace("#include <metalnessmap_pars_fragment>", r).replace("#include <roughnessmap_fragment>", n).replace("#include <metalnessmap_fragment>", a).replace("#include <lights_physical_fragment>", o) }, Object.defineProperties(this, { specular: { get: function () { return s.specular.value }, set: function (e) { s.specular.value = e } }, specularMap: { get: function () { return s.specularMap.value }, set: function (e) { (s.specularMap.value = e) ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP } }, glossiness: { get: function () { return s.glossiness.value }, set: function (e) { s.glossiness.value = e } }, glossinessMap: { get: function () { return s.glossinessMap.value }, set: function (e) { (s.glossinessMap.value = e) ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV) } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e) } copy(e) { return super.copy(e), this.specularMap = e.specularMap, this.specular.copy(e.specular), this.glossinessMap = e.glossinessMap, this.glossiness = e.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this } } class H { constructor() { this.name = d.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"] } getMaterialType() { return x } extendParams(e, t, i) { var r, t = t.extensions[this.name]; e.color = new THREE.Color(1, 1, 1), e.opacity = 1; const n = []; return Array.isArray(t.diffuseFactor) && (r = t.diffuseFactor, e.color.fromArray(r), e.opacity = r[3]), void 0 !== t.diffuseTexture && n.push(i.assignTexture(e, "map", t.diffuseTexture)), e.emissive = new THREE.Color(0, 0, 0), e.glossiness = void 0 !== t.glossinessFactor ? t.glossinessFactor : 1, e.specular = new THREE.Color(1, 1, 1), Array.isArray(t.specularFactor) && e.specular.fromArray(t.specularFactor), void 0 !== t.specularGlossinessTexture && (r = t.specularGlossinessTexture, n.push(i.assignTexture(e, "glossinessMap", r)), n.push(i.assignTexture(e, "specularMap", r))), Promise.all(n) } createMaterial(e) { const t = new x(e); return t.fog = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, t.normalMapType = THREE.TangentSpaceNormalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t } } class B { constructor() { this.name = d.KHR_MESH_QUANTIZATION } } class _ extends THREE.Interpolant { constructor(e, t, i, r) { super(e, t, i, r) } copySampleValue_(e) { const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = e * r * 3 + r; for (let e = 0; e !== r; e++)t[e] = i[n + e]; return t } } _.prototype.beforeStart_ = _.prototype.copySampleValue_, _.prototype.afterEnd_ = _.prototype.copySampleValue_, _.prototype.interpolate_ = function (e, t, i, r) { const n = this.resultBuffer; var a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, c = r - t, h = e * l, u = h - l, d = -2 * (t = (i = (r = (i - t) / c) * r) * r) + 3 * i, p = t - i, f = 1 - d, m = p - i + r; for (let e = 0; e !== o; e++) { var v = a[u + e + o], g = a[u + e + s] * c, x = a[h + e + o], y = a[h + e] * c; n[e] = f * v + m * g + d * x + p * y } return n }; const y = { FLOAT: 5126, FLOAT_MAT3: 35675, FLOAT_MAT4: 35676, FLOAT_VEC2: 35664, FLOAT_VEC3: 35665, FLOAT_VEC4: 35666, LINEAR: 9729, REPEAT: 10497, SAMPLER_2D: 35678, POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6, UNSIGNED_BYTE: 5121, UNSIGNED_SHORT: 5123 }, b = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, w = { 9728: THREE.NearestFilter, 9729: THREE.LinearFilter, 9984: THREE.NearestMipmapNearestFilter, 9985: THREE.LinearMipmapNearestFilter, 9986: THREE.NearestMipmapLinearFilter, 9987: THREE.LinearMipmapLinearFilter }, E = { 33071: THREE.ClampToEdgeWrapping, 33648: THREE.MirroredRepeatWrapping, 10497: THREE.RepeatWrapping }, T = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, S = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, M = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, U = { CUBICSPLINE: void 0, LINEAR: THREE.InterpolateLinear, STEP: THREE.InterpolateDiscrete }, A = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }; function R(e, t) { return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e) } function z(e) { return void 0 === e.DefaultMaterial && (e.DefaultMaterial = new THREE.MeshStandardMaterial({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: THREE.FrontSide })), e.DefaultMaterial } function L(e, t, i) { for (const r in i.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = i.extensions[r]) } function P(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function O(i, r) { if (i.updateMorphTargets(), void 0 !== r.weights) for (let e = 0, t = r.weights.length; e < t; e++)i.morphTargetInfluences[e] = r.weights[e]; if (r.extras && Array.isArray(r.extras.targetNames)) { var n = r.extras.targetNames; if (i.morphTargetInfluences.length === n.length) { i.morphTargetDictionary = {}; for (let e = 0, t = n.length; e < t; e++)i.morphTargetDictionary[n[e]] = e } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function V(e) { var t = e.extensions && e.extensions[d.KHR_DRACO_MESH_COMPRESSION]; return t ? "draco:" + t.bufferView + ":" + t.indices + ":" + C(t.attributes) : e.indices + ":" + C(e.attributes) + ":" + e.mode } function C(i) { let r = ""; var n = Object.keys(i).sort(); for (let e = 0, t = n.length; e < t; e++)r += n[e] + ":" + i[n[e]] + ";"; return r } function F(e) { switch (e) { case Int8Array: return 1 / 127; case Uint8Array: return 1 / 255; case Int16Array: return 1 / 32767; case Uint16Array: return 1 / 65535; default: throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.") } } class k { constructor(e = {}, t = {}) { this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new i, this.associations = new Map, this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new THREE.ImageBitmapLoader(this.options.manager) : this.textureLoader = new THREE.TextureLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new THREE.FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0) } setExtensions(e) { this.extensions = e } setPlugins(e) { this.plugins = e } parse(i, e) { const r = this, n = this.json, a = this.extensions; this.cache.removeAll(), this._invokeAll(function (e) { return e._markDefs && e._markDefs() }), Promise.all(this._invokeAll(function (e) { return e.beforeRoot && e.beforeRoot() })).then(function () { return Promise.all([r.getDependencies("scene"), r.getDependencies("animation"), r.getDependencies("camera")]) }).then(function (e) { const t = { scene: e[0][n.scene || 0], scenes: e[0], animations: e[1], cameras: e[2], asset: n.asset, parser: r, userData: {} }; L(a, t, n), P(t, n), Promise.all(r._invokeAll(function (e) { return e.afterRoot && e.afterRoot(t) })).then(function () { i(t) }) }).catch(e) } _markDefs() { const i = this.json.nodes || []; var r = this.json.skins || []; const n = this.json.meshes || []; for (let e = 0, t = r.length; e < t; e++) { var a = r[e].joints; for (let e = 0, t = a.length; e < t; e++)i[a[e]].isBone = !0 } for (let e = 0, t = i.length; e < t; e++) { var o = i[e]; void 0 !== o.mesh && (this._addNodeRef(this.meshCache, o.mesh), void 0 !== o.skin && (n[o.mesh].isSkinnedMesh = !0)), void 0 !== o.camera && this._addNodeRef(this.cameraCache, o.camera) } } _addNodeRef(e, t) { void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++) } _getNodeRef(e, t, i) { if (e.refs[t] <= 1) return i; const r = i.clone(); return r.name += "_instance_" + e.uses[t]++, r } _invokeOne(t) { const i = Object.values(this.plugins); i.push(this); for (let e = 0; e < i.length; e++) { var r = t(i[e]); if (r) return r } return null } _invokeAll(t) { const i = Object.values(this.plugins), r = (i.unshift(this), []); for (let e = 0; e < i.length; e++) { var n = t(i[e]); n && r.push(n) } return r } getDependency(e, t) { var i = e + ":" + t; let r = this.cache.get(i); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this._invokeOne(function (e) { return e.loadMesh && e.loadMesh(t) }); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this._invokeOne(function (e) { return e.loadBufferView && e.loadBufferView(t) }); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this._invokeOne(function (e) { return e.loadMaterial && e.loadMaterial(t) }); break; case "texture": r = this._invokeOne(function (e) { return e.loadTexture && e.loadTexture(t) }); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this.loadAnimation(t); break; case "camera": r = this.loadCamera(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(i, r) } return r } getDependencies(i) { let e = this.cache.get(i); if (!e) { const r = this, t = this.json[i + ("mesh" === i ? "es" : "s")] || []; e = Promise.all(t.map(function (e, t) { return r.getDependency(i, t) })), this.cache.add(i, e) } return e } loadBuffer(e) { const i = this.json.buffers[e], r = this.fileLoader; if (i.type && "arraybuffer" !== i.type) throw new Error("THREE.GLTFLoader: " + i.type + " buffer type is not supported."); if (void 0 === i.uri && 0 === e) return Promise.resolve(this.extensions[d.KHR_BINARY_GLTF].body); const n = this.options; return new Promise(function (e, t) { r.load(R(i.uri, n.path), e, void 0, function () { t(new Error('THREE.GLTFLoader: Failed to load buffer "' + i.uri + '".')) }) }) } loadBufferView(e) { const r = this.json.bufferViews[e]; return this.getDependency("buffer", r.buffer).then(function (e) { var t = r.byteLength || 0, i = r.byteOffset || 0; return e.slice(i, i + t) }) } loadAccessor(e) { const v = this, g = this.json, x = this.json.accessors[e]; if (void 0 === x.bufferView && void 0 === x.sparse) return Promise.resolve(null); const t = []; return void 0 !== x.bufferView ? t.push(this.getDependency("bufferView", x.bufferView)) : t.push(null), void 0 !== x.sparse && (t.push(this.getDependency("bufferView", x.sparse.indices.bufferView)), t.push(this.getDependency("bufferView", x.sparse.values.bufferView))), Promise.all(t).then(function (e) { var t = e[0], i = T[x.type]; const r = b[x.componentType]; var n = r.BYTES_PER_ELEMENT, a = n * i, o = x.byteOffset || 0, s = void 0 !== x.bufferView ? g.bufferViews[x.bufferView].byteStride : void 0, l = !0 === x.normalized; let c, h; if (s && s !== a) { var a = Math.floor(o / s), u = "InterleavedBuffer:" + x.bufferView + ":" + x.componentType + ":" + a + ":" + x.count; let e = v.cache.get(u); e || (c = new r(t, a * s, x.count * s / n), e = new THREE.InterleavedBuffer(c, s / n), v.cache.add(u, e)), h = new THREE.InterleavedBufferAttribute(e, i, o % s / n, l) } else c = null === t ? new r(x.count * i) : new r(t, o, x.count * i), h = new THREE.BufferAttribute(c, i, l); if (void 0 !== x.sparse) { a = T.SCALAR; const m = b[x.sparse.indices.componentType]; var u = x.sparse.indices.byteOffset || 0, s = x.sparse.values.byteOffset || 0, d = new m(e[1], u, x.sparse.count * a), p = new r(e[2], s, x.sparse.count * i); null !== t && (h = new THREE.BufferAttribute(h.array.slice(), h.itemSize, h.normalized)); for (let e = 0, t = d.length; e < t; e++) { var f = d[e]; if (h.setX(f, p[e * i]), 2 <= i && h.setY(f, p[e * i + 1]), 3 <= i && h.setZ(f, p[e * i + 2]), 4 <= i && h.setW(f, p[e * i + 3]), 5 <= i) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.") } } return h }) } loadTexture(e) { var t = this.json; const i = this.options; var r = t.textures[e], t = t.images[r.source]; let n = this.textureLoader; return t.uri && null !== (r = i.manager.getHandler(t.uri)) && (n = r), this.loadTextureImage(e, t, n) } loadTextureImage(i, r, n) { const a = this, o = this.json, s = this.options, l = o.textures[i]; var e = (r.uri || r.bufferView) + ":" + l.sampler; if (this.textureCache[e]) return this.textureCache[e]; const c = self.URL || self.webkitURL; let h = r.uri || "", u = !1, d = !0; var t = 0 < h.search(/\.jpe?g($|\?)/i) || 0 === h.search(/^data\:image\/jpeg/); if ("image/jpeg" !== r.mimeType && !t || (d = !1), void 0 !== r.bufferView) h = a.getDependency("bufferView", r.bufferView).then(function (e) { "image/png" === r.mimeType && (t = new DataView(e, 25, 1).getUint8(0, !1), d = 6 === t || 4 === t || 3 === t), u = !0; var t = new Blob([e], { type: r.mimeType }); return h = c.createObjectURL(t) }); else if (void 0 === r.uri) throw new Error("THREE.GLTFLoader: Image " + i + " is missing URI and bufferView"); return t = Promise.resolve(h).then(function (r) { return new Promise(function (i, e) { let t = i; !0 === n.isImageBitmapLoader && (t = function (e) { const t = new THREE.Texture(e); t.needsUpdate = !0, i(t) }), n.load(R(r, s.path), t, void 0, e) }) }).then(function (e) { !0 === u && c.revokeObjectURL(h), e.flipY = !1, l.name && (e.name = l.name), d || (e.format = THREE.RGBFormat); var t = (o.samplers || {})[l.sampler] || {}; return e.magFilter = w[t.magFilter] || THREE.LinearFilter, e.minFilter = w[t.minFilter] || THREE.LinearMipmapLinearFilter, e.wrapS = E[t.wrapS] || THREE.RepeatWrapping, e.wrapT = E[t.wrapT] || THREE.RepeatWrapping, a.associations.set(e, { type: "textures", index: i }), e }).catch(function () { return console.error("THREE.GLTFLoader: Couldn't load texture", h), null }), this.textureCache[e] = t } assignTexture(r, n, a) { const o = this; return this.getDependency("texture", a.index).then(function (e) { var t, i; return void 0 === a.texCoord || 0 == a.texCoord || "aoMap" === n && 1 == a.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + a.texCoord + " for texture " + n + " not yet supported."), o.extensions[d.KHR_TEXTURE_TRANSFORM] && (t = void 0 !== a.extensions ? a.extensions[d.KHR_TEXTURE_TRANSFORM] : void 0) && (i = o.associations.get(e), e = o.extensions[d.KHR_TEXTURE_TRANSFORM].extendTexture(e, t), o.associations.set(e, i)), r[n] = e }) } assignFinalMaterial(e) { const t = e.geometry; let i = e.material; var r = void 0 !== t.attributes.tangent, n = void 0 !== t.attributes.color, a = void 0 === t.attributes.normal; if (e.isPoints) { var o = "PointsMaterial:" + i.uuid; let e = this.cache.get(o); e || (e = new THREE.PointsMaterial, THREE.Material.prototype.copy.call(e, i), e.color.copy(i.color), e.map = i.map, e.sizeAttenuation = !1, this.cache.add(o, e)), i = e } else if (e.isLine) { o = "LineBasicMaterial:" + i.uuid; let e = this.cache.get(o); e || (e = new THREE.LineBasicMaterial, THREE.Material.prototype.copy.call(e, i), e.color.copy(i.color), this.cache.add(o, e)), i = e } if (r || n || a) { let e = "ClonedMaterial:" + i.uuid + ":", t = (i.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"), r && (e += "vertex-tangents:"), n && (e += "vertex-colors:"), a && (e += "flat-shading:"), this.cache.get(e)); t || (t = i.clone(), n && (t.vertexColors = !0), a && (t.flatShading = !0), r && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(i))), i = t } i.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv), e.material = i } getMaterialType() { return THREE.MeshStandardMaterial } loadMaterial(t) { const i = this; var e = this.json; const r = this.extensions, n = e.materials[t]; let a; const o = {}, s = []; if ((e = n.extensions || {})[d.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { const c = r[d.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; a = c.getMaterialType(), s.push(c.extendParams(o, n, i)) } else if (e[d.KHR_MATERIALS_UNLIT]) { const h = r[d.KHR_MATERIALS_UNLIT]; a = h.getMaterialType(), s.push(h.extendParams(o, n, i)) } else e = n.pbrMetallicRoughness || {}, o.color = new THREE.Color(1, 1, 1), o.opacity = 1, Array.isArray(e.baseColorFactor) && (l = e.baseColorFactor, o.color.fromArray(l), o.opacity = l[3]), void 0 !== e.baseColorTexture && s.push(i.assignTexture(o, "map", e.baseColorTexture)), o.metalness = void 0 !== e.metallicFactor ? e.metallicFactor : 1, o.roughness = void 0 !== e.roughnessFactor ? e.roughnessFactor : 1, void 0 !== e.metallicRoughnessTexture && (s.push(i.assignTexture(o, "metalnessMap", e.metallicRoughnessTexture)), s.push(i.assignTexture(o, "roughnessMap", e.metallicRoughnessTexture))), a = this._invokeOne(function (e) { return e.getMaterialType && e.getMaterialType(t) }), s.push(Promise.all(this._invokeAll(function (e) { return e.extendMaterialParams && e.extendMaterialParams(t, o) }))); !0 === n.doubleSided && (o.side = THREE.DoubleSide); var l = n.alphaMode || A.OPAQUE; return l === A.BLEND ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, l === A.MASK && (o.alphaTest = void 0 !== n.alphaCutoff ? n.alphaCutoff : .5)), void 0 !== n.normalTexture && a !== THREE.MeshBasicMaterial && (s.push(i.assignTexture(o, "normalMap", n.normalTexture)), o.normalScale = new THREE.Vector2(1, -1), void 0 !== n.normalTexture.scale && o.normalScale.set(n.normalTexture.scale, -n.normalTexture.scale)), void 0 !== n.occlusionTexture && a !== THREE.MeshBasicMaterial && (s.push(i.assignTexture(o, "aoMap", n.occlusionTexture)), void 0 !== n.occlusionTexture.strength && (o.aoMapIntensity = n.occlusionTexture.strength)), void 0 !== n.emissiveFactor && a !== THREE.MeshBasicMaterial && (o.emissive = (new THREE.Color).fromArray(n.emissiveFactor)), void 0 !== n.emissiveTexture && a !== THREE.MeshBasicMaterial && s.push(i.assignTexture(o, "emissiveMap", n.emissiveTexture)), Promise.all(s).then(function () { let e; return e = a === x ? r[d.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o) : new a(o), n.name && (e.name = n.name), e.map && (e.map.encoding = THREE.sRGBEncoding), e.emissiveMap && (e.emissiveMap.encoding = THREE.sRGBEncoding), P(e, n), i.associations.set(e, { type: "materials", index: t }), n.extensions && L(r, e, n), e }) } createUniqueName(e) { var t = THREE.PropertyBinding.sanitizeNodeName(e || ""); let i = t; for (let e = 1; this.nodeNamesUsed[i]; ++e)i = t + "_" + e; return this.nodeNamesUsed[i] = !0, i } loadGeometries(i) { const r = this, n = this.extensions, a = this.primitiveCache, o = []; for (let e = 0, t = i.length; e < t; e++) { var s = i[e], l = V(s), c = a[l]; c ? o.push(c.promise) : (c = s.extensions && s.extensions[d.KHR_DRACO_MESH_COMPRESSION] ? function (t) { return n[d.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, r).then(function (e) { return I(e, t, r) }) }(s) : I(new THREE.BufferGeometry, s, r), a[l] = { primitive: s, promise: c }, o.push(c)) } return Promise.all(o) } loadMesh(c) { const h = this; var e = this.json; const u = this.extensions, d = e.meshes[c], p = d.primitives, i = []; for (let e = 0, t = p.length; e < t; e++) { var r = void 0 === p[e].material ? z(this.cache) : this.getDependency("material", p[e].material); i.push(r) } return i.push(h.loadGeometries(p)), Promise.all(i).then(function (e) { var i = e.slice(0, e.length - 1), r = e[e.length - 1]; const n = []; for (let t = 0, e = r.length; t < e; t++) { var a = r[t], o = p[t]; let e; var s = i[t]; if (o.mode === y.TRIANGLES || o.mode === y.TRIANGLE_STRIP || o.mode === y.TRIANGLE_FAN || void 0 === o.mode) !0 !== (e = new (!0 === d.isSkinnedMesh ? THREE.SkinnedMesh : THREE.Mesh)(a, s)).isSkinnedMesh || e.geometry.attributes.skinWeight.normalized || e.normalizeSkinWeights(), o.mode === y.TRIANGLE_STRIP ? e.geometry = N(e.geometry, THREE.TriangleStripDrawMode) : o.mode === y.TRIANGLE_FAN && (e.geometry = N(e.geometry, THREE.TriangleFanDrawMode)); else if (o.mode === y.LINES) e = new THREE.LineSegments(a, s); else if (o.mode === y.LINE_STRIP) e = new THREE.Line(a, s); else if (o.mode === y.LINE_LOOP) e = new THREE.LineLoop(a, s); else { if (o.mode !== y.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + o.mode); e = new THREE.Points(a, s) } 0 < Object.keys(e.geometry.morphAttributes).length && O(e, d), e.name = h.createUniqueName(d.name || "mesh_" + c), P(e, d), o.extensions && L(u, e, o), h.assignFinalMaterial(e), n.push(e) } if (1 === n.length) return n[0]; const l = new THREE.Group; for (let e = 0, t = n.length; e < t; e++)l.add(n[e]); return l }) } loadCamera(e) { let t; var i = (e = this.json.cameras[e])[e.type]; if (i) return "perspective" === e.type ? t = new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === e.type && (t = new THREE.OrthographicCamera(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), e.name && (t.name = this.createUniqueName(e.name)), P(t, e), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") } loadSkin(e) { const t = { joints: (e = this.json.skins[e]).joints }; return void 0 === e.inverseBindMatrices ? Promise.resolve(t) : this.getDependency("accessor", e.inverseBindMatrices).then(function (e) { return t.inverseBindMatrices = e, t }) } loadAnimation(t) { const y = this.json.animations[t], i = [], r = [], n = [], a = [], o = []; for (let e = 0, t = y.channels.length; e < t; e++) { var s = y.channels[e], l = y.samplers[s.sampler], c = void 0 !== (s = s.target).node ? s.node : s.id, h = void 0 !== y.parameters ? y.parameters[l.input] : l.input, u = void 0 !== y.parameters ? y.parameters[l.output] : l.output; i.push(this.getDependency("node", c)), r.push(this.getDependency("accessor", h)), n.push(this.getDependency("accessor", u)), a.push(l), o.push(s) } return Promise.all([Promise.all(i), Promise.all(r), Promise.all(n), Promise.all(a), Promise.all(o)]).then(function (e) { var i = e[0], r = e[1], n = e[2], a = e[3], o = e[4]; const s = []; for (let e = 0, t = i.length; e < t; e++) { const m = i[e]; var l = r[e], c = n[e], h = a[e], u = o[e]; if (void 0 !== m) { m.updateMatrix(), m.matrixAutoUpdate = !0; let i; switch (M[u.path]) { case M.weights: i = THREE.NumberKeyframeTrack; break; case M.rotation: i = THREE.QuaternionKeyframeTrack; break; case M.position: case M.scale: default: i = THREE.VectorKeyframeTrack }var d = m.name || m.uuid, p = void 0 !== h.interpolation ? U[h.interpolation] : THREE.InterpolateLinear; const v = []; M[u.path] === M.weights ? m.traverse(function (e) { !0 === e.isMesh && e.morphTargetInfluences && v.push(e.name || e.uuid) }) : v.push(d); let r = c.array; if (c.normalized) { var f = F(r.constructor); const g = new Float32Array(r.length); for (let e = 0, t = r.length; e < t; e++)g[e] = r[e] * f; r = g } for (let e = 0, t = v.length; e < t; e++) { const x = new i(v[e] + "." + M[u.path], l.array, r, p); "CUBICSPLINE" === h.interpolation && (x.createInterpolant = function (e) { return new _(this.times, this.values, this.getValueSize() / 3, e) }, x.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), s.push(x) } } } return e = y.name || "animation_" + t, new THREE.AnimationClip(e, void 0, s) }) } createNodeMesh(e) { var t = this.json; const i = this, r = t.nodes[e]; return void 0 === r.mesh ? null : i.getDependency("mesh", r.mesh).then(function (e) { const t = i._getNodeRef(i.meshCache, r.mesh, e); return void 0 !== r.weights && t.traverse(function (i) { if (i.isMesh) for (let e = 0, t = r.weights.length; e < t; e++)i.morphTargetInfluences[e] = r.weights[e] }), t }) } loadNode(n) { var e = this.json; const t = this.extensions, a = this, o = e.nodes[n], s = o.name ? a.createUniqueName(o.name) : ""; return function () { const t = []; var e = a._invokeOne(function (e) { return e.createNodeMesh && e.createNodeMesh(n) }); return e && t.push(e), void 0 !== o.camera && t.push(a.getDependency("camera", o.camera).then(function (e) { return a._getNodeRef(a.cameraCache, o.camera, e) })), a._invokeAll(function (e) { return e.createNodeAttachment && e.createNodeAttachment(n) }).forEach(function (e) { t.push(e) }), Promise.all(t) }().then(function (i) { let r; if ((r = !0 === o.isBone ? new THREE.Bone : 1 < i.length ? new THREE.Group : 1 === i.length ? i[0] : new THREE.Object3D) !== i[0]) for (let e = 0, t = i.length; e < t; e++)r.add(i[e]); if (o.name && (r.userData.name = o.name, r.name = s), P(r, o), o.extensions && L(t, r, o), void 0 !== o.matrix) { const e = new THREE.Matrix4; e.fromArray(o.matrix), r.applyMatrix4(e) } else void 0 !== o.translation && r.position.fromArray(o.translation), void 0 !== o.rotation && r.quaternion.fromArray(o.rotation), void 0 !== o.scale && r.scale.fromArray(o.scale); return a.associations.set(r, { type: "nodes", index: n }), r }) } loadScene(e) { var i = this.json, t = this.extensions, e = this.json.scenes[e]; const r = new THREE.Group; e.name && (r.name = this.createUniqueName(e.name)), P(r, e), e.extensions && L(t, r, e); var n = e.nodes || []; const a = []; for (let e = 0, t = n.length; e < t; e++)a.push(D(n[e], r, i, this)); return Promise.all(a).then(function () { return r }) } } function D(e, t, o, l) { const c = o.nodes[e]; return l.getDependency("node", e).then(function (e) { if (void 0 === c.skin) return e; let s; return l.getDependency("skin", c.skin).then(function (i) { const r = []; for (let e = 0, t = (s = i).joints.length; e < t; e++)r.push(l.getDependency("node", s.joints[e])); return Promise.all(r) }).then(function (o) { return e.traverse(function (e) { if (e.isMesh) { const r = [], n = []; for (let e = 0, t = o.length; e < t; e++) { var i = o[e]; if (i) { r.push(i); const a = new THREE.Matrix4; void 0 !== s.inverseBindMatrices && a.fromArray(s.inverseBindMatrices.array, 16 * e), n.push(a) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', s.joints[e]) } e.bind(new THREE.Skeleton(r, n), e.matrixWorld) } }), e }) }).then(function (i) { t.add(i); const r = []; if (c.children) { var n = c.children; for (let e = 0, t = n.length; e < t; e++) { var a = n[e]; r.push(D(a, i, o, l)) } } return Promise.all(r) }) } function I(d, e, p) { var t = e.attributes; const i = []; for (const v in t) { var r = S[v] || v.toLowerCase(); r in d.attributes || i.push(function (e, t) { return p.getDependency("accessor", e).then(function (e) { d.setAttribute(t, e) }) }(t[v], r)) } void 0 === e.indices || d.index || (n = p.getDependency("accessor", e.indices).then(function (e) { d.setIndex(e) }), i.push(n)), P(d, e); { var n = d, a = e, o = p, s = a.attributes; const g = new THREE.Box3; if (void 0 !== s.POSITION) { var l = (s = o.json.accessors[s.POSITION]).min, c = s.max; if (void 0 === l || void 0 === c) console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."); else { g.set(new THREE.Vector3(l[0], l[1], l[2]), new THREE.Vector3(c[0], c[1], c[2])), s.normalized && (l = F(b[s.componentType]), g.min.multiplyScalar(l), g.max.multiplyScalar(l)); var h = a.targets; if (void 0 !== h) { const y = new THREE.Vector3, _ = new THREE.Vector3; for (let e = 0, t = h.length; e < t; e++) { var u, f, m = h[e]; void 0 !== m.POSITION && (f = (m = o.json.accessors[m.POSITION]).min, u = m.max, void 0 !== f && void 0 !== u ? (_.setX(Math.max(Math.abs(f[0]), Math.abs(u[0]))), _.setY(Math.max(Math.abs(f[1]), Math.abs(u[1]))), _.setZ(Math.max(Math.abs(f[2]), Math.abs(u[2]))), m.normalized && (f = F(b[m.componentType]), _.multiplyScalar(f)), y.max(_)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")) } g.expandByVector(y) } n.boundingBox = g; const x = new THREE.Sphere; g.getCenter(x.center), x.radius = g.min.distanceTo(g.max) / 2, n.boundingSphere = x } } } return Promise.all(i).then(function () { if (void 0 === e.targets) return d; { var n = d, a = e.targets, o = p; let i = !1, r = !1; for (let e = 0, t = a.length; e < t; e++) { var s = a[e]; if (void 0 !== s.POSITION && (i = !0), void 0 !== s.NORMAL && (r = !0), i && r) break } if (!i && !r) return Promise.resolve(n); const h = [], u = []; for (let e = 0, t = a.length; e < t; e++) { var l, c = a[e]; i && (l = void 0 !== c.POSITION ? o.getDependency("accessor", c.POSITION) : n.attributes.position, h.push(l)), r && (l = void 0 !== c.NORMAL ? o.getDependency("accessor", c.NORMAL) : n.attributes.normal, u.push(l)) } return Promise.all([Promise.all(h), Promise.all(u)]).then(function (e) { var t = e[0], e = e[1]; return i && (n.morphAttributes.position = t), r && (n.morphAttributes.normal = e), n.morphTargetsRelative = !0, n }) } }) } function N(e, t) { let i = e.getIndex(); if (null === i) { const s = []; var r = e.getAttribute("position"); if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e; for (let e = 0; e < r.count; e++)s.push(e); e.setIndex(s), i = e.getIndex() } var n = i.count - 2; const a = []; if (t === THREE.TriangleFanDrawMode) for (let e = 1; e <= n; e++)a.push(i.getX(0)), a.push(i.getX(e)), a.push(i.getX(e + 1)); else for (let e = 0; e < n; e++)e % 2 == 0 ? (a.push(i.getX(e)), a.push(i.getX(e + 1)), a.push(i.getX(e + 2))) : (a.push(i.getX(e + 2)), a.push(i.getX(e + 1)), a.push(i.getX(e))); a.length / 3 != n && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."); const o = e.clone(); return o.setIndex(a), o } THREE.GLTFLoader = e }(), function () { class e extends THREE.Loader { load(t, i, e, r) { const n = new THREE.FileLoader(this.manager); n.setPath(this.path), n.setResponseType("text"), n.load(t, e => { try { i(this.parse(e)) } catch (e) { r ? r(e) : console.error(e), this.manager.itemError(t) } }, e, r) } parse(e) { const i = (e = e.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim()).split(/[\n\r]+/g); var r = i[0].trim().split(/\s+/g).map(e => parseFloat(e)), n = r[1] - r[0], a = r.length; for (let e = 1, t = r.length; e < t; e++)if (n != r[e] - r[e - 1]) throw new Error("LUT3dlLoader: Inconsistent grid size not supported."); const o = new Array(a * a * a * 3); let s = 0, l = 0; for (let e = 1, t = i.length; e < t; e++) { const v = i[e].trim(); var c = v.split(/\s/g), h = parseFloat(c[0]), u = parseFloat(c[1]), c = parseFloat(c[2]), d = (l = Math.max(l, h, u, c), s % a * a * a + Math.floor(s / a) % a * a + Math.floor(s / (a * a)) % a); o[3 * d + 0] = h, o[3 * d + 1] = u, o[3 * d + 2] = c, s += 1 } var e = Math.ceil(Math.log2(l)), p = Math.pow(2, e); for (let e = 0, t = o.length; e < t; e++) { var f = o[e]; o[e] = 255 * f / p } e = new Uint8Array(o); const t = new THREE.DataTexture, m = (t.image.data = e, t.image.width = a, t.image.height = a * a, t.format = THREE.RGBFormat, t.type = THREE.UnsignedByteType, t.magFilter = THREE.LinearFilter, t.minFilter = THREE.LinearFilter, t.wrapS = THREE.ClampToEdgeWrapping, t.wrapT = THREE.ClampToEdgeWrapping, t.generateMipmaps = !1, new THREE.DataTexture3D); return m.image.data = e, m.image.width = a, m.image.height = a, m.image.depth = a, m.format = THREE.RGBFormat, m.type = THREE.UnsignedByteType, m.magFilter = THREE.LinearFilter, m.minFilter = THREE.LinearFilter, m.wrapS = THREE.ClampToEdgeWrapping, m.wrapT = THREE.ClampToEdgeWrapping, m.wrapR = THREE.ClampToEdgeWrapping, m.generateMipmaps = !1, { size: a, texture: t, texture3D: m } } } THREE.LUT3dlLoader = e }(), function () { class e extends THREE.Loader { load(t, i, e, r) { const n = new THREE.FileLoader(this.manager); n.setPath(this.path), n.setResponseType("text"), n.load(t, e => { try { i(this.parse(e)) } catch (e) { r ? r(e) : console.error(e), this.manager.itemError(t) } }, e, r) } parse(e) { e = e.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim(); let i = null, r = null; const n = new THREE.Vector3(0, 0, 0), a = new THREE.Vector3(1, 1, 1), o = e.split(/[\n\r]+/g); let s = null, l = 0; for (let e = 0, t = o.length; e < t; e++) { const f = o[e].trim(); var c = f.split(/\s/g); switch (c[0]) { case "TITLE": i = f.substring(7, f.length - 1); break; case "LUT_3D_SIZE": var h = c[1]; r = parseFloat(h), s = new Uint8Array(r * r * r * 3); break; case "DOMAIN_MIN": n.x = parseFloat(c[1]), n.y = parseFloat(c[2]), n.z = parseFloat(c[3]); break; case "DOMAIN_MAX": a.x = parseFloat(c[1]), a.y = parseFloat(c[2]), a.z = parseFloat(c[3]); break; default: var h = parseFloat(c[0]), u = parseFloat(c[1]), d = parseFloat(c[2]); if (1 < h || h < 0 || 1 < u || u < 0 || 1 < d || d < 0) throw new Error("LUTCubeLoader : Non normalized values not supported."); s[l + 0] = 255 * h, s[l + 1] = 255 * u, s[l + 2] = 255 * d, l += 3 } } const t = new THREE.DataTexture, p = (t.image.data = s, t.image.width = r, t.image.height = r * r, t.format = THREE.RGBFormat, t.type = THREE.UnsignedByteType, t.magFilter = THREE.LinearFilter, t.minFilter = THREE.LinearFilter, t.wrapS = THREE.ClampToEdgeWrapping, t.wrapT = THREE.ClampToEdgeWrapping, t.generateMipmaps = !1, new THREE.DataTexture3D); return p.image.data = s, p.image.width = r, p.image.height = r, p.image.depth = r, p.format = THREE.RGBFormat, p.type = THREE.UnsignedByteType, p.magFilter = THREE.LinearFilter, p.minFilter = THREE.LinearFilter, p.wrapS = THREE.ClampToEdgeWrapping, p.wrapT = THREE.ClampToEdgeWrapping, p.wrapR = THREE.ClampToEdgeWrapping, p.generateMipmaps = !1, { title: i, size: r, domainMin: n, domainMax: a, texture: t, texture3D: p } } } THREE.LUTCubeLoader = e }(), function () { const p = new THREE.Vector3, f = new THREE.Vector3, m = new THREE.Vector3; THREE.Capsule = class e { constructor(e = new THREE.Vector3(0, 0, 0), t = new THREE.Vector3(0, 1, 0), i = 1) { this.start = e, this.end = t, this.radius = i } clone() { return new e(this.start.clone(), this.end.clone(), this.radius) } set(e, t, i) { this.start.copy(e), this.end.copy(t), this.radius = i } copy(e) { this.start.copy(e.start), this.end.copy(e.end), this.radius = e.radius } getCenter(e) { return e.copy(this.end).add(this.start).multiplyScalar(.5) } translate(e) { this.start.add(e), this.end.add(e) } checkAABBAxis(e, t, i, r, n, a, o, s, l) { return (n - e < l || n - i < l) && (e - a < l || i - a < l) && (o - t < l || o - r < l) && (t - s < l || r - s < l) } intersectsBox(e) { return this.checkAABBAxis(this.start.x, this.start.y, this.end.x, this.end.y, e.min.x, e.max.x, e.min.y, e.max.y, this.radius) && this.checkAABBAxis(this.start.x, this.start.z, this.end.x, this.end.z, e.min.x, e.max.x, e.min.z, e.max.z, this.radius) && this.checkAABBAxis(this.start.y, this.start.z, this.end.y, this.end.z, e.min.y, e.max.y, e.min.z, e.max.z, this.radius) } lineLineMinimumPoints(e, t) { const i = p.copy(e.end).sub(e.start), r = f.copy(t.end).sub(t.start); var n = m.copy(t.start).sub(e.start), a = i.dot(r), o = i.dot(i), s = r.dot(r), l = r.dot(n), n = i.dot(n); let c, h; var u, o = o * s - a * a, d = (h = Math.abs(o) < 1e-10 ? (d = -l / s, u = (a - l) / s, Math.abs(d - .5) < Math.abs(u - .5) ? (c = 0, d) : (c = 1, u)) : ((c = (l * a + n * s) / o) * a - l) / s, h = Math.max(0, Math.min(1, h)), c = Math.max(0, Math.min(1, c)), i.multiplyScalar(c).add(e.start)); return [d, r.multiplyScalar(h).add(t.start)] } } }(), function () { const i = {}; THREE.ColorConverter = class { static setHSV(e, t, i, r) { return t = THREE.MathUtils.euclideanModulo(t, 1), i = THREE.MathUtils.clamp(i, 0, 1), r = THREE.MathUtils.clamp(r, 0, 1), e.setHSL(t, i * r / ((t = (2 - i) * r) < 1 ? t : 2 - t), .5 * t) } static getHSV(e, t) { return void 0 === t && (console.warn("THREE.ColorConverter: .getHSV() target is now required"), t = { h: 0, s: 0, l: 0 }), e.getHSL(i), i.s *= i.l < .5 ? i.l : 1 - i.l, t.h = i.h, t.s = 2 * i.s / (i.l + i.s), t.v = i.l + i.s, t } static setCMYK(e, t, i, r, n) { return e.setRGB((1 - t) * (1 - n), (1 - i) * (1 - n), (1 - r) * (1 - n)) } static getCMYK(e, t) { void 0 === t && (console.warn("THREE.ColorConverter: .getCMYK() target is now required"), t = { c: 0, m: 0, y: 0, k: 0 }); var i = e.r, r = e.g, e = e.b, n = 1 - Math.max(i, r, e), r = (1 - r - n) / (1 - n), e = (1 - e - n) / (1 - n); return t.c = (1 - i - n) / (1 - n), t.m = r, t.y = e, t.k = n, t } } }(), function () { const t = new THREE.Vector3, _ = new THREE.Line3, b = new THREE.Plane, w = new THREE.Vector3, r = new THREE.Triangle; class E { constructor() { this.normal = new THREE.Vector3, this.midpoint = new THREE.Vector3, this.area = 0, this.constant = 0, this.outside = null, this.mark = 0, this.edge = null } static create(e, t, i) { const r = new E, n = new s(e, r), a = new s(t, r), o = new s(i, r); return ((n.next = o.prev = a).next = n.prev = o).next = a.prev = n, r.edge = n, r.compute() } getEdge(e) { let t = this.edge; for (; 0 < e;)t = t.next, e--; for (; e < 0;)t = t.prev, e++; return t } compute() { var e = this.edge.tail(), t = this.edge.head(), i = this.edge.next.head(); return r.set(e.point, t.point, i.point), r.getNormal(this.normal), r.getMidpoint(this.midpoint), this.area = r.getArea(), this.constant = this.normal.dot(this.midpoint), this } distanceToPoint(e) { return this.normal.dot(e) - this.constant } } class s { constructor(e, t) { this.vertex = e, this.prev = null, this.next = null, this.twin = null, this.face = t } head() { return this.vertex } tail() { return this.prev ? this.prev.vertex : null } length() { var e = this.head(); const t = this.tail(); return null !== t ? t.point.distanceTo(e.point) : -1 } lengthSquared() { var e = this.head(); const t = this.tail(); return null !== t ? t.point.distanceToSquared(e.point) : -1 } setTwin(e) { return (this.twin = e).twin = this } } class n { constructor(e) { this.point = e, this.prev = null, this.next = null, this.face = null } } class e { constructor() { this.head = null, this.tail = null } first() { return this.head } last() { return this.tail } clear() { return this.head = this.tail = null, this } insertBefore(e, t) { return t.prev = e.prev, t.next = e, null === t.prev ? this.head = t : t.prev.next = t, e.prev = t, this } insertAfter(e, t) { return t.prev = e, t.next = e.next, null === t.next ? this.tail = t : t.next.prev = t, e.next = t, this } append(e) { return null === this.head ? this.head = e : this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e, this } appendChain(e) { for (null === this.head ? this.head = e : this.tail.next = e, e.prev = this.tail; null !== e.next;)e = e.next; return this.tail = e, this } remove(e) { return null === e.prev ? this.head = e.next : e.prev.next = e.next, null === e.next ? this.tail = e.prev : e.next.prev = e.prev, this } removeSubList(e, t) { return null === e.prev ? this.head = t.next : e.prev.next = t.next, null === t.next ? this.tail = e.prev : t.next.prev = e.prev, this } isEmpty() { return null === this.head } } THREE.ConvexHull = class { constructor() { this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new e, this.unassigned = new e, this.vertices = [] } setFromPoints(i) { !0 !== Array.isArray(i) && console.error("THREE.ConvexHull: Points parameter is not an array."), i.length < 4 && console.error("THREE.ConvexHull: The algorithm needs at least four points."), this.makeEmpty(); for (let e = 0, t = i.length; e < t; e++)this.vertices.push(new n(i[e])); return this.compute(), this } setFromObject(e) { const a = []; return e.updateMatrixWorld(!0), e.traverse(function (i) { var e = i.geometry; if (void 0 !== e) if (e.isGeometry) console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead."); else if (e.isBufferGeometry) { var r = e.attributes.position; if (void 0 !== r) for (let e = 0, t = r.count; e < t; e++) { const n = new THREE.Vector3; n.fromBufferAttribute(r, e).applyMatrix4(i.matrixWorld), a.push(n) } } }), this.setFromPoints(a) } containsPoint(i) { var r = this.faces; for (let e = 0, t = r.length; e < t; e++) { const n = r[e]; if (n.distanceToPoint(i) > this.tolerance) return !1 } return !0 } intersectRay(i, e) { var r = this.faces; let n = -1 / 0, a = 1 / 0; for (let e = 0, t = r.length; e < t; e++) { const l = r[e]; var o = l.distanceToPoint(i.origin), s = l.normal.dot(i.direction); if (0 < o && 0 <= s) return null; if (!((o = 0 !== s ? -o / s : 0) <= 0) && (0 < s ? a = Math.min(o, a) : n = Math.max(o, n), n > a)) return null } return n !== -1 / 0 ? i.at(n, e) : i.at(a, e), e } intersectsRay(e) { return null !== this.intersectRay(e, t) } makeEmpty() { return this.faces = [], this.vertices = [], this } addVertexToFace(e, t) { return null === (e.face = t).outside ? this.assigned.append(e) : this.assigned.insertBefore(t.outside, e), t.outside = e, this } removeVertexFromFace(e, t) { return e === t.outside && (null !== e.next && e.next.face === t ? t.outside = e.next : t.outside = null), this.assigned.remove(e), this } removeAllVerticesFromFace(t) { if (null !== t.outside) { const i = t.outside; let e = t.outside; for (; null !== e.next && e.next.face === t;)e = e.next; return this.assigned.removeSubList(i, e), i.prev = e.next = null, t.outside = null, i } } deleteFaceVertices(t, i) { if (void 0 !== (t = this.removeAllVerticesFromFace(t))) if (void 0 === i) this.unassigned.appendChain(t); else { let e = t; do { var r = e.next } while (i.distanceToPoint(e.point) > this.tolerance ? this.addVertexToFace(e, i) : this.unassigned.append(e), null !== (e = r)) } return this } resolveUnassignedPoints(n) { if (!1 === this.unassigned.isEmpty()) { let r = this.unassigned.first(); do { var e = r.next; let t = this.tolerance, i = null; for (let e = 0; e < n.length; e++) { const o = n[e]; if (0 === o.mark) { var a = o.distanceToPoint(r.point); if (a > t && (t = a, i = o), t > 1e3 * this.tolerance) break } } null !== i && this.addVertexToFace(r, i), r = e } while (null !== r) } return this } computeExtremes() { const i = new THREE.Vector3, r = new THREE.Vector3, n = [], a = []; for (let e = 0; e < 3; e++)n[e] = a[e] = this.vertices[0]; i.copy(this.vertices[0].point), r.copy(this.vertices[0].point); for (let e = 0, t = this.vertices.length; e < t; e++) { var o = this.vertices[e]; const s = o.point; for (let e = 0; e < 3; e++)s.getComponent(e) < i.getComponent(e) && (i.setComponent(e, s.getComponent(e)), n[e] = o); for (let e = 0; e < 3; e++)s.getComponent(e) > r.getComponent(e) && (r.setComponent(e, s.getComponent(e)), a[e] = o) } return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(i.x), Math.abs(r.x)) + Math.max(Math.abs(i.y), Math.abs(r.y)) + Math.max(Math.abs(i.z), Math.abs(r.z))), { min: n, max: a } } computeInitialHull() { var i = this.vertices, e = this.computeExtremes(); const t = e.min, r = e.max; let n = 0, a = 0; for (let e = 0; e < 3; e++) { var o = r[e].point.getComponent(e) - t[e].point.getComponent(e); o > n && (n = o, a = e) } var s = t[a], l = r[a]; let c, h; n = 0, _.set(s.point, l.point); for (let e = 0, t = this.vertices.length; e < t; e++) { var u, d = i[e]; d !== s && d !== l && (_.closestPointToPoint(d.point, !0, w), (u = w.distanceToSquared(d.point)) > n && (n = u, c = d)) } n = -1, b.setFromCoplanarPoints(s.point, l.point, c.point); for (let e = 0, t = this.vertices.length; e < t; e++) { var p, f = i[e]; f !== s && f !== l && f !== c && (p = Math.abs(b.distanceToPoint(f.point))) > n && (n = p, h = f) } const m = []; if (b.distanceToPoint(h.point) < 0) { m.push(E.create(s, l, c), E.create(h, l, s), E.create(h, c, l), E.create(h, s, c)); for (let e = 0; e < 3; e++) { var v = (e + 1) % 3; m[e + 1].getEdge(2).setTwin(m[0].getEdge(v)), m[e + 1].getEdge(1).setTwin(m[1 + v].getEdge(0)) } } else { m.push(E.create(s, c, l), E.create(h, s, l), E.create(h, l, c), E.create(h, c, s)); for (let e = 0; e < 3; e++) { var g = (e + 1) % 3; m[e + 1].getEdge(2).setTwin(m[0].getEdge((3 - e) % 3)), m[e + 1].getEdge(0).setTwin(m[1 + g].getEdge(1)) } } for (let e = 0; e < 4; e++)this.faces.push(m[e]); for (let e = 0, t = i.length; e < t; e++) { var x = i[e]; if (x !== s && x !== l && x !== c && x !== h) { n = this.tolerance; let t = null; for (let e = 0; e < 4; e++) { var y = this.faces[e].distanceToPoint(x.point); y > n && (n = y, t = this.faces[e]) } null !== t && this.addVertexToFace(x, t) } } return this } reindexFaces() { const t = []; for (let e = 0; e < this.faces.length; e++) { var i = this.faces[e]; 0 === i.mark && t.push(i) } return this.faces = t, this } nextVertexToAdd() { if (!1 === this.assigned.isEmpty()) { let e, t = 0; const n = this.assigned.first().face; let i = n.outside; do { var r = n.distanceToPoint(i.point) } while (r > t && (t = r, e = i), null !== (i = i.next) && i.face === n); return e } } computeHorizon(e, t, i, r) { this.deleteFaceVertices(i), i.mark = 1; let n; n = null === t ? t = i.getEdge(0) : t.next; do { var a = n.twin; const o = a.face; 0 === o.mark && (o.distanceToPoint(e) > this.tolerance ? this.computeHorizon(e, a, o, r) : r.push(n)), n = n.next } while (n !== t); return this } addAdjoiningFace(e, t) { const i = E.create(e, t.tail(), t.head()); return this.faces.push(i), i.getEdge(-1).setTwin(t.twin), i.getEdge(0) } addNewFaces(t, i) { this.newFaces = []; let r = null, n = null; for (let e = 0; e < i.length; e++) { var a = i[e]; const o = this.addAdjoiningFace(t, a); null === r ? r = o : o.next.setTwin(n), this.newFaces.push(o.face), n = o } return r.next.setTwin(n), this } addVertexToHull(e) { var t = []; return this.unassigned.clear(), this.removeVertexFromFace(e, e.face), this.computeHorizon(e.point, null, e.face, t), this.addNewFaces(e, t), this.resolveUnassignedPoints(this.newFaces), this } cleanup() { return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this } compute() { var e; for (this.computeInitialHull(); void 0 !== (e = this.nextVertexToAdd());)this.addVertexToHull(e); return this.reindexFaces(), this.cleanup(), this } } }(), function () { const f = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; for (let e = 0; e < 256; e++)f[256 + e] = f[e]; function m(e) { return e * e * e * (e * (6 * e - 15) + 10) } function v(e, t, i) { return t + e * (i - t) } function g(e, t, i, r) { var n = (e &= 15) < 8 ? t : i, i = e < 4 ? i : 12 == e || 14 == e ? t : r; return (0 == (1 & e) ? n : -n) + (0 == (2 & e) ? i : -i) } THREE.ImprovedNoise = class { noise(e, t, i) { var r = 255 & (o = Math.floor(e)), n = 255 & (s = Math.floor(t)), a = 255 & (l = Math.floor(i)), o = (e -= o) - 1, s = (t -= s) - 1, l = (i -= l) - 1, c = m(e), h = m(t), u = m(i), d = f[r] + n, p = f[d] + a, d = f[d + 1] + a, r = f[1 + r] + n, n = f[r] + a, r = f[r + 1] + a; return v(u, v(h, v(c, g(f[p], e, t, i), g(f[n], o, t, i)), v(c, g(f[d], e, s, i), g(f[r], o, s, i))), v(h, v(c, g(f[p + 1], e, t, l), g(f[n + 1], o, t, l)), v(c, g(f[d + 1], e, s, l), g(f[r + 1], o, s, l)))) } } }(), function () { class e { constructor(e, t = 32) { this.lut = [], this.map = [], this.n = 0, this.minV = 0, this.maxV = 1, this.setColorMap(e, t) } set(e) { return !0 === e.isLut && this.copy(e), this } setMin(e) { return this.minV = e, this } setMax(e) { return this.maxV = e, this } setColorMap(e, t = 32) { this.map = s[e] || s.rainbow, this.n = t; var i = 1 / this.n; for (let t = this.lut.length = 0; t <= 1; t += i)for (let e = 0; e < this.map.length - 1; e++)if (t >= this.map[e][0] && t < this.map[e + 1][0]) { var r = this.map[e][0], n = this.map[e + 1][0]; const o = new THREE.Color(this.map[e][1]); var a = new THREE.Color(this.map[e + 1][1]), a = o.lerp(a, (t - r) / (n - r)); this.lut.push(a) } return this } copy(e) { return this.lut = e.lut, this.map = e.map, this.n = e.n, this.minV = e.minV, this.maxV = e.maxV, this } getColor(e) { e <= this.minV ? e = this.minV : e >= this.maxV && (e = this.maxV), e = (e - this.minV) / (this.maxV - this.minV); let t = Math.round(e * this.n); return t == this.n ? --t : t, this.lut[t] } addColorMap(e, t) { return s[e] = t, this } createCanvas() { const e = document.createElement("canvas"); return e.width = 1, e.height = this.n, this.updateCanvas(e), e } updateCanvas(e) { const t = e.getContext("2d", { alpha: !1 }); var i = t.getImageData(0, 0, 1, this.n); const r = i.data; let n = 0; var a = 1 / this.n; for (let t = 1; 0 <= t; t -= a)for (let e = this.map.length - 1; 0 <= e; e--)if (t < this.map[e][0] && t >= this.map[e - 1][0]) { var o = this.map[e - 1][0], s = this.map[e][0]; const c = new THREE.Color(this.map[e - 1][1]); var l = new THREE.Color(this.map[e][1]), l = c.lerp(l, (t - o) / (s - o)); r[4 * n] = Math.round(255 * l.r), r[4 * n + 1] = Math.round(255 * l.g), r[4 * n + 2] = Math.round(255 * l.b), r[4 * n + 3] = 255, n += 1 } return t.putImageData(i, 0, 0), e } } e.prototype.isLut = !0; const s = { rainbow: [[0, 255], [.2, 65535], [.5, 65280], [.8, 16776960], [1, 16711680]], cooltowarm: [[0, 3952322], [.2, 10206463], [.5, 14474460], [.8, 16163717], [1, 11797542]], blackbody: [[0, 0], [.2, 7864320], [.5, 15086080], [.8, 16776960], [1, 16777215]], grayscale: [[0, 0], [.2, 4210752], [.5, 8355712], [.8, 12566463], [1, 16777215]] }; THREE.ColorMapKeywords = s, THREE.Lut = e }(), function () { const o = new THREE.Triangle, s = new THREE.Vector3; THREE.MeshSurfaceSampler = class { constructor(e) { let t = e.geometry; if (!t.isBufferGeometry || 3 !== t.attributes.position.itemSize) throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh."); t.index && (console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."), t = t.toNonIndexed()), this.geometry = t, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.colorAttribute = this.geometry.getAttribute("color"), this.weightAttribute = null, this.distribution = null } setWeightAttribute(e) { return this.weightAttribute = e ? this.geometry.getAttribute(e) : null, this } build() { var i = this.positionAttribute; const r = this.weightAttribute, n = new Float32Array(i.count / 3); for (let t = 0; t < i.count; t += 3) { let e = 1; r && (e = r.getX(t) + r.getX(t + 1) + r.getX(t + 2)), o.a.fromBufferAttribute(i, t), o.b.fromBufferAttribute(i, t + 1), o.c.fromBufferAttribute(i, t + 2), e *= o.getArea(), n[t / 3] = e } this.distribution = new Float32Array(i.count / 3); let t = 0; for (let e = 0; e < n.length; e++)t += n[e], this.distribution[e] = t; return this } setRandomGenerator(e) { return this.randomFunction = e, this } sample(e, t, i) { var r = this.distribution[this.distribution.length - 1], r = this.binarySearch(this.randomFunction() * r); return this.sampleFace(r, e, t, i) } binarySearch(e) { var t = this.distribution; let i = 0, r = t.length - 1, n = -1; for (; i <= r;) { var a = Math.ceil((i + r) / 2); if (0 === a || t[a - 1] <= e && t[a] > e) { n = a; break } e < t[a] ? r = a - 1 : i = a + 1 } return n } sampleFace(e, t, i, r) { let n = this.randomFunction(), a = this.randomFunction(); return 1 < n + a && (n = 1 - n, a = 1 - a), o.a.fromBufferAttribute(this.positionAttribute, 3 * e), o.b.fromBufferAttribute(this.positionAttribute, 3 * e + 1), o.c.fromBufferAttribute(this.positionAttribute, 3 * e + 2), t.set(0, 0, 0).addScaledVector(o.a, n).addScaledVector(o.b, a).addScaledVector(o.c, 1 - (n + a)), void 0 !== i && o.getNormal(i), void 0 !== r && void 0 !== this.colorAttribute && (o.a.fromBufferAttribute(this.colorAttribute, 3 * e), o.b.fromBufferAttribute(this.colorAttribute, 3 * e + 1), o.c.fromBufferAttribute(this.colorAttribute, 3 * e + 2), s.set(0, 0, 0).addScaledVector(o.a, n).addScaledVector(o.b, a).addScaledVector(o.c, 1 - (n + a)), r.r = s.x, r.g = s.y, r.b = s.z), this } } }(), function () { const n = { c: null, u: [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], e: [] }, a = { c: null, u: [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], e: [] }, o = [[], [], []], s = [[], [], []], l = [], r = new THREE.Vector3, c = new THREE.Vector3, h = new THREE.Vector3, u = new THREE.Vector3, i = new THREE.Vector3, t = new THREE.Vector3, d = new THREE.Matrix3, p = new THREE.Box3, f = new THREE.Matrix4, m = new THREE.Matrix4, v = new THREE.Ray; class e { constructor(e = new THREE.Vector3, t = new THREE.Vector3, i = new THREE.Matrix3) { this.center = e, this.halfSize = t, this.rotation = i } set(e, t, i) { return this.center = e, this.halfSize = t, this.rotation = i, this } copy(e) { return this.center.copy(e.center), this.halfSize.copy(e.halfSize), this.rotation.copy(e.rotation), this } clone() { return (new this.constructor).copy(this) } getSize(e) { return e.copy(this.halfSize).multiplyScalar(2) } clampPoint(e, t) { var i = this.halfSize, e = (u.subVectors(e, this.center), this.rotation.extractBasis(r, c, h), t.copy(this.center), THREE.MathUtils.clamp(u.dot(r), -i.x, i.x)), e = (t.add(r.multiplyScalar(e)), THREE.MathUtils.clamp(u.dot(c), -i.y, i.y)), e = (t.add(c.multiplyScalar(e)), THREE.MathUtils.clamp(u.dot(h), -i.z, i.z)); return t.add(h.multiplyScalar(e)), t } containsPoint(e) { return u.subVectors(e, this.center), this.rotation.extractBasis(r, c, h), Math.abs(u.dot(r)) <= this.halfSize.x && Math.abs(u.dot(c)) <= this.halfSize.y && Math.abs(u.dot(h)) <= this.halfSize.z } intersectsBox3(e) { return this.intersectsOBB(g.fromBox3(e)) } intersectsSphere(e) { return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius } intersectsOBB(e, i = Number.EPSILON) { n.c = this.center, n.e[0] = this.halfSize.x, n.e[1] = this.halfSize.y, n.e[2] = this.halfSize.z, this.rotation.extractBasis(n.u[0], n.u[1], n.u[2]), a.c = e.center, a.e[0] = e.halfSize.x, a.e[1] = e.halfSize.y, a.e[2] = e.halfSize.z, e.rotation.extractBasis(a.u[0], a.u[1], a.u[2]); for (let t = 0; t < 3; t++)for (let e = 0; e < 3; e++)o[t][e] = n.u[t].dot(a.u[e]); u.subVectors(a.c, n.c), l[0] = u.dot(n.u[0]), l[1] = u.dot(n.u[1]), l[2] = u.dot(n.u[2]); for (let t = 0; t < 3; t++)for (let e = 0; e < 3; e++)s[t][e] = Math.abs(o[t][e]) + i; let t, r; for (let e = 0; e < 3; e++)if (t = n.e[e], r = a.e[0] * s[e][0] + a.e[1] * s[e][1] + a.e[2] * s[e][2], Math.abs(l[e]) > t + r) return !1; for (let e = 0; e < 3; e++)if (t = n.e[0] * s[0][e] + n.e[1] * s[1][e] + n.e[2] * s[2][e], r = a.e[e], Math.abs(l[0] * o[0][e] + l[1] * o[1][e] + l[2] * o[2][e]) > t + r) return !1; return t = n.e[1] * s[2][0] + n.e[2] * s[1][0], r = a.e[1] * s[0][2] + a.e[2] * s[0][1], !(Math.abs(l[2] * o[1][0] - l[1] * o[2][0]) > t + r || (t = n.e[1] * s[2][1] + n.e[2] * s[1][1], r = a.e[0] * s[0][2] + a.e[2] * s[0][0], Math.abs(l[2] * o[1][1] - l[1] * o[2][1]) > t + r || (t = n.e[1] * s[2][2] + n.e[2] * s[1][2], r = a.e[0] * s[0][1] + a.e[1] * s[0][0], Math.abs(l[2] * o[1][2] - l[1] * o[2][2]) > t + r || (t = n.e[0] * s[2][0] + n.e[2] * s[0][0], r = a.e[1] * s[1][2] + a.e[2] * s[1][1], Math.abs(l[0] * o[2][0] - l[2] * o[0][0]) > t + r || (t = n.e[0] * s[2][1] + n.e[2] * s[0][1], r = a.e[0] * s[1][2] + a.e[2] * s[1][0], Math.abs(l[0] * o[2][1] - l[2] * o[0][1]) > t + r || (t = n.e[0] * s[2][2] + n.e[2] * s[0][2], r = a.e[0] * s[1][1] + a.e[1] * s[1][0], Math.abs(l[0] * o[2][2] - l[2] * o[0][2]) > t + r || (t = n.e[0] * s[1][0] + n.e[1] * s[0][0], r = a.e[1] * s[2][2] + a.e[2] * s[2][1], Math.abs(l[1] * o[0][0] - l[0] * o[1][0]) > t + r || (t = n.e[0] * s[1][1] + n.e[1] * s[0][1], r = a.e[0] * s[2][2] + a.e[2] * s[2][0], Math.abs(l[1] * o[0][1] - l[0] * o[1][1]) > t + r || (t = n.e[0] * s[1][2] + n.e[1] * s[0][2], r = a.e[0] * s[2][1] + a.e[1] * s[2][0], Math.abs(l[1] * o[0][2] - l[0] * o[1][2]) > t + r))))))))) } intersectsPlane(e) { this.rotation.extractBasis(r, c, h); var t = this.halfSize.x * Math.abs(e.normal.dot(r)) + this.halfSize.y * Math.abs(e.normal.dot(c)) + this.halfSize.z * Math.abs(e.normal.dot(h)), e = e.normal.dot(this.center) - e.constant; return Math.abs(e) <= t } intersectRay(e, t) { return this.getSize(i), p.setFromCenterAndSize(u.set(0, 0, 0), i), f.setFromMatrix3(this.rotation), f.setPosition(this.center), m.copy(f).invert(), v.copy(e).applyMatrix4(m), v.intersectBox(p, t) ? t.applyMatrix4(f) : null } intersectsRay(e) { return null !== this.intersectRay(e, u) } fromBox3(e) { return e.getCenter(this.center), e.getSize(this.halfSize).multiplyScalar(.5), this.rotation.identity(), this } equals(e) { return e.center.equals(this.center) && e.halfSize.equals(this.halfSize) && e.rotation.equals(this.rotation) } applyMatrix4(e) { var t = e.elements; let i = u.set(t[0], t[1], t[2]).length(); var r = u.set(t[4], t[5], t[6]).length(), t = u.set(t[8], t[9], t[10]).length(), n = (e.determinant() < 0 && (i = -i), d.setFromMatrix4(e), 1 / i), a = 1 / r, o = 1 / t; return d.elements[0] *= n, d.elements[1] *= n, d.elements[2] *= n, d.elements[3] *= a, d.elements[4] *= a, d.elements[5] *= a, d.elements[6] *= o, d.elements[7] *= o, d.elements[8] *= o, this.rotation.multiply(d), this.halfSize.x *= i, this.halfSize.y *= r, this.halfSize.z *= t, u.setFromMatrixPosition(e), this.center.add(u), this } } const g = new e; THREE.OBB = e }(), function () { const d = new THREE.Vector3, l = new THREE.Vector3, p = new THREE.Plane, f = new THREE.Line3, m = new THREE.Line3, a = new THREE.Sphere, o = new THREE.Capsule; THREE.Octree = class c { constructor(e) { this.triangles = [], this.box = e, this.subTrees = [] } addTriangle(e) { return this.bounds || (this.bounds = new THREE.Box3), this.bounds.min.x = Math.min(this.bounds.min.x, e.a.x, e.b.x, e.c.x), this.bounds.min.y = Math.min(this.bounds.min.y, e.a.y, e.b.y, e.c.y), this.bounds.min.z = Math.min(this.bounds.min.z, e.a.z, e.b.z, e.c.z), this.bounds.max.x = Math.max(this.bounds.max.x, e.a.x, e.b.x, e.c.x), this.bounds.max.y = Math.max(this.bounds.max.y, e.a.y, e.b.y, e.c.y), this.bounds.max.z = Math.max(this.bounds.max.z, e.a.z, e.b.z, e.c.z), this.triangles.push(e), this } calcBox() { return this.box = this.bounds.clone(), this.box.min.x -= .01, this.box.min.y -= .01, this.box.min.z -= .01, this } split(t) { if (this.box) { const a = []; var i, r = l.copy(this.box.max).sub(this.box.min).multiplyScalar(.5); for (let i = 0; i < 2; i++)for (let t = 0; t < 2; t++)for (let e = 0; e < 2; e++) { const o = new THREE.Box3, s = d.set(i, t, e); o.min.copy(this.box.min).add(s.multiply(r)), o.max.copy(o.min).add(r), a.push(new c(o)) } for (; i = this.triangles.pop();)for (let e = 0; e < a.length; e++)a[e].box.intersectsTriangle(i) && a[e].triangles.push(i); for (let e = 0; e < a.length; e++) { var n = a[e].triangles.length; 8 < n && t < 16 && a[e].split(t + 1), 0 !== n && this.subTrees.push(a[e]) } return this } } build() { return this.calcBox(), this.split(0), this } getRayTriangles(t, i) { for (let e = 0; e < this.subTrees.length; e++) { const r = this.subTrees[e]; if (t.intersectsBox(r.box)) if (0 < r.triangles.length) for (let e = 0; e < r.triangles.length; e++)-1 === i.indexOf(r.triangles[e]) && i.push(r.triangles[e]); else r.getRayTriangles(t, i) } return i } triangleCapsuleIntersect(t, e) { e.getPlane(p); var i = p.distanceToPoint(t.start) - t.radius, r = p.distanceToPoint(t.end) - t.radius; if (0 < i && 0 < r || i < -t.radius && r < -t.radius) return !1; var n = Math.abs(i / (Math.abs(i) + Math.abs(r))); const a = d.copy(t.start).lerp(t.end, n); if (e.containsPoint(a)) return { normal: p.normal.clone(), point: a.clone(), depth: Math.abs(Math.min(i, r)) }; var o = t.radius * t.radius, s = f.set(t.start, t.end), l = [[e.a, e.b], [e.b, e.c], [e.c, e.a]]; for (let e = 0; e < l.length; e++) { var c = m.set(l[e][0], l[e][1]); const [h, u] = t.lineLineMinimumPoints(s, c); if (h.distanceToSquared(u) < o) return { normal: h.clone().sub(u).normalize(), point: u.clone(), depth: t.radius - h.distanceTo(u) } } return !1 } triangleSphereIntersect(t, e) { if (e.getPlane(p), !t.intersectsPlane(p)) return !1; var i = Math.abs(p.distanceToSphere(t)), r = t.radius * t.radius - i * i; const n = p.projectPoint(t.center, d); if (e.containsPoint(t.center)) return { normal: p.normal.clone(), point: n.clone(), depth: Math.abs(p.distanceToSphere(t)) }; var a = [[e.a, e.b], [e.b, e.c], [e.c, e.a]]; for (let e = 0; e < a.length; e++) { f.set(a[e][0], a[e][1]), f.closestPointToPoint(n, !0, l); var o = l.distanceToSquared(t.center); if (o < r) return { normal: t.center.clone().sub(l).normalize(), point: l.clone(), depth: t.radius - Math.sqrt(o) } } return !1 } getSphereTriangles(t, i) { for (let e = 0; e < this.subTrees.length; e++) { const r = this.subTrees[e]; if (t.intersectsBox(r.box)) if (0 < r.triangles.length) for (let e = 0; e < r.triangles.length; e++)-1 === i.indexOf(r.triangles[e]) && i.push(r.triangles[e]); else r.getSphereTriangles(t, i) } } getCapsuleTriangles(t, i) { for (let e = 0; e < this.subTrees.length; e++) { const r = this.subTrees[e]; if (t.intersectsBox(r.box)) if (0 < r.triangles.length) for (let e = 0; e < r.triangles.length; e++)-1 === i.indexOf(r.triangles[e]) && i.push(r.triangles[e]); else r.getCapsuleTriangles(t, i) } } sphereIntersect(e) { a.copy(e); var t = []; let i, r = !1; this.getSphereTriangles(e, t); for (let e = 0; e < t.length; e++)(i = this.triangleSphereIntersect(a, t[e])) && (r = !0, a.center.add(i.normal.multiplyScalar(i.depth))); if (r) { const n = a.center.clone().sub(e.center); return e = n.length(), { normal: n.normalize(), depth: e } } return !1 } capsuleIntersect(e) { o.copy(e); var t = []; let i, r = !1; this.getCapsuleTriangles(o, t); for (let e = 0; e < t.length; e++)(i = this.triangleCapsuleIntersect(o, t[e])) && (r = !0, o.translate(i.normal.multiplyScalar(i.depth))); if (r) { const n = o.getCenter(new THREE.Vector3).sub(e.getCenter(d)); return e = n.length(), { normal: n.normalize(), depth: e } } return !1 } rayIntersect(n) { if (0 !== n.direction.length()) { var a, o = []; let t, i, r = 1e100; this.getRayTriangles(n, o); for (let e = 0; e < o.length; e++) { const s = n.intersectTriangle(o[e].a, o[e].b, o[e].c, !0, d); s && (a = s.sub(n.origin).length(), r > a && (i = s.clone().add(n.origin), r = a, t = o[e])) } return r < 1e100 && { distance: r, triangle: t, position: i } } } fromGraphNode(e) { return e.updateWorldMatrix(!0, !0), e.traverse(i => { if (!0 === i.isMesh) { let e, t = !1; var r = (e = null !== i.geometry.index ? (t = !0, i.geometry.toNonIndexed()) : i.geometry).getAttribute("position"); for (let e = 0; e < r.count; e += 3) { const n = (new THREE.Vector3).fromBufferAttribute(r, e), a = (new THREE.Vector3).fromBufferAttribute(r, e + 1), o = (new THREE.Vector3).fromBufferAttribute(r, e + 2); n.applyMatrix4(i.matrixWorld), a.applyMatrix4(i.matrixWorld), o.applyMatrix4(i.matrixWorld), this.addTriangle(new THREE.Triangle(n, a, o)) } t && e.dispose() } }), this.build(), this } } }(), THREE.SimplexNoise = class { constructor(t = Math) { this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]], this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]], this.p = []; for (let e = 0; e < 256; e++)this.p[e] = Math.floor(256 * t.random()); this.perm = []; for (let e = 0; e < 512; e++)this.perm[e] = this.p[255 & e]; this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]] } dot(e, t, i) { return e[0] * t + e[1] * i } dot3(e, t, i, r) { return e[0] * t + e[1] * i + e[2] * r } dot4(e, t, i, r, n) { return e[0] * t + e[1] * i + e[2] * r + e[3] * n } noise(e, t) { var i = (e + t) * (.5 * (Math.sqrt(3) - 1)), r = Math.floor(e + i); let n, a; a = (t -= (i = Math.floor(t + i)) - (o = (r + i) * (c = (3 - Math.sqrt(3)) / 6))) < (e -= r - o) ? (n = 1, 0) : (n = 0, 1); var o = e - n + c, s = t - a + c, l = e - 1 + 2 * c, c = t - 1 + 2 * c, i = 255 & i, h = this.perm[(r &= 255) + this.perm[i]] % 12, u = this.perm[r + n + this.perm[i + a]] % 12, r = this.perm[1 + r + this.perm[1 + i]] % 12, i = (e = (i = .5 - e * e - t * t) < 0 ? 0 : (i *= i) * i * this.dot(this.grad3[h], e, t), .5 - o * o - s * s), h = .5 - l * l - c * c; return 70 * (e + (i < 0 ? 0 : (i *= i) * i * this.dot(this.grad3[u], o, s)) + (h < 0 ? 0 : (h *= h) * h * this.dot(this.grad3[r], l, c))) } noise3d(e, t, i) { var r = (e + t + i) * (1 / 3), n = Math.floor(e + r), a = Math.floor(t + r), i = i - ((r = Math.floor(i + r)) - (d = (n + a + r) * (1 / 6))); let o, s, l, c, h, u; u = (t -= a - d) <= (e -= n - d) ? i <= t ? (o = 1, s = 0, l = 0, c = 1, h = 1, 0) : (h = (c = (l = i <= e ? (o = 1, s = 0) : (o = 0, s = 0, 1), 1), 0), 1) : t < i ? (o = 0, s = 0, l = 1, c = 0, h = 1) : e < i ? (o = 0, s = 1, l = 0, c = 0, h = 1) : (o = 0, s = 1, l = 0, c = 1, h = 1, 0); var d = e - o + 1 / 6, p = t - s + 1 / 6, f = i - l + 1 / 6, m = e - c + 1 / 6 * 2, v = t - h + 1 / 6 * 2, g = i - u + 1 / 6 * 2, x = e - 1 + .5, y = t - 1 + .5, _ = i - 1 + .5, a = 255 & a, b = this.perm[(n &= 255) + this.perm[a + this.perm[r &= 255]]] % 12, w = this.perm[n + o + this.perm[a + s + this.perm[r + l]]] % 12, E = this.perm[n + c + this.perm[a + h + this.perm[r + u]]] % 12, n = this.perm[1 + n + this.perm[1 + a + this.perm[1 + r]]] % 12, r = (e = (a = .6 - e * e - t * t - i * i) < 0 ? 0 : (a *= a) * a * this.dot3(this.grad3[b], e, t, i), .6 - d * d - p * p - f * f), a = .6 - m * m - v * v - g * g, b = .6 - x * x - y * y - _ * _; return 32 * (e + (r < 0 ? 0 : (r *= r) * r * this.dot3(this.grad3[w], d, p, f)) + (a < 0 ? 0 : (a *= a) * a * this.dot3(this.grad3[E], m, v, g)) + (b < 0 ? 0 : (b *= b) * b * this.dot3(this.grad3[n], x, y, _))) } noise4d(e, t, i, r) { var n = this.grad4, a = this.simplex, o = this.perm, s = (Math.sqrt(5) - 1) / 4, l = (5 - Math.sqrt(5)) / 20, s = (e + t + i + r) * s, c = Math.floor(e + s), h = Math.floor(t + s), u = Math.floor(i + s), d = 3 <= a[b = ((t -= h - (b = (c + h + u + (s = Math.floor(r + s))) * l)) < (e -= c - b) ? 32 : 0) + ((i -= u - b) < e ? 16 : 0) + (i < t ? 8 : 0) + ((r -= s - b) < e ? 4 : 0) + (r < t ? 2 : 0) + (r < i ? 1 : 0)][0] ? 1 : 0, p = 3 <= a[b][1] ? 1 : 0, f = 3 <= a[b][2] ? 1 : 0, m = 3 <= a[b][3] ? 1 : 0, v = 2 <= a[b][0] ? 1 : 0, g = 2 <= a[b][1] ? 1 : 0, x = 2 <= a[b][2] ? 1 : 0, y = 2 <= a[b][3] ? 1 : 0, _ = 1 <= a[b][0] ? 1 : 0, H = 1 <= a[b][1] ? 1 : 0, B = 1 <= a[b][2] ? 1 : 0, a = 1 <= a[b][3] ? 1 : 0, b = e - d + l, w = t - p + l, E = i - f + l, T = r - m + l, S = e - v + 2 * l, M = t - g + 2 * l, A = i - x + 2 * l, R = r - y + 2 * l, L = e - _ + 3 * l, P = t - H + 3 * l, C = i - B + 3 * l, F = r - a + 3 * l, D = e - 1 + 4 * l, I = t - 1 + 4 * l, N = i - 1 + 4 * l, U = o[(c &= 255) + o[(h &= 255) + o[(u &= 255) + o[s &= 255]]]] % 32, d = o[c + d + o[h + p + o[u + f + o[s + m]]]] % 32, p = o[c + v + o[h + g + o[u + x + o[s + y]]]] % 32, f = o[c + _ + o[h + H + o[u + B + o[s + a]]]] % 32, m = o[1 + c + o[1 + h + o[1 + u + o[1 + s]]]] % 32, g = .6 - b * b - w * w - E * E - T * T, x = .6 - S * S - M * M - A * A - R * R, y = .6 - L * L - P * P - C * C - F * F, _ = .6 - D * D - I * I - N * N - (l = r - 1 + 4 * l) * l; return 27 * (((v = .6 - e * e - t * t - i * i - r * r) < 0 ? 0 : (v *= v) * v * this.dot4(n[U], e, t, i, r)) + (g < 0 ? 0 : (g *= g) * g * this.dot4(n[d], b, w, E, T)) + (x < 0 ? 0 : (x *= x) * x * this.dot4(n[p], S, M, A, R)) + (y < 0 ? 0 : (y *= y) * y * this.dot4(n[f], L, P, C, F)) + (_ < 0 ? 0 : (_ *= _) * _ * this.dot4(n[m], D, I, N, l))) } }, function () { const t = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), i = new THREE.BufferGeometry; i.setAttribute("position", new THREE.Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), i.setAttribute("uv", new THREE.Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2)), THREE.EffectComposer = class { constructor(e, t) { var i, r; this.renderer = e, void 0 === t ? (i = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }, r = e.getSize(new THREE.Vector2), this._pixelRatio = e.getPixelRatio(), this._width = r.width, this._height = r.height, (t = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, i)).texture.name = "EffectComposer.rt1") : (this._pixelRatio = 1, this._width = t.width, this._height = t.height), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === THREE.CopyShader && console.error("THREE.EffectComposer relies on THREE.CopyShader"), void 0 === THREE.ShaderPass && console.error("THREE.EffectComposer relies on THREE.ShaderPass"), this.copyPass = new THREE.ShaderPass(THREE.CopyShader), this.clock = new THREE.Clock } swapBuffers() { var e = this.readBuffer; this.readBuffer = this.writeBuffer, this.writeBuffer = e } addPass(e) { this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } insertPass(e, t) { this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio) } removePass(e) { -1 !== (e = this.passes.indexOf(e)) && this.passes.splice(e, 1) } isLastEnabledPass(t) { for (let e = t + 1; e < this.passes.length; e++)if (this.passes[e].enabled) return !1; return !0 } render(i) { void 0 === i && (i = this.clock.getDelta()); var e = this.renderer.getRenderTarget(); let r = !1; for (let e = 0, t = this.passes.length; e < t; e++) { const a = this.passes[e]; if (!1 !== a.enabled) { if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(e), a.render(this.renderer, this.writeBuffer, this.readBuffer, i, r), a.needsSwap) { if (r) { var n = this.renderer.getContext(); const o = this.renderer.state.buffers.stencil; o.setFunc(n.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, i), o.setFunc(n.EQUAL, 1, 4294967295) } this.swapBuffers() } void 0 !== THREE.MaskPass && (a instanceof THREE.MaskPass ? r = !0 : a instanceof THREE.ClearMaskPass && (r = !1)) } } this.renderer.setRenderTarget(e) } reset(e) { var t; void 0 === e && (t = this.renderer.getSize(new THREE.Vector2), this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)), this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2 } setSize(e, t) { this._width = e, this._height = t; var i = this._width * this._pixelRatio, r = this._height * this._pixelRatio; this.renderTarget1.setSize(i, r), this.renderTarget2.setSize(i, r); for (let e = 0; e < this.passes.length; e++)this.passes[e].setSize(i, r) } setPixelRatio(e) { this._pixelRatio = e, this.setSize(this._width, this._height) } }, THREE.FullScreenQuad = class { constructor(e) { this._mesh = new THREE.Mesh(i, e) } dispose() { this._mesh.geometry.dispose() } render(e) { e.render(this._mesh, t) } get material() { return this._mesh.material } set material(e) { this._mesh.material = e } }, THREE.Pass = class { constructor() { this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1 } setSize() { } render() { console.error("THREE.Pass: .render() must be implemented in derived pass.") } } }(), function () {
	const t = {
		defines: { USE_3DTEXTURE: 1 }, uniforms: { lut3d: { value: null }, lut: { value: null }, lutSize: { value: 0 }, tDiffuse: { value: null }, intensity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `

		uniform float lutSize;
		#if USE_3DTEXTURE
		precision highp sampler3D;
		uniform sampler3D lut3d;
		#else
		uniform sampler2D lut;

		vec3 lutLookup( sampler2D tex, float size, vec3 rgb ) {

			float sliceHeight = 1.0 / size;
			float yPixelHeight = 1.0 / ( size * size );

			// Get the slices on either side of the sample
			float slice = rgb.b * size;
			float interp = fract( slice );
			float slice0 = slice - interp;
			float centeredInterp = interp - 0.5;

			float slice1 = slice0 + sign( centeredInterp );

			// Pull y sample in by half a pixel in each direction to avoid color
			// bleeding from adjacent slices.
			float greenOffset = clamp( rgb.g * sliceHeight, yPixelHeight * 0.5, sliceHeight - yPixelHeight * 0.5 );

			vec2 uv0 = vec2(
				rgb.r,
				slice0 * sliceHeight + greenOffset
			);
			vec2 uv1 = vec2(
				rgb.r,
				slice1 * sliceHeight + greenOffset
			);

			vec3 sample0 = texture2D( tex, uv0 ).rgb;
			vec3 sample1 = texture2D( tex, uv1 ).rgb;

			return mix( sample0, sample1, abs( centeredInterp ) );

		}
		#endif

		varying vec2 vUv;
		uniform float intensity;
		uniform sampler2D tDiffuse;
		void main() {

			vec4 val = texture2D( tDiffuse, vUv );
			vec4 lutVal;

			// pull the sample in by half a pixel so the sample begins
			// at the center of the edge pixels.
			float pixelWidth = 1.0 / lutSize;
			float halfPixelWidth = 0.5 / lutSize;
			vec3 uvw = vec3( halfPixelWidth ) + val.rgb * ( 1.0 - pixelWidth );

			#if USE_3DTEXTURE

			lutVal = vec4( texture( lut3d, uvw ).rgb, val.a );

			#else

			lutVal = vec4( lutLookup( lut, lutSize, uvw ), val.a );

			#endif

			gl_FragColor = vec4( mix( val, lutVal, intensity ) );

		}

	`}; class e extends THREE.Pass { constructor(e, t) { super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof THREE.ShaderMaterial ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = THREE.UniformsUtils.clone(e.uniforms), this.material = new THREE.ShaderMaterial({ defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new THREE.FullScreenQuad(this.material) } render(e, t, i) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (i.texture.encoding = e.outputEncoding, e.setRenderTarget(null)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)), this.fsQuad.render(e) } } THREE.LUTPass = class extends e { set lut(e) { const t = this.material; var i; e !== this.lut && (t.uniforms.lut3d.value = null, t.uniforms.lut.value = null, e && ((i = e.isDataTexture3D ? 1 : 0) !== t.defines.USE_3DTEXTURE && (t.defines.USE_3DTEXTURE = i, t.needsUpdate = !0), t.uniforms.lutSize.value = e.image.width, e.isDataTexture3D ? t.uniforms.lut3d.value = e : t.uniforms.lut.value = e)) } get lut() { return this.material.uniforms.lut.value || this.material.uniforms.lut3d.value } set intensity(e) { this.material.uniforms.intensity.value = e } get intensity() { return this.material.uniforms.intensity.value } constructor(e = {}) { super(t), this.lut = e.lut || null, this.intensity = "intensity" in e ? e.intensity : 1 } }
}(), function () {
	class s extends THREE.Pass {
		constructor(e, t, i, r) { var n, a; super(), this.renderScene = t, this.renderCamera = i, this.selectedObjects = void 0 !== r ? r : [], this.visibleEdgeColor = new THREE.Color(1, 1, 1), this.hiddenEdgeColor = new THREE.Color(.1, .04, .02), this.edgeGlow = 0, this.usePatternTexture = !1, this.edgeThickness = 1, this.edgeStrength = 3, this.downSampleRatio = 2, this.pulsePeriod = 0, this._visibilityCache = new Map, this.resolution = void 0 !== e ? new THREE.Vector2(e.x, e.y) : new THREE.Vector2(256, 256), t = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }, i = Math.round(this.resolution.x / this.downSampleRatio), r = Math.round(this.resolution.y / this.downSampleRatio), this.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 16777215 }), this.maskBufferMaterial.side = THREE.DoubleSide, this.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, t), this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask", this.renderTargetMaskBuffer.texture.generateMipmaps = !1, this.depthMaterial = new THREE.MeshDepthMaterial, this.depthMaterial.side = THREE.DoubleSide, this.depthMaterial.depthPacking = THREE.RGBADepthPacking, this.depthMaterial.blending = THREE.NoBlending, this.prepareMaskMaterial = this.getPrepareMaskMaterial(), this.prepareMaskMaterial.side = THREE.DoubleSide, this.prepareMaskMaterial.fragmentShader = (n = this.prepareMaskMaterial.fragmentShader, a = this.renderCamera.isPerspectiveCamera ? "perspective" : "orthographic", n.replace(/DEPTH_TO_VIEW_Z/g, a + "DepthToViewZ")), this.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, t), this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth", this.renderTargetDepthBuffer.texture.generateMipmaps = !1, this.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(i, r, t), this.renderTargetMaskDownSampleBuffer.texture.name = "OutlinePass.depthDownSample", this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1, this.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(i, r, t), this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1", this.renderTargetBlurBuffer1.texture.generateMipmaps = !1, this.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(i / 2), Math.round(r / 2), t), this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2", this.renderTargetBlurBuffer2.texture.generateMipmaps = !1, this.edgeDetectionMaterial = this.getEdgeDetectionMaterial(), this.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(i, r, t), this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1", this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1, this.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(i / 2), Math.round(r / 2), t), this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2", this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1, this.separableBlurMaterial1 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial1.uniforms.texSize.value.set(i, r), this.separableBlurMaterial1.uniforms.kernelRadius.value = 1, this.separableBlurMaterial2 = this.getSeperableBlurMaterial(4), this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(i / 2), Math.round(r / 2)), this.separableBlurMaterial2.uniforms.kernelRadius.value = 4, this.overlayMaterial = this.getOverlayMaterial(), void 0 === THREE.CopyShader && console.error("THREE.OutlinePass relies on CopyShader"), e = THREE.CopyShader, this.copyUniforms = THREE.UniformsUtils.clone(e.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new THREE.ShaderMaterial({ uniforms: this.copyUniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, blending: THREE.NoBlending, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new THREE.Color, this.oldClearAlpha = 1, this.fsQuad = new THREE.FullScreenQuad(null), this.tempPulseColor1 = new THREE.Color, this.tempPulseColor2 = new THREE.Color, this.textureMatrix = new THREE.Matrix4 } dispose() { this.renderTargetMaskBuffer.dispose(), this.renderTargetDepthBuffer.dispose(), this.renderTargetMaskDownSampleBuffer.dispose(), this.renderTargetBlurBuffer1.dispose(), this.renderTargetBlurBuffer2.dispose(), this.renderTargetEdgeBuffer1.dispose(), this.renderTargetEdgeBuffer2.dispose() } setSize(e, t) { this.renderTargetMaskBuffer.setSize(e, t), this.renderTargetDepthBuffer.setSize(e, t), e = Math.round(e / this.downSampleRatio), t = Math.round(t / this.downSampleRatio), this.renderTargetMaskDownSampleBuffer.setSize(e, t), this.renderTargetBlurBuffer1.setSize(e, t), this.renderTargetEdgeBuffer1.setSize(e, t), this.separableBlurMaterial1.uniforms.texSize.value.set(e, t), e = Math.round(e / 2), t = Math.round(t / 2), this.renderTargetBlurBuffer2.setSize(e, t), this.renderTargetEdgeBuffer2.setSize(e, t), this.separableBlurMaterial2.uniforms.texSize.value.set(e, t) } changeVisibilityOfSelectedObjects(t) { const i = this._visibilityCache; function r(e) { e.isMesh && (!0 === t ? e.visible = i.get(e) : (i.set(e, e.visible), e.visible = t)) } for (let e = 0; e < this.selectedObjects.length; e++) { const n = this.selectedObjects[e]; n.traverse(r) } } changeVisibilityOfNonSelectedObjects(r) { const n = this._visibilityCache, a = []; function t(e) { e.isMesh && a.push(e) } for (let e = 0; e < this.selectedObjects.length; e++) { const i = this.selectedObjects[e]; i.traverse(t) } this.renderScene.traverse(function (i) { if (i.isMesh || i.isSprite) { let t = !1; for (let e = 0; e < a.length; e++)if (a[e].id === i.id) { t = !0; break } var e; !1 === t && (e = i.visible, !1 !== r && !0 !== n.get(i) || (i.visible = r), n.set(i, e)) } else (i.isPoints || i.isLine) && (!0 === r ? i.visible = n.get(i) : (n.set(i, i.visible), i.visible = r)) }) } updateTextureMatrix() { this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(this.renderCamera.projectionMatrix), this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse) } render(e, t, i, r, n) { var a, o; 0 < this.selectedObjects.length && (e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha(), a = e.autoClear, e.autoClear = !1, n && e.state.buffers.stencil.setTest(!1), e.setClearColor(16777215, 1), this.changeVisibilityOfSelectedObjects(!1), o = this.renderScene.background, this.renderScene.background = null, this.renderScene.overrideMaterial = this.depthMaterial, e.setRenderTarget(this.renderTargetDepthBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.changeVisibilityOfSelectedObjects(!0), this._visibilityCache.clear(), this.updateTextureMatrix(), this.changeVisibilityOfNonSelectedObjects(!1), this.renderScene.overrideMaterial = this.prepareMaskMaterial, this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near, this.renderCamera.far), this.prepareMaskMaterial.uniforms.depthTexture.value = this.renderTargetDepthBuffer.texture, this.prepareMaskMaterial.uniforms.textureMatrix.value = this.textureMatrix, e.setRenderTarget(this.renderTargetMaskBuffer), e.clear(), e.render(this.renderScene, this.renderCamera), this.renderScene.overrideMaterial = null, this.changeVisibilityOfNonSelectedObjects(!0), this._visibilityCache.clear(), this.renderScene.background = o, this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetMaskBuffer.texture, e.setRenderTarget(this.renderTargetMaskDownSampleBuffer), e.clear(), this.fsQuad.render(e), this.tempPulseColor1.copy(this.visibleEdgeColor), this.tempPulseColor2.copy(this.hiddenEdgeColor), 0 < this.pulsePeriod && (o = .625 + .75 * Math.cos(.01 * performance.now() / this.pulsePeriod) / 2, this.tempPulseColor1.multiplyScalar(o), this.tempPulseColor2.multiplyScalar(o)), this.fsQuad.material = this.edgeDetectionMaterial, this.edgeDetectionMaterial.uniforms.maskTexture.value = this.renderTargetMaskDownSampleBuffer.texture, this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height), this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value = this.tempPulseColor1, this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value = this.tempPulseColor2, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial1, this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = s.BlurDirectionX, this.separableBlurMaterial1.uniforms.kernelRadius.value = this.edgeThickness, e.setRenderTarget(this.renderTargetBlurBuffer1), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial1.uniforms.colorTexture.value = this.renderTargetBlurBuffer1.texture, this.separableBlurMaterial1.uniforms.direction.value = s.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer1), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.separableBlurMaterial2, this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetEdgeBuffer1.texture, this.separableBlurMaterial2.uniforms.direction.value = s.BlurDirectionX, e.setRenderTarget(this.renderTargetBlurBuffer2), e.clear(), this.fsQuad.render(e), this.separableBlurMaterial2.uniforms.colorTexture.value = this.renderTargetBlurBuffer2.texture, this.separableBlurMaterial2.uniforms.direction.value = s.BlurDirectionY, e.setRenderTarget(this.renderTargetEdgeBuffer2), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.overlayMaterial, this.overlayMaterial.uniforms.maskTexture.value = this.renderTargetMaskBuffer.texture, this.overlayMaterial.uniforms.edgeTexture1.value = this.renderTargetEdgeBuffer1.texture, this.overlayMaterial.uniforms.edgeTexture2.value = this.renderTargetEdgeBuffer2.texture, this.overlayMaterial.uniforms.patternTexture.value = this.patternTexture, this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength, this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow, this.overlayMaterial.uniforms.usePatternTexture.value = this.usePatternTexture, n && e.state.buffers.stencil.setTest(!0), e.setRenderTarget(i), this.fsQuad.render(e), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = a), this.renderToScreen && (this.fsQuad.material = this.materialCopy, i.texture.encoding = e.outputEncoding, this.copyUniforms.tDiffuse.value = i.texture, e.setRenderTarget(null), this.fsQuad.render(e)) } getPrepareMaskMaterial() {
			return new THREE.ShaderMaterial({
				uniforms: { depthTexture: { value: null }, cameraNearFar: { value: new THREE.Vector2(.5, .5) }, textureMatrix: { value: null } }, vertexShader: `#include <morphtarget_pars_vertex>
				#include <skinning_pars_vertex>

				varying vec4 projTexCoord;
				varying vec4 vPosition;
				uniform mat4 textureMatrix;

				void main() {

					#include <skinbase_vertex>
					#include <begin_vertex>
					#include <morphtarget_vertex>
					#include <skinning_vertex>
					#include <project_vertex>

					vPosition = mvPosition;
					vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );
					projTexCoord = textureMatrix * worldPosition;

				}`, fragmentShader: `#include <packing>
				varying vec4 vPosition;
				varying vec4 projTexCoord;
				uniform sampler2D depthTexture;
				uniform vec2 cameraNearFar;

				void main() {

					float depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));
					float viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );
					float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;
					gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);

				}`})
		} getEdgeDetectionMaterial() {
			return new THREE.ShaderMaterial({
				uniforms: { maskTexture: { value: null }, texSize: { value: new THREE.Vector2(.5, .5) }, visibleEdgeColor: { value: new THREE.Vector3(1, 1, 1) }, hiddenEdgeColor: { value: new THREE.Vector3(1, 1, 1) } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform vec2 texSize;
				uniform vec3 visibleEdgeColor;
				uniform vec3 hiddenEdgeColor;

				void main() {
					vec2 invSize = 1.0 / texSize;
					vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);
					vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);
					vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);
					vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);
					vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);
					float diff1 = (c1.r - c2.r)*0.5;
					float diff2 = (c3.r - c4.r)*0.5;
					float d = length( vec2(diff1, diff2) );
					float a1 = min(c1.g, c2.g);
					float a2 = min(c3.g, c4.g);
					float visibilityFactor = min(a1, a2);
					vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;
					gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);
				}`})
		} getSeperableBlurMaterial(e) {
			return new THREE.ShaderMaterial({
				defines: { MAX_RADIUS: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new THREE.Vector2(.5, .5) }, direction: { value: new THREE.Vector2(.5, .5) }, kernelRadius: { value: 1 } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;
				uniform float kernelRadius;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}

				void main() {
					vec2 invSize = 1.0 / texSize;
					float weightSum = gaussianPdf(0.0, kernelRadius);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);
					vec2 uvOffset = delta;
					for( int i = 1; i <= MAX_RADIUS; i ++ ) {
						float w = gaussianPdf(uvOffset.x, kernelRadius);
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += ((sample1 + sample2) * w);
						weightSum += (2.0 * w);
						uvOffset += delta;
					}
					gl_FragColor = diffuseSum/weightSum;
				}`})
		} getOverlayMaterial() {
			return new THREE.ShaderMaterial({
				uniforms: { maskTexture: { value: null }, edgeTexture1: { value: null }, edgeTexture2: { value: null }, patternTexture: { value: null }, edgeStrength: { value: 1 }, edgeGlow: { value: 1 }, usePatternTexture: { value: 0 } }, vertexShader: `varying vec2 vUv;

				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;

				uniform sampler2D maskTexture;
				uniform sampler2D edgeTexture1;
				uniform sampler2D edgeTexture2;
				uniform sampler2D patternTexture;
				uniform float edgeStrength;
				uniform float edgeGlow;
				uniform bool usePatternTexture;

				void main() {
					vec4 edgeValue1 = texture2D(edgeTexture1, vUv);
					vec4 edgeValue2 = texture2D(edgeTexture2, vUv);
					vec4 maskColor = texture2D(maskTexture, vUv);
					vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);
					float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;
					vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;
					vec4 finalColor = edgeStrength * maskColor.r * edgeValue;
					if(usePatternTexture)
						finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);
					gl_FragColor = finalColor;
				}`, blending: THREE.AdditiveBlending, depthTest: !1, depthWrite: !1, transparent: !0
			})
		}
	} s.BlurDirectionX = new THREE.Vector2(1, 0), s.BlurDirectionY = new THREE.Vector2(0, 1), THREE.OutlinePass = s
}(), function () { const t = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), i = new THREE.BufferGeometry; i.setAttribute("position", new THREE.Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), i.setAttribute("uv", new THREE.Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2)), THREE.Pass = class { constructor() { this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1 } setSize() { } render() { console.error("THREE.Pass: .render() must be implemented in derived pass.") } }, THREE.FullScreenQuad = class { constructor(e) { this._mesh = new THREE.Mesh(i, e) } dispose() { this._mesh.geometry.dispose() } render(e) { e.render(this._mesh, t) } get material() { return this._mesh.material } set material(e) { this._mesh.material = e } } }(), function () { class e extends THREE.Pass { constructor(e, t, i, r, n) { super(), this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = r, this.clearAlpha = void 0 !== n ? n : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new THREE.Color } render(e, t, i) { var r = e.autoClear; e.autoClear = !1; let n, a; void 0 !== this.overrideMaterial && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (e.getClearColor(this._oldClearColor), n = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor && e.setClearColor(this._oldClearColor, n), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = a), e.autoClear = r } } THREE.RenderPass = e }(), function () { class e extends THREE.Pass { constructor(e, t) { super(), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof THREE.ShaderMaterial ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = THREE.UniformsUtils.clone(e.uniforms), this.material = new THREE.ShaderMaterial({ defines: Object.assign({}, e.defines), uniforms: this.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader })), this.fsQuad = new THREE.FullScreenQuad(this.material) } render(e, t, i) { this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (i.texture.encoding = e.outputEncoding, e.setRenderTarget(null)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)), this.fsQuad.render(e) } } THREE.ShaderPass = e }(), function () {
	class s extends THREE.Pass {
		constructor(e, t, i, r) { super(), this.strength = void 0 !== t ? t : 1, this.radius = i, this.threshold = r, this.resolution = void 0 !== e ? new THREE.Vector2(e.x, e.y) : new THREE.Vector2(256, 256), this.clearColor = new THREE.Color(0, 0, 0); var n = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }; this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5; let a = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2); this.renderTargetBright = new THREE.WebGLRenderTarget(a, o, n), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1; for (let e = 0; e < this.nMips; e++) { const l = new THREE.WebGLRenderTarget(a, o, n), c = (l.texture.name = "UnrealBloomPass.h" + e, l.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(l), new THREE.WebGLRenderTarget(a, o, n)); c.texture.name = "UnrealBloomPass.v" + e, c.texture.generateMipmaps = !1, this.renderTargetsVertical.push(c), a = Math.round(a / 2), o = Math.round(o / 2) } void 0 === THREE.LuminosityHighPassShader && console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader"); var i = THREE.LuminosityHighPassShader, s = (this.highPassUniforms = THREE.UniformsUtils.clone(i.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = .01, this.materialHighPassFilter = new THREE.ShaderMaterial({ uniforms: this.highPassUniforms, vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, defines: {} }), this.separableBlurMaterials = [], [3, 5, 7, 9, 11]); a = Math.round(this.resolution.x / 2), o = Math.round(this.resolution.y / 2); for (let e = 0; e < this.nMips; e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(s[e])), this.separableBlurMaterials[e].uniforms.texSize.value = new THREE.Vector2(a, o), a = Math.round(a / 2), o = Math.round(o / 2); this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = .1, this.compositeMaterial.needsUpdate = !0, this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2], this.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, void 0 === THREE.CopyShader && console.error("THREE.UnrealBloomPass relies on THREE.CopyShader"), e = THREE.CopyShader, this.copyUniforms = THREE.UniformsUtils.clone(e.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new THREE.ShaderMaterial({ uniforms: this.copyUniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, blending: THREE.AdditiveBlending, depthTest: !1, depthWrite: !1, transparent: !0 }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new THREE.Color, this.oldClearAlpha = 1, this.basic = new THREE.MeshBasicMaterial, this.fsQuad = new THREE.FullScreenQuad(null) } dispose() { for (let e = 0; e < this.renderTargetsHorizontal.length; e++)this.renderTargetsHorizontal[e].dispose(); for (let e = 0; e < this.renderTargetsVertical.length; e++)this.renderTargetsVertical[e].dispose(); this.renderTargetBright.dispose() } setSize(e, t) { let i = Math.round(e / 2), r = Math.round(t / 2); this.renderTargetBright.setSize(i, r); for (let e = 0; e < this.nMips; e++)this.renderTargetsHorizontal[e].setSize(i, r), this.renderTargetsVertical[e].setSize(i, r), this.separableBlurMaterials[e].uniforms.texSize.value = new THREE.Vector2(i, r), i = Math.round(i / 2), r = Math.round(r / 2) } render(t, e, i, r, n) { t.getClearColor(this._oldClearColor), this.oldClearAlpha = t.getClearAlpha(); var a = t.autoClear; t.autoClear = !1, t.setClearColor(this.clearColor, 0), n && t.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = i.texture, t.setRenderTarget(null), t.clear(), this.fsQuad.render(t)), this.highPassUniforms.tDiffuse.value = i.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, t.setRenderTarget(this.renderTargetBright), t.clear(), this.fsQuad.render(t); let o = this.renderTargetBright; for (let e = 0; e < this.nMips; e++)this.fsQuad.material = this.separableBlurMaterials[e], this.separableBlurMaterials[e].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[e].uniforms.direction.value = s.BlurDirectionX, t.setRenderTarget(this.renderTargetsHorizontal[e]), t.clear(), this.fsQuad.render(t), this.separableBlurMaterials[e].uniforms.colorTexture.value = this.renderTargetsHorizontal[e].texture, this.separableBlurMaterials[e].uniforms.direction.value = s.BlurDirectionY, t.setRenderTarget(this.renderTargetsVertical[e]), t.clear(), this.fsQuad.render(t), o = this.renderTargetsVertical[e]; this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, t.setRenderTarget(this.renderTargetsHorizontal[0]), t.clear(), this.fsQuad.render(t), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, n && t.state.buffers.stencil.setTest(!0), this.renderToScreen ? t.setRenderTarget(null) : t.setRenderTarget(i), this.fsQuad.render(t), t.setClearColor(this._oldClearColor, this.oldClearAlpha), t.autoClear = a } getSeperableBlurMaterial(e) {
			return new THREE.ShaderMaterial({
				defines: { KERNEL_RADIUS: e, SIGMA: e }, uniforms: { colorTexture: { value: null }, texSize: { value: new THREE.Vector2(.5, .5) }, direction: { value: new THREE.Vector2(.5, .5) } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`})
		} getCompositeMaterial(e) {
			return new THREE.ShaderMaterial({
				defines: { NUM_MIPS: e }, uniforms: { blurTexture1: { value: null }, blurTexture2: { value: null }, blurTexture3: { value: null }, blurTexture4: { value: null }, blurTexture5: { value: null }, dirtTexture: { value: null }, bloomStrength: { value: 1 }, bloomFactors: { value: null }, bloomTintColors: { value: null }, bloomRadius: { value: 0 } }, vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`, fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`})
		}
	} s.BlurDirectionX = new THREE.Vector2(1, 0), s.BlurDirectionY = new THREE.Vector2(0, 1), THREE.UnrealBloomPass = s
}(), THREE.ACESFilmicToneMappingShader = {
	uniforms: { tDiffuse: { value: null }, exposure: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#define saturate(a) clamp( a, 0.0, 1.0 )

		uniform sampler2D tDiffuse;

		uniform float exposure;

		varying vec2 vUv;

		vec3 RRTAndODTFit( vec3 v ) {

			vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
			vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
			return a / b;

		}

		vec3 ACESFilmicToneMapping( vec3 color ) {

		// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
			const mat3 ACESInputMat = mat3(
				vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
				vec3( 0.35458, 0.90834, 0.13383 ),
				vec3( 0.04823, 0.01566, 0.83777 )
			);

		// ODT_SAT => XYZ => D60_2_D65 => sRGB
			const mat3 ACESOutputMat = mat3(
				vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
				vec3( -0.53108,  1.10813, -0.07276 ),
				vec3( -0.07367, -0.00605,  1.07602 )
			);

			color = ACESInputMat * color;

		// Apply RRT and ODT
			color = RRTAndODTFit( color );

			color = ACESOutputMat * color;

		// Clamp to [0, 1]
			return saturate( color );

		}

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			tex.rgb *= exposure / 0.6; // pre-exposed, outside of the tone mapping function

			gl_FragColor = vec4( ACESFilmicToneMapping( tex.rgb ), tex.a );

		}`}, THREE.AfterimageShader = {
		uniforms: { damp: { value: .96 }, tOld: { value: null }, tNew: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float damp;

		uniform sampler2D tOld;
		uniform sampler2D tNew;

		varying vec2 vUv;

		vec4 when_gt( vec4 x, float y ) {

			return max( sign( x - y ), 0.0 );

		}

		void main() {

			vec4 texelOld = texture2D( tOld, vUv );
			vec4 texelNew = texture2D( tNew, vUv );

			texelOld *= damp * when_gt( texelOld, 0.1 );

			gl_FragColor = max(texelNew, texelOld);

		}`}, THREE.BasicShader = {
		uniforms: {}, vertexShader: `

		void main() {

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		void main() {

			gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );

		}`}, THREE.BleachBypassShader = {
		uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 base = texture2D( tDiffuse, vUv );

			vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );
			float lum = dot( lumCoeff, base.rgb );
			vec3 blend = vec3( lum );

			float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );

			vec3 result1 = 2.0 * base.rgb * blend;
			vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );

			vec3 newColor = mix( result1, result2, L );

			float A2 = opacity * base.a;
			vec3 mixRGB = A2 * newColor.rgb;
			mixRGB += ( ( 1.0 - A2 ) * base.rgb );

			gl_FragColor = vec4( mixRGB, base.a );

		}`}, THREE.BlendShader = {
		uniforms: { tDiffuse1: { value: null }, tDiffuse2: { value: null }, mixRatio: { value: .5 }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;
		uniform float mixRatio;

		uniform sampler2D tDiffuse1;
		uniform sampler2D tDiffuse2;

		varying vec2 vUv;

		void main() {

			vec4 texel1 = texture2D( tDiffuse1, vUv );
			vec4 texel2 = texture2D( tDiffuse2, vUv );
			gl_FragColor = opacity * mix( texel1, texel2, mixRatio );

		}`}, THREE.BokehShader = {
		defines: { DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tColor: { value: null }, tDepth: { value: null }, focus: { value: 1 }, aspect: { value: 1 }, aperture: { value: .025 }, maxblur: { value: .01 }, nearClip: { value: 1 }, farClip: { value: 1e3 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`}, function () {
		var e = {
			uniforms: { textureWidth: { value: 1 }, textureHeight: { value: 1 }, focalDepth: { value: 1 }, focalLength: { value: 24 }, fstop: { value: .9 }, tColor: { value: null }, tDepth: { value: null }, maxblur: { value: 1 }, showFocus: { value: 0 }, manualdof: { value: 0 }, vignetting: { value: 0 }, depthblur: { value: 0 }, threshold: { value: .5 }, gain: { value: 2 }, bias: { value: .5 }, fringe: { value: .7 }, znear: { value: .1 }, zfar: { value: 100 }, noise: { value: 1 }, dithering: { value: 1e-4 }, pentagon: { value: 0 }, shaderFocus: { value: 1 }, focusCoords: { value: new THREE.Vector2 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;
		uniform float textureWidth;
		uniform float textureHeight;

		uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below
		uniform float focalLength; //focal length in mm
		uniform float fstop; //f-stop value
		uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)

		/*
		make sure that these two values are the same for your camera, otherwise distances will be wrong.
		*/

		uniform float znear; // camera clipping start
		uniform float zfar; // camera clipping end

		//------------------------------------------
		//user variables

		const int samples = SAMPLES; //samples on the first ring
		const int rings = RINGS; //ring count

		const int maxringsamples = rings * samples;

		uniform bool manualdof; // manual dof calculation
		float ndofstart = 1.0; // near dof blur start
		float ndofdist = 2.0; // near dof blur falloff distance
		float fdofstart = 1.0; // far dof blur start
		float fdofdist = 3.0; // far dof blur falloff distance

		float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)

		uniform bool vignetting; // use optical lens vignetting

		float vignout = 1.3; // vignetting outer border
		float vignin = 0.0; // vignetting inner border
		float vignfade = 22.0; // f-stops till vignete fades

		uniform bool shaderFocus;
		// disable if you use external focalDepth value

		uniform vec2 focusCoords;
		// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)
		// if center of screen use vec2(0.5, 0.5);

		uniform float maxblur;
		//clamp value of max blur (0.0 = no blur, 1.0 default)

		uniform float threshold; // highlight threshold;
		uniform float gain; // highlight gain;

		uniform float bias; // bokeh edge bias
		uniform float fringe; // bokeh chromatic aberration / fringing

		uniform bool noise; //use noise instead of pattern for sample dithering

		uniform float dithering;

		uniform bool depthblur; // blur the depth buffer
		float dbsize = 1.25; // depth blur size

		/*
		next part is experimental
		not looking good with small sample and ring count
		looks okay starting from samples = 4, rings = 4
		*/

		uniform bool pentagon; //use pentagon as bokeh shape?
		float feather = 0.4; //pentagon shape feather

		//------------------------------------------

		float penta(vec2 coords) {
			//pentagonal shape
			float scale = float(rings) - 1.3;
			vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);
			vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);
			vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);
			vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);
			vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);
			vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);

			vec4  one = vec4( 1.0 );

			vec4 P = vec4((coords),vec2(scale, scale));

			vec4 dist = vec4(0.0);
			float inorout = -4.0;

			dist.x = dot( P, HS0 );
			dist.y = dot( P, HS1 );
			dist.z = dot( P, HS2 );
			dist.w = dot( P, HS3 );

			dist = smoothstep( -feather, feather, dist );

			inorout += dot( dist, one );

			dist.x = dot( P, HS4 );
			dist.y = HS5.w - abs( P.z );

			dist = smoothstep( -feather, feather, dist );
			inorout += dist.x;

			return clamp( inorout, 0.0, 1.0 );
		}

		float bdepth(vec2 coords) {
			// Depth buffer blur
			float d = 0.0;
			float kernel[9];
			vec2 offset[9];

			vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;

			offset[0] = vec2(-wh.x,-wh.y);
			offset[1] = vec2( 0.0, -wh.y);
			offset[2] = vec2( wh.x -wh.y);

			offset[3] = vec2(-wh.x,  0.0);
			offset[4] = vec2( 0.0,   0.0);
			offset[5] = vec2( wh.x,  0.0);

			offset[6] = vec2(-wh.x, wh.y);
			offset[7] = vec2( 0.0,  wh.y);
			offset[8] = vec2( wh.x, wh.y);

			kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;
			kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;
			kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;


			for( int i=0; i<9; i++ ) {
				float tmp = texture2D(tDepth, coords + offset[i]).r;
				d += tmp * kernel[i];
			}

			return d;
		}


		vec3 color(vec2 coords,float blur) {
			//processing the sample

			vec3 col = vec3(0.0);
			vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);

			col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;
			col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;
			col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;

			vec3 lumcoeff = vec3(0.299,0.587,0.114);
			float lum = dot(col.rgb, lumcoeff);
			float thresh = max((lum-threshold)*gain, 0.0);
			return col+mix(vec3(0.0),col,thresh*blur);
		}

		vec3 debugFocus(vec3 col, float blur, float depth) {
			float edge = 0.002*depth; //distance based edge smoothing
			float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);
			float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);

			col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);
			col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);

			return col;
		}

		float linearize(float depth) {
			return -zfar * znear / (depth * (zfar - znear) - zfar);
		}

		float vignette() {
			float dist = distance(vUv.xy, vec2(0.5,0.5));
			dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);
			return clamp(dist,0.0,1.0);
		}

		float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {
			float rings2 = float(rings);
			float step = PI*2.0 / float(ringsamples);
			float pw = cos(j*step)*i;
			float ph = sin(j*step)*i;
			float p = 1.0;
			if (pentagon) {
				p = penta(vec2(pw,ph));
			}
			col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;
			return 1.0 * mix(1.0, i /rings2, bias) * p;
		}

		void main() {
			//scene depth calculation

			float depth = linearize(texture2D(tDepth,vUv.xy).x);

			// Blur depth?
			if ( depthblur ) {
				depth = linearize(bdepth(vUv.xy));
			}

			//focal plane calculation

			float fDepth = focalDepth;

			if (shaderFocus) {

				fDepth = linearize(texture2D(tDepth,focusCoords).x);

			}

			// dof blur factor calculation

			float blur = 0.0;

			if (manualdof) {
				float a = depth-fDepth; // Focal plane
				float b = (a-fdofstart)/fdofdist; // Far DoF
				float c = (-a-ndofstart)/ndofdist; // Near Dof
				blur = (a>0.0) ? b : c;
			} else {
				float f = focalLength; // focal length in mm
				float d = fDepth*1000.0; // focal plane in mm
				float o = depth*1000.0; // depth in mm

				float a = (o*f)/(o-f);
				float b = (d*f)/(d-f);
				float c = (d-f)/(d*fstop*CoC);

				blur = abs(a-b)*c;
			}

			blur = clamp(blur,0.0,1.0);

			// calculation of pattern for dithering

			vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;

			// getting blur x and y step factor

			float w = (1.0/textureWidth)*blur*maxblur+noise.x;
			float h = (1.0/textureHeight)*blur*maxblur+noise.y;

			// calculation of final color

			vec3 col = vec3(0.0);

			if(blur < 0.05) {
				//some optimization thingy
				col = texture2D(tColor, vUv.xy).rgb;
			} else {
				col = texture2D(tColor, vUv.xy).rgb;
				float s = 1.0;
				int ringsamples;

				for (int i = 1; i <= rings; i++) {
					/*unboxstart*/
					ringsamples = i * samples;

					for (int j = 0 ; j < maxringsamples ; j++) {
						if (j >= ringsamples) break;
						s += gather(float(i), float(j), ringsamples, col, w, h, blur);
					}
					/*unboxend*/
				}

				col /= s; //divide by sample count
			}

			if (showFocus) {
				col = debugFocus(col, blur, depth);
			}

			if (vignetting) {
				col *= vignette();
			}

			gl_FragColor.rgb = col;
			gl_FragColor.a = 1.0;
		}`}; THREE.BokehDepthShader = {
			uniforms: { mNear: { value: 1 }, mFar: { value: 1e3 } }, vertexShader: `

		varying float vViewZDepth;

		void main() {

			#include <begin_vertex>
			#include <project_vertex>

			vViewZDepth = - mvPosition.z;

		}`, fragmentShader: `

		uniform float mNear;
		uniform float mFar;

		varying float vViewZDepth;

		void main() {

			float color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );
			gl_FragColor = vec4( vec3( color ), 1.0 );

		}`}, THREE.BokehShader = e
	}(), THREE.BrightnessContrastShader = {
		uniforms: { tDiffuse: { value: null }, brightness: { value: 0 }, contrast: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float brightness;
		uniform float contrast;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			gl_FragColor.rgb += brightness;

			if (contrast > 0.0) {
				gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;
			} else {
				gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;
			}

		}`}, function () {
		var e = {
			uniforms: { tDiffuse: { value: null }, powRGB: { value: new THREE.Vector3(2, 2, 2) }, mulRGB: { value: new THREE.Vector3(1, 1, 1) }, addRGB: { value: new THREE.Vector3(0, 0, 0) } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 powRGB;
		uniform vec3 mulRGB;
		uniform vec3 addRGB;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );

		}`}; THREE.ColorCorrectionShader = e
	}(), function () {
		var e = {
			uniforms: { tDiffuse: { value: null }, color: { value: new THREE.Color(16777215) } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );
			float v = dot( texel.xyz, luma );

			gl_FragColor = vec4( v * color, texel.w );

		}`}; THREE.ColorifyShader = e
	}(), function () {
		var e = {
			defines: { KERNEL_SIZE_FLOAT: "25.0", KERNEL_SIZE_INT: "25" }, uniforms: { tDiffuse: { value: null }, uImageIncrement: { value: new THREE.Vector2(.001953125, 0) }, cKernel: { value: [] } }, vertexShader: `

		uniform vec2 uImageIncrement;

		varying vec2 vUv;

		void main() {

			vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float cKernel[ KERNEL_SIZE_INT ];

		uniform sampler2D tDiffuse;
		uniform vec2 uImageIncrement;

		varying vec2 vUv;

		void main() {

			vec2 imageCoord = vUv;
			vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );

			for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {

				sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];
				imageCoord += uImageIncrement;

			}

			gl_FragColor = sum;

		}`, buildKernel: function (t) { let i = 2 * Math.ceil(3 * t) + 1; var r, n = .5 * ((i = 25 < i ? 25 : i) - 1); const a = new Array(i); let o = 0; for (let e = 0; e < i; ++e)a[e] = (r = e - n, Math.exp(-r * r / (2 * t * t))), o += a[e]; for (let e = 0; e < i; ++e)a[e] /= o; return a }
		}; THREE.ConvolutionShader = e
	}(), THREE.CopyShader = {
		uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`}, function () {
		var e = {
			defines: { KERNEL_RADIUS: 4, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDiffuse: { value: null }, size: { value: new THREE.Vector2(512, 512) }, sampleUvOffsets: { value: [new THREE.Vector2(0, 0)] }, sampleWeights: { value: [1] }, tDepth: { value: null }, cameraNear: { value: 10 }, cameraFar: { value: 1e3 }, depthCutoff: { value: 10 } }, vertexShader: `

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`}; const n = { createSampleWeights: function (t, i) { const r = []; for (let e = 0; e <= t; e++)r.push((n = e, a = i, Math.exp(-n * n / (a * a * 2)) / (Math.sqrt(2 * Math.PI) * a))); var n, a; return r }, createSampleOffsets: function (t, i) { const r = []; for (let e = 0; e <= t; e++)r.push(i.clone().multiplyScalar(e)); return r }, configure: function (e, t, i, r) { e.defines.KERNEL_RADIUS = t, e.uniforms.sampleUvOffsets.value = n.createSampleOffsets(t, r), e.uniforms.sampleWeights.value = n.createSampleWeights(t, i), e.needsUpdate = !0 } }; THREE.BlurShaderUtils = n, THREE.DepthLimitedBlurShader = e
	}(), THREE.DigitalGlitch = {
		uniforms: { tDiffuse: { value: null }, tDisp: { value: null }, byp: { value: 0 }, amount: { value: .08 }, angle: { value: .02 }, seed: { value: .02 }, seed_x: { value: .02 }, seed_y: { value: .02 }, distortion_x: { value: .5 }, distortion_y: { value: .6 }, col_s: { value: .05 } }, vertexShader: `

		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `

		uniform int byp; //should we apply the glitch ?

		uniform sampler2D tDiffuse;
		uniform sampler2D tDisp;

		uniform float amount;
		uniform float angle;
		uniform float seed;
		uniform float seed_x;
		uniform float seed_y;
		uniform float distortion_x;
		uniform float distortion_y;
		uniform float col_s;

		varying vec2 vUv;


		float rand(vec2 co){
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}

		void main() {
			if(byp<1) {
				vec2 p = vUv;
				float xs = floor(gl_FragCoord.x / 0.5);
				float ys = floor(gl_FragCoord.y / 0.5);
				//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
				vec4 normal = texture2D (tDisp, p*seed*seed);
				if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {
					if(seed_x>0.){
						p.y = 1. - (p.y + distortion_y);
					}
					else {
						p.y = distortion_y;
					}
				}
				if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {
					if(seed_y>0.){
						p.x=distortion_x;
					}
					else {
						p.x = 1. - (p.x + distortion_x);
					}
				}
				p.x+=normal.x*seed_x*(seed/5.);
				p.y+=normal.y*seed_y*(seed/5.);
				//base from RGB shift shader
				vec2 offset = amount * vec2( cos(angle), sin(angle));
				vec4 cr = texture2D(tDiffuse, p + offset);
				vec4 cga = texture2D(tDiffuse, p);
				vec4 cb = texture2D(tDiffuse, p - offset);
				gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);
				//add noise
				vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);
				gl_FragColor = gl_FragColor+ snow;
			}
			else {
				gl_FragColor=texture2D (tDiffuse, vUv);
			}
		}`}, THREE.DOFMipMapShader = {
		uniforms: { tColor: { value: null }, tDepth: { value: null }, focus: { value: 1 }, maxblur: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float focus;
		uniform float maxblur;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		varying vec2 vUv;

		void main() {

			vec4 depth = texture2D( tDepth, vUv );

			float factor = depth.x - focus;

			vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );

			gl_FragColor = col;
			gl_FragColor.a = 1.0;

		}`}, function () {
		var e = {
			uniforms: { tDiffuse: { value: null }, tSize: { value: new THREE.Vector2(256, 256) }, center: { value: new THREE.Vector2(.5, .5) }, angle: { value: 1.57 }, scale: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform vec2 center;
		uniform float angle;
		uniform float scale;
		uniform vec2 tSize;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		float pattern() {

			float s = sin( angle ), c = cos( angle );

			vec2 tex = vUv * tSize - center;
			vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;

			return ( sin( point.x ) * sin( point.y ) ) * 4.0;

		}

		void main() {

			vec4 color = texture2D( tDiffuse, vUv );

			float average = ( color.r + color.g + color.b ) / 3.0;

			gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );

		}`}; THREE.DotScreenShader = e
	}(), THREE.FilmShader = {
		uniforms: { tDiffuse: { value: null }, time: { value: 0 }, nIntensity: { value: .5 }, sIntensity: { value: .05 }, sCount: { value: 4096 }, grayscale: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#include <common>

		// control parameter
		uniform float time;

		uniform bool grayscale;

		// noise effect intensity value (0 = no effect, 1 = full effect)
		uniform float nIntensity;

		// scanlines effect intensity value (0 = no effect, 1 = full effect)
		uniform float sIntensity;

		// scanlines effect count value (0 = no effect, 4096 = full effect)
		uniform float sCount;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

		// sample the source
			vec4 cTextureScreen = texture2D( tDiffuse, vUv );

		// make some noise
			float dx = rand( vUv + time );

		// add noise
			vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );

		// get us a sine and cosine
			vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );

		// add scanlines
			cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;

		// interpolate between source and result by intensity
			cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );

		// convert to grayscale if desired
			if( grayscale ) {

				cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );

			}

			gl_FragColor =  vec4( cResult, cTextureScreen.a );

		}`}, THREE.FocusShader = {
		uniforms: { tDiffuse: { value: null }, screenWidth: { value: 1024 }, screenHeight: { value: 1024 }, sampleDistance: { value: .94 }, waveFactor: { value: .00125 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float screenWidth;
		uniform float screenHeight;
		uniform float sampleDistance;
		uniform float waveFactor;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 color, org, tmp, add;
			float sample_dist, f;
			vec2 vin;
			vec2 uv = vUv;

			add = color = org = texture2D( tDiffuse, uv );

			vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );
			sample_dist = dot( vin, vin ) * 2.0;

			f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;

			vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );

			add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );
			if( tmp.b < color.b ) color = tmp;

			add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );
			if( tmp.b < color.b ) color = tmp;

			add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );
			if( tmp.b < color.b ) color = tmp;

			add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );
			if( tmp.b < color.b ) color = tmp;

			add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );
			if( tmp.b < color.b ) color = tmp;

			add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );
			if( tmp.b < color.b ) color = tmp;

			add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );
			if( tmp.b < color.b ) color = tmp;

			color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );
			color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );

			gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );

		}`}, function () {
		var e = {
			uniforms: { tDiffuse: { value: null }, aspect: { value: new THREE.Vector2(512, 512) } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		varying vec2 vUv;

		uniform vec2 aspect;

		vec2 texel = vec2( 1.0 / aspect.x, 1.0 / aspect.y );


		mat3 G[9];

		// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45

		const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );
		const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );
		const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );
		const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );
		const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );
		const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );
		const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );
		const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );
		const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );

		void main(void)
		{

			G[0] = g0,
			G[1] = g1,
			G[2] = g2,
			G[3] = g3,
			G[4] = g4,
			G[5] = g5,
			G[6] = g6,
			G[7] = g7,
			G[8] = g8;

			mat3 I;
			float cnv[9];
			vec3 sample;

		/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
			for (float i=0.0; i<3.0; i++) {
				for (float j=0.0; j<3.0; j++) {
					sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;
					I[int(i)][int(j)] = length(sample);
				}
			}

		/* calculate the convolution values for all the masks */
			for (int i=0; i<9; i++) {
				float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);
				cnv[i] = dp3 * dp3;
			}

			float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);
			float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);

			gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);
		}`}; THREE.FreiChenShader = e
	}(), function () {
		var e = {
			uniforms: { tDiffuse: { value: null }, resolution: { value: new THREE.Vector2(1 / 1024, 1 / 512) } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		precision highp float;

		uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		#define FXAA_PC 1
		#define FXAA_GLSL_100 1
		#define FXAA_QUALITY_PRESET 12

		#define FXAA_GREEN_AS_LUMA 1

		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_PC_CONSOLE
				//
				// The console algorithm for PC is included
				// for developers targeting really low spec machines.
				// Likely better to just run FXAA_PC, and use a really low preset.
				//
				#define FXAA_PC_CONSOLE 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GLSL_120
				#define FXAA_GLSL_120 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GLSL_130
				#define FXAA_GLSL_130 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_3
				#define FXAA_HLSL_3 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_4
				#define FXAA_HLSL_4 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_5
				#define FXAA_HLSL_5 0
		#endif
		/*==========================================================================*/
		#ifndef FXAA_GREEN_AS_LUMA
				//
				// For those using non-linear color,
				// and either not able to get luma in alpha, or not wanting to,
				// this enables FXAA to run using green as a proxy for luma.
				// So with this enabled, no need to pack luma in alpha.
				//
				// This will turn off AA on anything which lacks some amount of green.
				// Pure red and blue or combination of only R and B, will get no AA.
				//
				// Might want to lower the settings for both,
				//		fxaaConsoleEdgeThresholdMin
				//		fxaaQualityEdgeThresholdMin
				// In order to insure AA does not get turned off on colors
				// which contain a minor amount of green.
				//
				// 1 = On.
				// 0 = Off.
				//
				#define FXAA_GREEN_AS_LUMA 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_EARLY_EXIT
				//
				// Controls algorithm's early exit path.
				// On PS3 turning this ON adds 2 cycles to the shader.
				// On 360 turning this OFF adds 10ths of a millisecond to the shader.
				// Turning this off on console will result in a more blurry image.
				// So this defaults to on.
				//
				// 1 = On.
				// 0 = Off.
				//
				#define FXAA_EARLY_EXIT 1
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_DISCARD
				//
				// Only valid for PC OpenGL currently.
				// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
				//
				// 1 = Use discard on pixels which don't need AA.
				//		 For APIs which enable concurrent TEX+ROP from same surface.
				// 0 = Return unchanged color on pixels which don't need AA.
				//
				#define FXAA_DISCARD 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_FAST_PIXEL_OFFSET
				//
				// Used for GLSL 120 only.
				//
				// 1 = GL API supports fast pixel offsets
				// 0 = do not use fast pixel offsets
				//
				#ifdef GL_EXT_gpu_shader4
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifdef GL_NV_gpu_shader5
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifdef GL_ARB_gpu_shader5
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifndef FXAA_FAST_PIXEL_OFFSET
						#define FXAA_FAST_PIXEL_OFFSET 0
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GATHER4_ALPHA
				//
				// 1 = API supports gather4 on alpha channel.
				// 0 = API does not support gather4 on alpha channel.
				//
				#if (FXAA_HLSL_5 == 1)
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifdef GL_ARB_gpu_shader5
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifdef GL_NV_gpu_shader5
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifndef FXAA_GATHER4_ALPHA
						#define FXAA_GATHER4_ALPHA 0
				#endif
		#endif


		/*============================================================================
														FXAA QUALITY - TUNING KNOBS
		------------------------------------------------------------------------------
		NOTE the other tuning knobs are now in the shader function inputs!
		============================================================================*/
		#ifndef FXAA_QUALITY_PRESET
				//
				// Choose the quality preset.
				// This needs to be compiled into the shader as it effects code.
				// Best option to include multiple presets is to
				// in each shader define the preset, then include this file.
				//
				// OPTIONS
				// -----------------------------------------------------------------------
				// 10 to 15 - default medium dither (10=fastest, 15=highest quality)
				// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
				// 39			 - no dither, very expensive
				//
				// NOTES
				// -----------------------------------------------------------------------
				// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
				// 13 = about same speed as FXAA 3.9 and better than 12
				// 23 = closest to FXAA 3.9 visually and performance wise
				//	_ = the lowest digit is directly related to performance
				// _	= the highest digit is directly related to style
				//
				#define FXAA_QUALITY_PRESET 12
		#endif


		/*============================================================================

															 FXAA QUALITY - PRESETS

		============================================================================*/

		/*============================================================================
												 FXAA QUALITY - MEDIUM DITHER PRESETS
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 10)
				#define FXAA_QUALITY_PS 3
				#define FXAA_QUALITY_P0 1.5
				#define FXAA_QUALITY_P1 3.0
				#define FXAA_QUALITY_P2 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 11)
				#define FXAA_QUALITY_PS 4
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 3.0
				#define FXAA_QUALITY_P3 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 12)
				#define FXAA_QUALITY_PS 5
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 4.0
				#define FXAA_QUALITY_P4 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 13)
				#define FXAA_QUALITY_PS 6
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 4.0
				#define FXAA_QUALITY_P5 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 14)
				#define FXAA_QUALITY_PS 7
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 4.0
				#define FXAA_QUALITY_P6 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 15)
				#define FXAA_QUALITY_PS 8
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 4.0
				#define FXAA_QUALITY_P7 12.0
		#endif

		/*============================================================================
												 FXAA QUALITY - LOW DITHER PRESETS
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 20)
				#define FXAA_QUALITY_PS 3
				#define FXAA_QUALITY_P0 1.5
				#define FXAA_QUALITY_P1 2.0
				#define FXAA_QUALITY_P2 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 21)
				#define FXAA_QUALITY_PS 4
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 22)
				#define FXAA_QUALITY_PS 5
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 23)
				#define FXAA_QUALITY_PS 6
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 24)
				#define FXAA_QUALITY_PS 7
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 3.0
				#define FXAA_QUALITY_P6 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 25)
				#define FXAA_QUALITY_PS 8
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 4.0
				#define FXAA_QUALITY_P7 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 26)
				#define FXAA_QUALITY_PS 9
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 4.0
				#define FXAA_QUALITY_P8 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 27)
				#define FXAA_QUALITY_PS 10
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 4.0
				#define FXAA_QUALITY_P9 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 28)
				#define FXAA_QUALITY_PS 11
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 4.0
				#define FXAA_QUALITY_P10 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 29)
				#define FXAA_QUALITY_PS 12
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 2.0
				#define FXAA_QUALITY_P10 4.0
				#define FXAA_QUALITY_P11 8.0
		#endif

		/*============================================================================
												 FXAA QUALITY - EXTREME QUALITY
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 39)
				#define FXAA_QUALITY_PS 12
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.0
				#define FXAA_QUALITY_P2 1.0
				#define FXAA_QUALITY_P3 1.0
				#define FXAA_QUALITY_P4 1.0
				#define FXAA_QUALITY_P5 1.5
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 2.0
				#define FXAA_QUALITY_P10 4.0
				#define FXAA_QUALITY_P11 8.0
		#endif



		/*============================================================================

																		API PORTING

		============================================================================*/
		#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)
				#define FxaaBool bool
				#define FxaaDiscard discard
				#define FxaaFloat float
				#define FxaaFloat2 vec2
				#define FxaaFloat3 vec3
				#define FxaaFloat4 vec4
				#define FxaaHalf float
				#define FxaaHalf2 vec2
				#define FxaaHalf3 vec3
				#define FxaaHalf4 vec4
				#define FxaaInt2 ivec2
				#define FxaaSat(x) clamp(x, 0.0, 1.0)
				#define FxaaTex sampler2D
		#else
				#define FxaaBool bool
				#define FxaaDiscard clip(-1)
				#define FxaaFloat float
				#define FxaaFloat2 float2
				#define FxaaFloat3 float3
				#define FxaaFloat4 float4
				#define FxaaHalf half
				#define FxaaHalf2 half2
				#define FxaaHalf3 half3
				#define FxaaHalf4 half4
				#define FxaaSat(x) saturate(x)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_100 == 1)
			#define FxaaTexTop(t, p) texture2D(t, p, 0.0)
			#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_120 == 1)
				// Requires,
				//	#version 120
				// And at least,
				//	#extension GL_EXT_gpu_shader4 : enable
				//	(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)
				#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
				#if (FXAA_FAST_PIXEL_OFFSET == 1)
						#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)
				#else
						#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
				#endif
				#if (FXAA_GATHER4_ALPHA == 1)
						// use #extension GL_ARB_gpu_shader5 : enable
						#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
						#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
						#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
						#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_130 == 1)
				// Requires "#version 130" or better
				#define FxaaTexTop(t, p) textureLod(t, p, 0.0)
				#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
				#if (FXAA_GATHER4_ALPHA == 1)
						// use #extension GL_ARB_gpu_shader5 : enable
						#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
						#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
						#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
						#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_3 == 1)
				#define FxaaInt2 float2
				#define FxaaTex sampler2D
				#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))
				#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_4 == 1)
				#define FxaaInt2 int2
				struct FxaaTex { SamplerState smpl; Texture2D tex; };
				#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
				#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_5 == 1)
				#define FxaaInt2 int2
				struct FxaaTex { SamplerState smpl; Texture2D tex; };
				#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
				#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
				#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)
				#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)
				#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)
				#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)
		#endif


		/*============================================================================
											 GREEN AS LUMA OPTION SUPPORT FUNCTION
		============================================================================*/
		#if (FXAA_GREEN_AS_LUMA == 0)
				FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
		#else
				FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
		#endif




		/*============================================================================

																 FXAA3 QUALITY - PC

		============================================================================*/
		#if (FXAA_PC == 1)
		/*--------------------------------------------------------------------------*/
		FxaaFloat4 FxaaPixelShader(
				//
				// Use noperspective interpolation here (turn off perspective interpolation).
				// {xy} = center of pixel
				FxaaFloat2 pos,
				//
				// Used only for FXAA Console, and not used on the 360 version.
				// Use noperspective interpolation here (turn off perspective interpolation).
				// {xy_} = upper left of pixel
				// {_zw} = lower right of pixel
				FxaaFloat4 fxaaConsolePosPos,
				//
				// Input color texture.
				// {rgb_} = color in linear or perceptual color space
				// if (FXAA_GREEN_AS_LUMA == 0)
				//		 {__a} = luma in perceptual color space (not linear)
				FxaaTex tex,
				//
				// Only used on the optimized 360 version of FXAA Console.
				// For everything but 360, just use the same input here as for "tex".
				// For 360, same texture, just alias with a 2nd sampler.
				// This sampler needs to have an exponent bias of -1.
				FxaaTex fxaaConsole360TexExpBiasNegOne,
				//
				// Only used on the optimized 360 version of FXAA Console.
				// For everything but 360, just use the same input here as for "tex".
				// For 360, same texture, just alias with a 3nd sampler.
				// This sampler needs to have an exponent bias of -2.
				FxaaTex fxaaConsole360TexExpBiasNegTwo,
				//
				// Only used on FXAA Quality.
				// This must be from a constant/uniform.
				// {x_} = 1.0/screenWidthInPixels
				// {_y} = 1.0/screenHeightInPixels
				FxaaFloat2 fxaaQualityRcpFrame,
				//
				// Only used on FXAA Console.
				// This must be from a constant/uniform.
				// This effects sub-pixel AA quality and inversely sharpness.
				//	 Where N ranges between,
				//		 N = 0.50 (default)
				//		 N = 0.33 (sharper)
				// {x__} = -N/screenWidthInPixels
				// {_y_} = -N/screenHeightInPixels
				// {_z_} =	N/screenWidthInPixels
				// {__w} =	N/screenHeightInPixels
				FxaaFloat4 fxaaConsoleRcpFrameOpt,
				//
				// Only used on FXAA Console.
				// Not used on 360, but used on PS3 and PC.
				// This must be from a constant/uniform.
				// {x__} = -2.0/screenWidthInPixels
				// {_y_} = -2.0/screenHeightInPixels
				// {_z_} =	2.0/screenWidthInPixels
				// {__w} =	2.0/screenHeightInPixels
				FxaaFloat4 fxaaConsoleRcpFrameOpt2,
				//
				// Only used on FXAA Console.
				// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.
				// This must be from a constant/uniform.
				// {x__} =	8.0/screenWidthInPixels
				// {_y_} =	8.0/screenHeightInPixels
				// {_z_} = -4.0/screenWidthInPixels
				// {__w} = -4.0/screenHeightInPixels
				FxaaFloat4 fxaaConsole360RcpFrameOpt2,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_SUBPIX define.
				// It is here now to allow easier tuning.
				// Choose the amount of sub-pixel aliasing removal.
				// This can effect sharpness.
				//	 1.00 - upper limit (softer)
				//	 0.75 - default amount of filtering
				//	 0.50 - lower limit (sharper, less sub-pixel aliasing removal)
				//	 0.25 - almost off
				//	 0.00 - completely off
				FxaaFloat fxaaQualitySubpix,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
				// It is here now to allow easier tuning.
				// The minimum amount of local contrast required to apply algorithm.
				//	 0.333 - too little (faster)
				//	 0.250 - low quality
				//	 0.166 - default
				//	 0.125 - high quality
				//	 0.063 - overkill (slower)
				FxaaFloat fxaaQualityEdgeThreshold,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
				// It is here now to allow easier tuning.
				// Trims the algorithm from processing darks.
				//	 0.0833 - upper limit (default, the start of visible unfiltered edges)
				//	 0.0625 - high quality (faster)
				//	 0.0312 - visible limit (slower)
				// Special notes when using FXAA_GREEN_AS_LUMA,
				//	 Likely want to set this to zero.
				//	 As colors that are mostly not-green
				//	 will appear very dark in the green channel!
				//	 Tune by looking at mostly non-green content,
				//	 then start at zero and increase until aliasing is a problem.
				FxaaFloat fxaaQualityEdgeThresholdMin,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.
				// It is here now to allow easier tuning.
				// This does not effect PS3, as this needs to be compiled in.
				//	 Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.
				//	 Due to the PS3 being ALU bound,
				//	 there are only three safe values here: 2 and 4 and 8.
				//	 These options use the shaders ability to a free *|/ by 2|4|8.
				// For all other platforms can be a non-power of two.
				//	 8.0 is sharper (default!!!)
				//	 4.0 is softer
				//	 2.0 is really soft (good only for vector graphics inputs)
				FxaaFloat fxaaConsoleEdgeSharpness,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.
				// It is here now to allow easier tuning.
				// This does not effect PS3, as this needs to be compiled in.
				//	 Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.
				//	 Due to the PS3 being ALU bound,
				//	 there are only two safe values here: 1/4 and 1/8.
				//	 These options use the shaders ability to a free *|/ by 2|4|8.
				// The console setting has a different mapping than the quality setting.
				// Other platforms can use other values.
				//	 0.125 leaves less aliasing, but is softer (default!!!)
				//	 0.25 leaves more aliasing, and is sharper
				FxaaFloat fxaaConsoleEdgeThreshold,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.
				// It is here now to allow easier tuning.
				// Trims the algorithm from processing darks.
				// The console setting has a different mapping than the quality setting.
				// This only applies when FXAA_EARLY_EXIT is 1.
				// This does not apply to PS3,
				// PS3 was simplified to avoid more shader instructions.
				//	 0.06 - faster but more aliasing in darks
				//	 0.05 - default
				//	 0.04 - slower and less aliasing in darks
				// Special notes when using FXAA_GREEN_AS_LUMA,
				//	 Likely want to set this to zero.
				//	 As colors that are mostly not-green
				//	 will appear very dark in the green channel!
				//	 Tune by looking at mostly non-green content,
				//	 then start at zero and increase until aliasing is a problem.
				FxaaFloat fxaaConsoleEdgeThresholdMin,
				//
				// Extra constants for 360 FXAA Console only.
				// Use zeros or anything else for other platforms.
				// These must be in physical constant registers and NOT immediates.
				// Immediates will result in compiler un-optimizing.
				// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)
				FxaaFloat4 fxaaConsole360ConstDir
		) {
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posM;
				posM.x = pos.x;
				posM.y = pos.y;
				#if (FXAA_GATHER4_ALPHA == 1)
						#if (FXAA_DISCARD == 0)
								FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
								#if (FXAA_GREEN_AS_LUMA == 0)
										#define lumaM rgbyM.w
								#else
										#define lumaM rgbyM.y
								#endif
						#endif
						#if (FXAA_GREEN_AS_LUMA == 0)
								FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);
								FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));
						#else
								FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);
								FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));
						#endif
						#if (FXAA_DISCARD == 1)
								#define lumaM luma4A.w
						#endif
						#define lumaE luma4A.z
						#define lumaS luma4A.x
						#define lumaSE luma4A.y
						#define lumaNW luma4B.w
						#define lumaN luma4B.z
						#define lumaW luma4B.x
				#else
						FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
						#if (FXAA_GREEN_AS_LUMA == 0)
								#define lumaM rgbyM.w
						#else
								#define lumaM rgbyM.y
						#endif
						#if (FXAA_GLSL_100 == 1)
							FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));
						#else
							FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
						#endif
				#endif
		/*--------------------------------------------------------------------------*/
				FxaaFloat maxSM = max(lumaS, lumaM);
				FxaaFloat minSM = min(lumaS, lumaM);
				FxaaFloat maxESM = max(lumaE, maxSM);
				FxaaFloat minESM = min(lumaE, minSM);
				FxaaFloat maxWN = max(lumaN, lumaW);
				FxaaFloat minWN = min(lumaN, lumaW);
				FxaaFloat rangeMax = max(maxWN, maxESM);
				FxaaFloat rangeMin = min(minWN, minESM);
				FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
				FxaaFloat range = rangeMax - rangeMin;
				FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
				FxaaBool earlyExit = range < rangeMaxClamped;
		/*--------------------------------------------------------------------------*/
				if(earlyExit)
						#if (FXAA_DISCARD == 1)
								FxaaDiscard;
						#else
								return rgbyM;
						#endif
		/*--------------------------------------------------------------------------*/
				#if (FXAA_GATHER4_ALPHA == 0)
						#if (FXAA_GLSL_100 == 1)
							FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));
						#else
							FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
						#endif
				#else
						FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
						FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
				#endif
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNS = lumaN + lumaS;
				FxaaFloat lumaWE = lumaW + lumaE;
				FxaaFloat subpixRcpRange = 1.0/range;
				FxaaFloat subpixNSWE = lumaNS + lumaWE;
				FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
				FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNESE = lumaNE + lumaSE;
				FxaaFloat lumaNWNE = lumaNW + lumaNE;
				FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
				FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNWSW = lumaNW + lumaSW;
				FxaaFloat lumaSWSE = lumaSW + lumaSE;
				FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
				FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
				FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
				FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
				FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
				FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
		/*--------------------------------------------------------------------------*/
				FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
				FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
				FxaaBool horzSpan = edgeHorz >= edgeVert;
				FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
		/*--------------------------------------------------------------------------*/
				if(!horzSpan) lumaN = lumaW;
				if(!horzSpan) lumaS = lumaE;
				if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
				FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
		/*--------------------------------------------------------------------------*/
				FxaaFloat gradientN = lumaN - lumaM;
				FxaaFloat gradientS = lumaS - lumaM;
				FxaaFloat lumaNN = lumaN + lumaM;
				FxaaFloat lumaSS = lumaS + lumaM;
				FxaaBool pairN = abs(gradientN) >= abs(gradientS);
				FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
				if(pairN) lengthSign = -lengthSign;
				FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posB;
				posB.x = posM.x;
				posB.y = posM.y;
				FxaaFloat2 offNP;
				offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
				offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
				if(!horzSpan) posB.x += lengthSign * 0.5;
				if( horzSpan) posB.y += lengthSign * 0.5;
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posN;
				posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
				posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
				FxaaFloat2 posP;
				posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
				posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
				FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
				FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
				FxaaFloat subpixE = subpixC * subpixC;
				FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
		/*--------------------------------------------------------------------------*/
				if(!pairN) lumaNN = lumaSS;
				FxaaFloat gradientScaled = gradient * 1.0/4.0;
				FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
				FxaaFloat subpixF = subpixD * subpixE;
				FxaaBool lumaMLTZero = lumaMM < 0.0;
		/*--------------------------------------------------------------------------*/
				lumaEndN -= lumaNN * 0.5;
				lumaEndP -= lumaNN * 0.5;
				FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
				FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
				if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
				if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
				FxaaBool doneNP = (!doneN) || (!doneP);
				if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
				if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
		/*--------------------------------------------------------------------------*/
				if(doneNP) {
						if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
						if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
						doneNP = (!doneN) || (!doneP);
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
		/*--------------------------------------------------------------------------*/
						#if (FXAA_QUALITY_PS > 3)
						if(doneNP) {
								if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
								if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
								if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
								if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
								if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
								doneNP = (!doneN) || (!doneP);
								if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
								if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
		/*--------------------------------------------------------------------------*/
								#if (FXAA_QUALITY_PS > 4)
								if(doneNP) {
										if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
										if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
										if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
										if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
										if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
										doneNP = (!doneN) || (!doneP);
										if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
										if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
		/*--------------------------------------------------------------------------*/
										#if (FXAA_QUALITY_PS > 5)
										if(doneNP) {
												if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
												if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
												if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
												if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
												if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
												doneNP = (!doneN) || (!doneP);
												if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
												if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
		/*--------------------------------------------------------------------------*/
												#if (FXAA_QUALITY_PS > 6)
												if(doneNP) {
														if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
														if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
														if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
														if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
														if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
														doneNP = (!doneN) || (!doneP);
														if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
														if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
		/*--------------------------------------------------------------------------*/
														#if (FXAA_QUALITY_PS > 7)
														if(doneNP) {
																if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
																if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
																if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
																if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
																doneN = abs(lumaEndN) >= gradientScaled;
																doneP = abs(lumaEndP) >= gradientScaled;
																if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
																if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
																doneNP = (!doneN) || (!doneP);
																if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
																if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
		/*--------------------------------------------------------------------------*/
				#if (FXAA_QUALITY_PS > 8)
				if(doneNP) {
						if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
						if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
						doneNP = (!doneN) || (!doneP);
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
		/*--------------------------------------------------------------------------*/
						#if (FXAA_QUALITY_PS > 9)
						if(doneNP) {
								if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
								if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
								if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
								if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
								if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
								doneNP = (!doneN) || (!doneP);
								if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
								if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
		/*--------------------------------------------------------------------------*/
								#if (FXAA_QUALITY_PS > 10)
								if(doneNP) {
										if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
										if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
										if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
										if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
										if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
										doneNP = (!doneN) || (!doneP);
										if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
										if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
		/*--------------------------------------------------------------------------*/
										#if (FXAA_QUALITY_PS > 11)
										if(doneNP) {
												if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
												if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
												if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
												if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
												if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
												doneNP = (!doneN) || (!doneP);
												if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
												if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
		/*--------------------------------------------------------------------------*/
												#if (FXAA_QUALITY_PS > 12)
												if(doneNP) {
														if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
														if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
														if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
														if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
														if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
														doneNP = (!doneN) || (!doneP);
														if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
														if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
		/*--------------------------------------------------------------------------*/
												}
												#endif
		/*--------------------------------------------------------------------------*/
										}
										#endif
		/*--------------------------------------------------------------------------*/
								}
								#endif
		/*--------------------------------------------------------------------------*/
						}
						#endif
		/*--------------------------------------------------------------------------*/
				}
				#endif
		/*--------------------------------------------------------------------------*/
														}
														#endif
		/*--------------------------------------------------------------------------*/
												}
												#endif
		/*--------------------------------------------------------------------------*/
										}
										#endif
		/*--------------------------------------------------------------------------*/
								}
								#endif
		/*--------------------------------------------------------------------------*/
						}
						#endif
		/*--------------------------------------------------------------------------*/
				}
		/*--------------------------------------------------------------------------*/
				FxaaFloat dstN = posM.x - posN.x;
				FxaaFloat dstP = posP.x - posM.x;
				if(!horzSpan) dstN = posM.y - posN.y;
				if(!horzSpan) dstP = posP.y - posM.y;
		/*--------------------------------------------------------------------------*/
				FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
				FxaaFloat spanLength = (dstP + dstN);
				FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
				FxaaFloat spanLengthRcp = 1.0/spanLength;
		/*--------------------------------------------------------------------------*/
				FxaaBool directionN = dstN < dstP;
				FxaaFloat dst = min(dstN, dstP);
				FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
				FxaaFloat subpixG = subpixF * subpixF;
				FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
				FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
		/*--------------------------------------------------------------------------*/
				FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
				FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
				if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
				if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
				#if (FXAA_DISCARD == 1)
						return FxaaTexTop(tex, posM);
				#else
						return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
				#endif
		}
		/*==========================================================================*/
		#endif

		void main() {
			gl_FragColor = FxaaPixelShader(
				vUv,
				vec4(0.0),
				tDiffuse,
				tDiffuse,
				tDiffuse,
				resolution,
				vec4(0.0),
				vec4(0.0),
				vec4(0.0),
				0.75,
				0.166,
				0.0833,
				0.0,
				0.0,
				0.0,
				vec4(0.0)
			);

			// TODO avoid querying texture twice for same texel
			gl_FragColor.a = texture2D(tDiffuse, vUv).a;
		}`}; THREE.FXAAShader = e
	}(), THREE.GammaCorrectionShader = {
		uniforms: { tDiffuse: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vUv );

			gl_FragColor = LinearTosRGB( tex ); // optional: LinearToGamma( tex, float( GAMMA_FACTOR ) );

		}`}, function () {
		var e = {
			uniforms: { tInput: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

		 vUv = uv;
		 gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

	 }`, fragmentShader: `

		varying vec2 vUv;

		uniform sampler2D tInput;

		void main() {

			gl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );

		}`}, t = {
			uniforms: { tInput: { value: null }, fStepSize: { value: 1 }, vSunPositionScreenSpace: { value: new THREE.Vector3 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

		 vUv = uv;
		 gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

	 }`, fragmentShader: `

		#define TAPS_PER_PASS 6.0

		varying vec2 vUv;

		uniform sampler2D tInput;

		uniform vec3 vSunPositionScreenSpace;
		uniform float fStepSize; // filter step size

		void main() {

		// delta from current pixel to "sun" position

			vec2 delta = vSunPositionScreenSpace.xy - vUv;
			float dist = length( delta );

		// Step vector (uv space)

			vec2 stepv = fStepSize * delta / dist;

		// Number of iterations between pixel and sun

			float iters = dist/fStepSize;

			vec2 uv = vUv.xy;
			float col = 0.0;

		// This breaks ANGLE in Chrome 22
		//	- see http://code.google.com/p/chromium/issues/detail?id=153105

		/*
		// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),
		// so i've just left the loop

		"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {",

		// Accumulate samples, making sure we dont walk past the light source.

		// The check for uv.y < 1 would not be necessary with "border" UV wrap
		// mode, with a black border color. I don't think this is currently
		// exposed by three.js. As a result there might be artifacts when the
		// sun is to the left, right or bottom of screen as these cases are
		// not specifically handled.

		"	col += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );",
		"	uv += stepv;",

		"}",
		*/

		// Unrolling loop manually makes it work in ANGLE

			float f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) ); // used to fade out godrays

			if ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;
			uv += stepv;

			if ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;
			uv += stepv;

			if ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;
			uv += stepv;

			if ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;
			uv += stepv;

			if ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;
			uv += stepv;

			if ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;
			uv += stepv;

		// Should technically be dividing by 'iters but 'TAPS_PER_PASS' smooths out
		// objectionable artifacts, in particular near the sun position. The side
		// effect is that the result is darker than it should be around the sun, as
		// TAPS_PER_PASS is greater than the number of samples actually accumulated.
		// When the result is inverted (in the shader 'godrays_combine this produces
		// a slight bright spot at the position of the sun, even when it is occluded.

			gl_FragColor = vec4( col/TAPS_PER_PASS );
			gl_FragColor.a = 1.0;

		}`}, i = {
			uniforms: { tColors: { value: null }, tGodRays: { value: null }, fGodRayIntensity: { value: .69 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		varying vec2 vUv;

		uniform sampler2D tColors;
		uniform sampler2D tGodRays;

		uniform float fGodRayIntensity;

		void main() {

		// Since THREE.MeshDepthMaterial renders foreground objects white and background
		// objects black, the god-rays will be white streaks. Therefore value is inverted
		// before being combined with tColors

			gl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );
			gl_FragColor.a = 1.0;

		}`}, r = {
			uniforms: { vSunPositionScreenSpace: { value: new THREE.Vector3 }, fAspect: { value: 1 }, sunColor: { value: new THREE.Color(16772608) }, bgColor: { value: new THREE.Color(0) } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		varying vec2 vUv;

		uniform vec3 vSunPositionScreenSpace;
		uniform float fAspect;

		uniform vec3 sunColor;
		uniform vec3 bgColor;

		void main() {

			vec2 diff = vUv - vSunPositionScreenSpace.xy;

		// Correct for aspect ratio

			diff.x *= fAspect;

			float prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );
			prop = 0.35 * pow( 1.0 - prop, 3.0 );

			gl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;
			gl_FragColor.w = 1.0;

		}`}; THREE.GodRaysCombineShader = i, THREE.GodRaysDepthMaskShader = e, THREE.GodRaysFakeSunShader = r, THREE.GodRaysGenerateShader = t
	}(), function () {
		var e = {
			uniforms: { tDiffuse: { value: null }, shape: { value: 1 }, radius: { value: 4 }, rotateR: { value: Math.PI / 12 * 1 }, rotateG: { value: Math.PI / 12 * 2 }, rotateB: { value: Math.PI / 12 * 3 }, scatter: { value: 0 }, width: { value: 1 }, height: { value: 1 }, blending: { value: 1 }, blendingMode: { value: 1 }, greyscale: { value: !1 }, disable: { value: !1 } }, vertexShader: `

		varying vec2 vUV;

		void main() {

			vUV = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

		}`, fragmentShader: `

		#define SQRT2_MINUS_ONE 0.41421356
		#define SQRT2_HALF_MINUS_ONE 0.20710678
		#define PI2 6.28318531
		#define SHAPE_DOT 1
		#define SHAPE_ELLIPSE 2
		#define SHAPE_LINE 3
		#define SHAPE_SQUARE 4
		#define BLENDING_LINEAR 1
		#define BLENDING_MULTIPLY 2
		#define BLENDING_ADD 3
		#define BLENDING_LIGHTER 4
		#define BLENDING_DARKER 5
		uniform sampler2D tDiffuse;
		uniform float radius;
		uniform float rotateR;
		uniform float rotateG;
		uniform float rotateB;
		uniform float scatter;
		uniform float width;
		uniform float height;
		uniform int shape;
		uniform bool disable;
		uniform float blending;
		uniform int blendingMode;
		varying vec2 vUV;
		uniform bool greyscale;
		const int samples = 8;

		float blend( float a, float b, float t ) {

		// linear blend
			return a * ( 1.0 - t ) + b * t;

		}

		float hypot( float x, float y ) {

		// vector magnitude
			return sqrt( x * x + y * y );

		}

		float rand( vec2 seed ){

		// get pseudo-random number
			return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );

		}

		float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {

		// apply shape-specific transforms
			float dist = hypot( coord.x - p.x, coord.y - p.y );
			float rad = channel;

			if ( shape == SHAPE_DOT ) {

				rad = pow( abs( rad ), 1.125 ) * rad_max;

			} else if ( shape == SHAPE_ELLIPSE ) {

				rad = pow( abs( rad ), 1.125 ) * rad_max;

				if ( dist != 0.0 ) {
					float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );
					dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;
				}

			} else if ( shape == SHAPE_LINE ) {

				rad = pow( abs( rad ), 1.5) * rad_max;
				float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;
				dist = hypot( normal.x * dot_p, normal.y * dot_p );

			} else if ( shape == SHAPE_SQUARE ) {

				float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;
				float sin_t = abs( sin( theta ) );
				float cos_t = abs( cos( theta ) );
				rad = pow( abs( rad ), 1.4 );
				rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );

			}

			return rad - dist;

		}

		struct Cell {

		// grid sample positions
			vec2 normal;
			vec2 p1;
			vec2 p2;
			vec2 p3;
			vec2 p4;
			float samp2;
			float samp1;
			float samp3;
			float samp4;

		};

		vec4 getSample( vec2 point ) {

		// multi-sampled point
			vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );
			float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;
			float step = PI2 / float( samples );
			float dist = radius * 0.66;

			for ( int i = 0; i < samples; ++i ) {

				float r = base + step * float( i );
				vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );
				tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );

			}

			tex /= float( samples ) + 1.0;
			return tex;

		}

		float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {

		// get colour for given point
			float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;

			if ( channel == 0 ) {

				c.samp1 = getSample( c.p1 ).r;
				c.samp2 = getSample( c.p2 ).r;
				c.samp3 = getSample( c.p3 ).r;
				c.samp4 = getSample( c.p4 ).r;

			} else if (channel == 1) {

				c.samp1 = getSample( c.p1 ).g;
				c.samp2 = getSample( c.p2 ).g;
				c.samp3 = getSample( c.p3 ).g;
				c.samp4 = getSample( c.p4 ).g;

			} else {

				c.samp1 = getSample( c.p1 ).b;
				c.samp3 = getSample( c.p3 ).b;
				c.samp2 = getSample( c.p2 ).b;
				c.samp4 = getSample( c.p4 ).b;

			}

			dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );
			dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );
			dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );
			dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );
			res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;
			res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;
			res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;
			res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;
			res = clamp( res, 0.0, 1.0 );

			return res;

		}

		Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {

		// get containing cell
			Cell c;

		// calc grid
			vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );
			float threshold = step * 0.5;
			float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );
			float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );
			vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );
			float offset_normal = mod( hypot( offset.x, offset.y ), step );
			float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;
			float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;
			float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );
			float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;
			float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;

		// get closest corner
			c.normal = n;
			c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;
			c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;

		// scatter
			if ( scatter != 0.0 ) {

				float off_mag = scatter * threshold * 0.5;
				float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;
				c.p1.x += cos( off_angle ) * off_mag;
				c.p1.y += sin( off_angle ) * off_mag;

			}

		// find corners
			float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );
			float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );
			c.p2.x = c.p1.x - n.x * normal_step;
			c.p2.y = c.p1.y - n.y * normal_step;
			c.p3.x = c.p1.x + n.y * line_step;
			c.p3.y = c.p1.y - n.x * line_step;
			c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;
			c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;

			return c;

		}

		float blendColour( float a, float b, float t ) {

		// blend colours
			if ( blendingMode == BLENDING_LINEAR ) {
				return blend( a, b, 1.0 - t );
			} else if ( blendingMode == BLENDING_ADD ) {
				return blend( a, min( 1.0, a + b ), t );
			} else if ( blendingMode == BLENDING_MULTIPLY ) {
				return blend( a, max( 0.0, a * b ), t );
			} else if ( blendingMode == BLENDING_LIGHTER ) {
				return blend( a, max( a, b ), t );
			} else if ( blendingMode == BLENDING_DARKER ) {
				return blend( a, min( a, b ), t );
			} else {
				return blend( a, b, 1.0 - t );
			}

		}

		void main() {

			if ( ! disable ) {

		// setup
				vec2 p = vec2( vUV.x * width, vUV.y * height );
				vec2 origin = vec2( 0, 0 );
				float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;

		// get channel samples
				Cell cell_r = getReferenceCell( p, origin, rotateR, radius );
				Cell cell_g = getReferenceCell( p, origin, rotateG, radius );
				Cell cell_b = getReferenceCell( p, origin, rotateB, radius );
				float r = getDotColour( cell_r, p, 0, rotateR, aa );
				float g = getDotColour( cell_g, p, 1, rotateG, aa );
				float b = getDotColour( cell_b, p, 2, rotateB, aa );

		// blend with original
				vec4 colour = texture2D( tDiffuse, vUV );
				r = blendColour( r, colour.r, blending );
				g = blendColour( g, colour.g, blending );
				b = blendColour( b, colour.b, blending );

				if ( greyscale ) {
					r = g = b = (r + b + g) / 3.0;
				}

				gl_FragColor = vec4( r, g, b, 1.0 );

			} else {

				gl_FragColor = texture2D( tDiffuse, vUV );

			}

		}`}; THREE.HalftoneShader = e
	}(), THREE.HorizontalBlurShader = {
		uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`}, THREE.HorizontalTiltShiftShader = {
		uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 }, r: { value: .35 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float h;
		uniform float r;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			float hh = h * abs( r - vUv.y );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`}, THREE.HueSaturationShader = {
		uniforms: { tDiffuse: { value: null }, hue: { value: 0 }, saturation: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float hue;
		uniform float saturation;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// hue
			float angle = hue * 3.14159265;
			float s = sin(angle), c = cos(angle);
			vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;
			float len = length(gl_FragColor.rgb);
			gl_FragColor.rgb = vec3(
				dot(gl_FragColor.rgb, weights.xyz),
				dot(gl_FragColor.rgb, weights.zxy),
				dot(gl_FragColor.rgb, weights.yzx)
			);

			// saturation
			float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;
			if (saturation > 0.0) {
				gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));
			} else {
				gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);
			}

		}`}, THREE.KaleidoShader = {
		uniforms: { tDiffuse: { value: null }, sides: { value: 6 }, angle: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float sides;
		uniform float angle;

		varying vec2 vUv;

		void main() {

			vec2 p = vUv - 0.5;
			float r = length(p);
			float a = atan(p.y, p.x) + angle;
			float tau = 2. * 3.1416 ;
			a = mod(a, tau/sides);
			a = abs(a - tau/sides/2.) ;
			p = r * vec2(cos(a), sin(a));
			vec4 color = texture2D(tDiffuse, p + 0.5);
			gl_FragColor = color;

		}`}, function () {
		var e = {
			shaderID: "luminosityHighPass", uniforms: { tDiffuse: { value: null }, luminosityThreshold: { value: 1 }, smoothWidth: { value: 1 }, defaultColor: { value: new THREE.Color(0) }, defaultOpacity: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`}; THREE.LuminosityHighPassShader = e
	}(), THREE.LuminosityShader = {
		uniforms: { tDiffuse: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#include <common>

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float l = linearToRelativeLuminance( texel.rgb );

			gl_FragColor = vec4( l, l, l, texel.w );

		}`}, THREE.MirrorShader = {
		uniforms: { tDiffuse: { value: null }, side: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform int side;

		varying vec2 vUv;

		void main() {

			vec2 p = vUv;
			if (side == 0){
				if (p.x > 0.5) p.x = 1.0 - p.x;
			}else if (side == 1){
				if (p.x < 0.5) p.x = 1.0 - p.x;
			}else if (side == 2){
				if (p.y < 0.5) p.y = 1.0 - p.y;
			}else if (side == 3){
				if (p.y > 0.5) p.y = 1.0 - p.y;
			}
			vec4 color = texture2D(tDiffuse, p);
			gl_FragColor = color;

		}`}, function () {
		var e = {
			defines: { TOON: !0, MATCAP: !0, MATCAP_BLENDING_ADD: !0 }, uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib.toon.uniforms, THREE.ShaderLib.phong.uniforms, THREE.ShaderLib.matcap.uniforms]), vertexShader: THREE.ShaderLib.phong.vertexShader, fragmentShader: THREE.ShaderLib.phong.fragmentShader.replace("#include <common>", `
					#ifdef USE_MATCAP
						uniform sampler2D matcap;
					#endif

					#include <common>
				`).replace("#include <envmap_common_pars_fragment>", `
					#include <gradientmap_pars_fragment>
					#include <envmap_common_pars_fragment>
				`).replace("#include <lights_phong_pars_fragment>", `
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`).replace("#include <envmap_fragment>", `
					#include <envmap_fragment>
					
#ifdef USE_MATCAP

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
	vec4 matcapColor = texture2D( matcap, uv );
	matcapColor = matcapTexelToLinear( matcapColor );

	#ifdef MATCAP_BLENDING_MULTIPLY

		outgoingLight *= matcapColor.rgb;

	#elif defined( MATCAP_BLENDING_ADD )

		outgoingLight += matcapColor.rgb;

	#endif

#endif

				`)
		}; THREE.MMDToonShader = e
	}(), function () {
		var e = {
			uniforms: { heightMap: { value: null }, resolution: { value: new THREE.Vector2(512, 512) }, scale: { value: new THREE.Vector2(1, 1) }, height: { value: .05 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float height;
		uniform vec2 resolution;
		uniform sampler2D heightMap;

		varying vec2 vUv;

		void main() {

			float val = texture2D( heightMap, vUv ).x;

			float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;
			float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;

			gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );

		}`}; THREE.NormalMapShader = e
	}(), THREE.ParallaxShader = {
		modes: { none: "NO_PARALLAX", basic: "USE_BASIC_PARALLAX", steep: "USE_STEEP_PARALLAX", occlusion: "USE_OCLUSION_PARALLAX", relief: "USE_RELIEF_PARALLAX" }, uniforms: { bumpMap: { value: null }, map: { value: null }, parallaxScale: { value: null }, parallaxMinLayers: { value: null }, parallaxMaxLayers: { value: null } }, vertexShader: `

		varying vec2 vUv;
		varying vec3 vViewPosition;
		varying vec3 vNormal;

		void main() {

			vUv = uv;
			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			vViewPosition = -mvPosition.xyz;
			vNormal = normalize( normalMatrix * normal );
			gl_Position = projectionMatrix * mvPosition;

		}`, fragmentShader: `

		uniform sampler2D bumpMap;
		uniform sampler2D map;

		uniform float parallaxScale;
		uniform float parallaxMinLayers;
		uniform float parallaxMaxLayers;

		varying vec2 vUv;
		varying vec3 vViewPosition;
		varying vec3 vNormal;

		#ifdef USE_BASIC_PARALLAX

			vec2 parallaxMap( in vec3 V ) {

				float initialHeight = texture2D( bumpMap, vUv ).r;

				// No Offset Limitting: messy, floating output at grazing angles.
			//"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;",

			// Offset Limiting
				vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;
				return vUv - texCoordOffset;

			}

		#else

			vec2 parallaxMap( in vec3 V ) {

				// Determine number of layers from angle between V and N
				float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );

				float layerHeight = 1.0 / numLayers;
				float currentLayerHeight = 0.0;
				// Shift of texture coordinates for each iteration
				vec2 dtex = parallaxScale * V.xy / V.z / numLayers;

				vec2 currentTextureCoords = vUv;

				float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;

				// while ( heightFromTexture > currentLayerHeight )
				// Infinite loops are not well supported. Do a "large" finite
				// loop, but not too large, as it slows down some compilers.
				for ( int i = 0; i < 30; i += 1 ) {
					if ( heightFromTexture <= currentLayerHeight ) {
						break;
					}
					currentLayerHeight += layerHeight;
					// Shift texture coordinates along vector V
					currentTextureCoords -= dtex;
					heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;
				}

				#ifdef USE_STEEP_PARALLAX

					return currentTextureCoords;

				#elif defined( USE_RELIEF_PARALLAX )

					vec2 deltaTexCoord = dtex / 2.0;
					float deltaHeight = layerHeight / 2.0;

					// Return to the mid point of previous layer
					currentTextureCoords += deltaTexCoord;
					currentLayerHeight -= deltaHeight;

					// Binary search to increase precision of Steep Parallax Mapping
					const int numSearches = 5;
					for ( int i = 0; i < numSearches; i += 1 ) {

						deltaTexCoord /= 2.0;
						deltaHeight /= 2.0;
						heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;
						// Shift along or against vector V
						if( heightFromTexture > currentLayerHeight ) { // Below the surface

							currentTextureCoords -= deltaTexCoord;
							currentLayerHeight += deltaHeight;

						} else { // above the surface

							currentTextureCoords += deltaTexCoord;
							currentLayerHeight -= deltaHeight;

						}

					}
					return currentTextureCoords;

				#elif defined( USE_OCLUSION_PARALLAX )

					vec2 prevTCoords = currentTextureCoords + dtex;

					// Heights for linear interpolation
					float nextH = heightFromTexture - currentLayerHeight;
					float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;

					// Proportions for linear interpolation
					float weight = nextH / ( nextH - prevH );

					// Interpolation of texture coordinates
					return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );

				#else // NO_PARALLAX

					return vUv;

				#endif

			}
		#endif

		vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {

 			vec2 texDx = dFdx( vUv );
			vec2 texDy = dFdy( vUv );

			vec3 vSigmaX = dFdx( surfPosition );
			vec3 vSigmaY = dFdy( surfPosition );
			vec3 vR1 = cross( vSigmaY, surfNormal );
			vec3 vR2 = cross( surfNormal, vSigmaX );
			float fDet = dot( vSigmaX, vR1 );

			vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );
			vec3 vProjVtex;
			vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;
			vProjVtex.z = dot( surfNormal, viewPosition );

			return parallaxMap( vProjVtex );
		}

		void main() {

			vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );
			gl_FragColor = texture2D( map, mapUv );

		}`}, THREE.PixelShader = {
		uniforms: { tDiffuse: { value: null }, resolution: { value: null }, pixelSize: { value: 1 } }, vertexShader: `

		varying highp vec2 vUv;

			void main() {

				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float pixelSize;
		uniform vec2 resolution;

		varying highp vec2 vUv;

		void main(){

			vec2 dxy = pixelSize / resolution;
			vec2 coord = dxy * floor( vUv / dxy );
			gl_FragColor = texture2D(tDiffuse, coord);

		}`}, THREE.RGBShiftShader = {
		uniforms: { tDiffuse: { value: null }, amount: { value: .005 }, angle: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float amount;
		uniform float angle;

		varying vec2 vUv;

		void main() {

			vec2 offset = amount * vec2( cos(angle), sin(angle));
			vec4 cr = texture2D(tDiffuse, vUv + offset);
			vec4 cga = texture2D(tDiffuse, vUv);
			vec4 cb = texture2D(tDiffuse, vUv - offset);
			gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);

		}`}, function () {
		var e = {
			defines: { NUM_SAMPLES: 7, NUM_RINGS: 4, NORMAL_TEXTURE: 0, DIFFUSE_TEXTURE: 0, DEPTH_PACKING: 1, PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, tDiffuse: { value: null }, tNormal: { value: null }, size: { value: new THREE.Vector2(512, 512) }, cameraNear: { value: 1 }, cameraFar: { value: 100 }, cameraProjectionMatrix: { value: new THREE.Matrix4 }, cameraInverseProjectionMatrix: { value: new THREE.Matrix4 }, scale: { value: 1 }, intensity: { value: .1 }, bias: { value: .5 }, minResolution: { value: 0 }, kernelRadius: { value: 100 }, randomSeed: { value: 0 } }, vertexShader: `

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`, fragmentShader: `

		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform sampler2D tDepth;

		#if NORMAL_TEXTURE == 1
		uniform sampler2D tNormal;
		#endif

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			#if NORMAL_TEXTURE == 1
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#else
			return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}`}; THREE.SAOShader = e
	}(), THREE.SepiaShader = {
		uniforms: { tDiffuse: { value: null }, amount: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float amount;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 color = texture2D( tDiffuse, vUv );
			vec3 c = color.rgb;

			color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );
			color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );
			color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );

			gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );

		}`}, function () {
		var e = {
			defines: { SMAA_THRESHOLD: "0.1" }, uniforms: { tDiffuse: { value: null }, resolution: { value: new THREE.Vector2(1 / 1024, 1 / 512) } }, vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		void SMAAEdgeDetectionVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAAEdgeDetectionVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];

		vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {
			vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );

			// Calculate color deltas:
			vec4 delta;
			vec3 C = texture2D( colorTex, texcoord ).rgb;

			vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;
			vec3 t = abs( C - Cleft );
			delta.x = max( max( t.r, t.g ), t.b );

			vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;
			t = abs( C - Ctop );
			delta.y = max( max( t.r, t.g ), t.b );

			// We do the usual threshold:
			vec2 edges = step( threshold, delta.xy );

			// Then discard if there is no edge:
			if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )
				discard;

			// Calculate right and bottom deltas:
			vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;
			t = abs( C - Cright );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;
			t = abs( C - Cbottom );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the maximum delta in the direct neighborhood:
			float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );

			// Calculate left-left and top-top deltas:
			vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;
			t = abs( C - Cleftleft );
			delta.z = max( max( t.r, t.g ), t.b );

			vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;
			t = abs( C - Ctoptop );
			delta.w = max( max( t.r, t.g ), t.b );

			// Calculate the final maximum delta:
			maxDelta = max( max( maxDelta, delta.z ), delta.w );

			// Local contrast adaptation in action:
			edges.xy *= step( 0.5 * maxDelta, delta.xy );

			return vec4( edges, 0.0, 0.0 );
		}

		void main() {

			gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );

		}`}, t = {
			defines: { SMAA_MAX_SEARCH_STEPS: "8", SMAA_AREATEX_MAX_DISTANCE: "16", SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )", SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )" }, uniforms: { tDiffuse: { value: null }, tArea: { value: null }, tSearch: { value: null }, resolution: { value: new THREE.Vector2(1 / 1024, 1 / 512) } }, vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 3 ];
		varying vec2 vPixcoord;

		void SMAABlendingWeightCalculationVS( vec2 texcoord ) {
			vPixcoord = texcoord / resolution;

			// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 ); // WebGL port note: Changed sign in Y and W components
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 ); // WebGL port note: Changed sign in Y and W components

			// And these for the searches, they indicate the ends of the loops:
			vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );

		}

		void main() {

			vUv = uv;

			SMAABlendingWeightCalculationVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )

		uniform sampler2D tDiffuse;
		uniform sampler2D tArea;
		uniform sampler2D tSearch;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[3];
		varying vec2 vPixcoord;

		#if __VERSION__ == 100
		vec2 round( vec2 x ) {
			return sign( x ) * floor( abs( x ) + 0.5 );
		}
		#endif

		float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {
			// Not required if searchTex accesses are set to point:
			// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
			// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
			//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
			e.r = bias + e.r * scale;
			return 255.0 * texture2D( searchTex, e, 0.0 ).r;
		}

		float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			/**
				* @PSEUDO_GATHER4
				* This texcoord has been offset by (-0.25, -0.125) in the vertex shader to
				* sample between edge, thus fetching four edges in a row.
				* Sampling with different offsets in each direction allows to disambiguate
				* which edges are active from the four fetched ones.
				*/
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			// We correct the previous (-0.25, -0.125) offset we applied:
			texcoord.x += 0.25 * resolution.x;

			// The searches are bias by 1, so adjust the coords accordingly:
			texcoord.x += resolution.x;

			// Disambiguate the length added by the last step:
			texcoord.x += 2.0 * resolution.x; // Undo last step
			texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

			return texcoord.x;
		}

		float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 0.0, 1.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 2.0, 0.0 ) * resolution;
				if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;
			}

			texcoord.x -= 0.25 * resolution.x;
			texcoord.x -= resolution.x;
			texcoord.x -= 2.0 * resolution.x;
			texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );

			return texcoord.x;
		}

		float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord += vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y -= 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y; // WebGL port note: Changed sign
			texcoord.y -= 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {
			vec2 e = vec2( 1.0, 0.0 );

			for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) { // WebGL port note: Changed while to for
				e = texture2D( edgesTex, texcoord, 0.0 ).rg;
				texcoord -= vec2( 0.0, 2.0 ) * resolution; // WebGL port note: Changed sign
				if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;
			}

			texcoord.y += 0.25 * resolution.y; // WebGL port note: Changed sign
			texcoord.y += resolution.y; // WebGL port note: Changed sign
			texcoord.y += 2.0 * resolution.y; // WebGL port note: Changed sign
			texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 ); // WebGL port note: Changed sign

			return texcoord.y;
		}

		vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {
			// Rounding prevents precision errors of bilinear filtering:
			vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;

			// We do a scale and bias for mapping to texel space:
			texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );

			// Move to proper place, according to the subpixel offset:
			texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

			return texture2D( areaTex, texcoord, 0.0 ).rg;
		}

		vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {
			vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );

			vec2 e = texture2D( edgesTex, texcoord ).rg;

			if ( e.g > 0.0 ) { // Edge at north
				vec2 d;

				// Find the distance to the left:
				vec2 coords;
				coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );
				coords.y = offset[ 1 ].y; // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)
				d.x = coords.x;

				// Now fetch the left crossing edges, two at a time using bilinear
				// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
				// discern what value each edge has:
				float e1 = texture2D( edgesTex, coords, 0.0 ).r;

				// Find the distance to the right:
				coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );
				d.y = coords.x;

				// We want the distances to be in pixel units (doing this here allow to
				// better interleave arithmetic and memory accesses):
				d = d / resolution.x - pixcoord.x;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the right crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;

				// Ok, we know how this pattern looks like, now it is time for getting
				// the actual area:
				weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );
			}

			if ( e.r > 0.0 ) { // Edge at west
				vec2 d;

				// Find the distance to the top:
				vec2 coords;

				coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );
				coords.x = offset[ 0 ].x; // offset[1].x = texcoord.x - 0.25 * resolution.x;
				d.x = coords.y;

				// Fetch the top crossing edges:
				float e1 = texture2D( edgesTex, coords, 0.0 ).g;

				// Find the distance to the bottom:
				coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );
				d.y = coords.y;

				// We want the distances to be in pixel units:
				d = d / resolution.y - pixcoord.y;

				// SMAAArea below needs a sqrt, as the areas texture is compressed
				// quadratically:
				vec2 sqrt_d = sqrt( abs( d ) );

				// Fetch the bottom crossing edges:
				coords.y -= 1.0 * resolution.y; // WebGL port note: Added
				float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;

				// Get the area for this direction:
				weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );
			}

			return weights;
		}

		void main() {

			gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );

		}`}, i = {
			uniforms: { tDiffuse: { value: null }, tColor: { value: null }, resolution: { value: new THREE.Vector2(1 / 1024, 1 / 512) } }, vertexShader: `

		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		void SMAANeighborhoodBlendingVS( vec2 texcoord ) {
			vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 ); // WebGL port note: Changed sign in W component
			vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 ); // WebGL port note: Changed sign in W component
		}

		void main() {

			vUv = uv;

			SMAANeighborhoodBlendingVS( vUv );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform sampler2D tColor;
		uniform vec2 resolution;

		varying vec2 vUv;
		varying vec4 vOffset[ 2 ];

		vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {
			// Fetch the blending weights for current pixel:
			vec4 a;
			a.xz = texture2D( blendTex, texcoord ).xz;
			a.y = texture2D( blendTex, offset[ 1 ].zw ).g;
			a.w = texture2D( blendTex, offset[ 1 ].xy ).a;

			// Is there any blending weight with a value greater than 0.0?
			if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {
				return texture2D( colorTex, texcoord, 0.0 );
			} else {
				// Up to 4 lines can be crossing a pixel (one through each edge). We
				// favor blending by choosing the line with the maximum weight for each
				// direction:
				vec2 offset;
				offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
				offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs

				// Then we go in the direction that has the maximum weight:
				if ( abs( offset.x ) > abs( offset.y )) { // horizontal vs. vertical
					offset.y = 0.0;
				} else {
					offset.x = 0.0;
				}

				// Fetch the opposite color and lerp by hand:
				vec4 C = texture2D( colorTex, texcoord, 0.0 );
				texcoord += sign( offset ) * resolution;
				vec4 Cop = texture2D( colorTex, texcoord, 0.0 );
				float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );

				// WebGL port note: Added gamma correction
				C.xyz = pow(C.xyz, vec3(2.2));
				Cop.xyz = pow(Cop.xyz, vec3(2.2));
				vec4 mixed = mix(C, Cop, s);
				mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

				return mixed;
			}
		}

		void main() {

			gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );

		}`}; THREE.SMAABlendShader = i, THREE.SMAAEdgesShader = e, THREE.SMAAWeightsShader = t
	}(), function () {
		var e = {
			uniforms: { tDiffuse: { value: null }, resolution: { value: new THREE.Vector2 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;

		void main() {

			vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );

		// kernel definition (in glsl matrices are filled in column-major order)

			const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel
			const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel

		// fetch the 3x3 neighbourhood of a fragment

		// first column

			float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;
			float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;
			float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;

		// second column

			float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;
			float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;
			float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;

		// third column

			float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;
			float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;
			float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;

		// gradient value in x direction

			float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +
				Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +
				Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;

		// gradient value in y direction

			float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +
				Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +
				Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;

		// magnitute of the total gradient

			float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );

			gl_FragColor = vec4( vec3( G ), 1 );

		}`}; THREE.SobelOperatorShader = e
	}(), function () {
		var e = {
			defines: { PERSPECTIVE_CAMERA: 1, KERNEL_SIZE: 32 }, uniforms: { tDiffuse: { value: null }, tNormal: { value: null }, tDepth: { value: null }, tNoise: { value: null }, kernel: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, resolution: { value: new THREE.Vector2 }, cameraProjectionMatrix: { value: new THREE.Matrix4 }, cameraInverseProjectionMatrix: { value: new THREE.Matrix4 }, kernelRadius: { value: 8 }, minDistance: { value: .005 }, maxDistance: { value: .05 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform sampler2D tNormal;
		uniform sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away

		varying vec2 vUv;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {

			return texture2D( tDepth, screenPosition ).x;

		}

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );

			vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
			vec3 viewNormal = getViewNormal( vUv );

			vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
			vec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;

			// compute matrix used to reorient a kernel vector

			vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
			vec3 bitangent = cross( viewNormal, tangent );
			mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

		 float occlusion = 0.0;

		 for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

				vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
				vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

				vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
				samplePointNDC /= samplePointNDC.w;

				vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

				float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
				float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
				float delta = sampleDepth - realDepth;

				if ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion

					occlusion += 1.0;

				}

			}

			occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

			gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );

		}`}, t = {
			defines: { PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null } }, vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );

		}`}, i = {
			uniforms: { tDiffuse: { value: null }, resolution: { value: new THREE.Vector2 } }, vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`}; THREE.SSAOBlurShader = i, THREE.SSAODepthShader = t, THREE.SSAOShader = e
	}(), function () {
		var e = {
			defines: { MAX_STEP: 0, PERSPECTIVE_CAMERA: !0, SPECULAR: !0, FILL_HOLE: !0, INFINITE_THICK: !1 }, uniforms: { tDiffuse: { value: null }, tSpecular: { value: null }, tNormalSelects: { value: null }, tRefractive: { value: null }, tDepth: { value: null }, tDepthSelects: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, resolution: { value: new THREE.Vector2 }, cameraProjectionMatrix: { value: new THREE.Matrix4 }, cameraInverseProjectionMatrix: { value: new THREE.Matrix4 }, ior: { value: 1.03 }, cameraRange: { value: 0 }, maxDistance: { value: 180 }, surfDist: { value: .007 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tDepthSelects;
		uniform sampler2D tNormalSelects;
		uniform sampler2D tRefractive;
		uniform sampler2D tDiffuse;
		uniform sampler2D tSpecular;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float ior;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		uniform float maxDistance;
		uniform float surfDist;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getDepthSelects( const in vec2 uv ) {
			return texture2D( tDepthSelects, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef PERSPECTIVE_CAMERA
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormalSelects( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormalSelects, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void setResultColor(vec2 uv){
			vec4 refractColor=texture2D(tDiffuse,uv);
			#ifdef SPECULAR
				vec4 specularColor=texture2D(tSpecular,vUv);
				gl_FragColor.xyz=mix(refractColor.xyz,vec3(1),specularColor.r);
				// gl_FragColor.xyz=refractColor.xyz*(1.+specularColor.r*3.);
			#else
				gl_FragColor.xyz=refractColor.xyz;
			#endif
			gl_FragColor.a=1.;

		}
		void main(){
			if(ior==1.) return; // Adding this line may have better performance, but more importantly, it can avoid display errors at the very edges of the model when IOR is equal to 1.

			float refractive=texture2D(tRefractive,vUv).r;
			if(refractive<=0.) return;

			// gl_FragColor=vec4(0,0,.5,1);return;
			vec3 viewNormalSelects=getViewNormalSelects( vUv );
			// gl_FragColor=vec4(viewNormalSelects,1);return;

			// if(viewNormalSelects.x<=0.&&viewNormalSelects.y<=0.&&viewNormalSelects.z<=0.) return;

			float depth = getDepthSelects( vUv );
			float viewZ = getViewZ( depth );
			// if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			#ifdef PERSPECTIVE_CAMERA
				vec3 viewIncidentDir=normalize(viewPosition);
			#else
				vec3 viewIncidentDir=vec3(0,0,-1);
			#endif

			vec3 viewRefractDir=refract(viewIncidentDir,viewNormalSelects,1./ior);
			// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml

			vec3 d1viewPosition=viewPosition+viewRefractDir*maxDistance;
			#ifdef PERSPECTIVE_CAMERA
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewRefractDir.z;
					d1viewPosition=viewPosition+viewRefractDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			#ifdef FILL_HOLE
				bool isRough=false;
				vec2 uvRough;
			#endif
			for(float i=0.;i<float(MAX_STEP);i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef PERSPECTIVE_CAMERA
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewRefractRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
					float sD=surfDist*cW;
				#else
					float viewRefractRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
					float sD=surfDist;
				#endif

				#ifdef FILL_HOLE // TODO: May can improve performance by check if INFINITE_THICK too.
					if(viewRefractRayZ<=vZ){
						if(!isRough){
							uvRough=uv;
							isRough=true;
						}
					}
				#endif

				bool hit;
				#ifdef INFINITE_THICK
					hit=viewRefractRayZ<=vZ;
				#else
					if(viewRefractRayZ-sD>vZ) continue;
					float away=pointToLineDistance(vP,viewPosition,d1viewPosition);
					hit=away<=sD;
				#endif
				if(hit){
					setResultColor(uv);
					return;
				}
			}

			#ifdef FILL_HOLE
				if(isRough){
					setResultColor(uvRough);
				}
				// else{
				// 	gl_FragColor=texture2D(tDiffuse,vUv);//For afterward add color mix feature.
				// }
			#else
				// gl_FragColor=texture2D(tDiffuse,vUv);//For afterward add color mix feature.
			#endif
		}
	`}; THREE.SSRrDepthShader = {
			defines: { PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `

		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
			gl_FragColor = vec4( vec3( d ), 1.0 );

		}

	`}, THREE.SSRrShader = e
	}(), function () {
		var e = {
			defines: { MAX_STEP: 0, PERSPECTIVE_CAMERA: !0, DISTANCE_ATTENUATION: !0, FRESNEL: !0, INFINITE_THICK: !1, SELECTIVE: !1 }, uniforms: { tDiffuse: { value: null }, tNormal: { value: null }, tMetalness: { value: null }, tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null }, resolution: { value: new THREE.Vector2 }, cameraProjectionMatrix: { value: new THREE.Matrix4 }, cameraInverseProjectionMatrix: { value: new THREE.Matrix4 }, opacity: { value: .5 }, maxDistance: { value: 180 }, cameraRange: { value: 0 }, thickness: { value: .018 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `
		// precision highp float;
		precision highp sampler2D;
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tNormal;
		uniform sampler2D tMetalness;
		uniform sampler2D tDiffuse;
		uniform float cameraRange;
		uniform vec2 resolution;
		uniform float opacity;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float maxDistance;
		uniform float thickness;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;
		#include <packing>
		float pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {
			//x0: point, x1: linePointA, x2: linePointB
			//https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html
			return length(cross(x0-x1,x0-x2))/length(x2-x1);
		}
		float pointPlaneDistance(vec3 point,vec3 planePoint,vec3 planeNormal){
			// https://mathworld.wolfram.com/Point-PlaneDistance.html
			//// https://en.wikipedia.org/wiki/Plane_(geometry)
			//// http://paulbourke.net/geometry/pointlineplane/
			float a=planeNormal.x,b=planeNormal.y,c=planeNormal.z;
			float x0=point.x,y0=point.y,z0=point.z;
			float x=planePoint.x,y=planePoint.y,z=planePoint.z;
			float d=-(a*x+b*y+c*z);
			float distance=(a*x0+b*y0+c*z0+d)/sqrt(a*a+b*b+c*c);
			return distance;
		}
		float getDepth( const in vec2 uv ) {
			return texture2D( tDepth, uv ).x;
		}
		float getViewZ( const in float depth ) {
			#ifdef PERSPECTIVE_CAMERA
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
		vec3 getViewPosition( const in vec2 uv, const in float depth/*clip space*/, const in float clipW ) {
			vec4 clipPosition = vec4( ( vec3( uv, depth ) - 0.5 ) * 2.0, 1.0 );//ndc
			clipPosition *= clipW; //clip
			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;//view
		}
		vec3 getViewNormal( const in vec2 uv ) {
			return unpackRGBToNormal( texture2D( tNormal, uv ).xyz );
		}
		vec2 viewPositionToXY(vec3 viewPosition){
			vec2 xy;
			vec4 clip=cameraProjectionMatrix*vec4(viewPosition,1);
			xy=clip.xy;//clip
			float clipW=clip.w;
			xy/=clipW;//NDC
			xy=(xy+1.)/2.;//uv
			xy*=resolution;//screen
			return xy;
		}
		void main(){
			#ifdef SELECTIVE
				float metalness=texture2D(tMetalness,vUv).r;
				if(metalness==0.) return;
			#endif

			float depth = getDepth( vUv );
			float viewZ = getViewZ( depth );
			if(-viewZ>=cameraFar) return;

			float clipW = cameraProjectionMatrix[2][3] * viewZ+cameraProjectionMatrix[3][3];
			vec3 viewPosition=getViewPosition( vUv, depth, clipW );

			vec2 d0=gl_FragCoord.xy;
			vec2 d1;

			vec3 viewNormal=getViewNormal( vUv );

			#ifdef PERSPECTIVE_CAMERA
				vec3 viewIncidentDir=normalize(viewPosition);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#else
				vec3 viewIncidentDir=vec3(0,0,-1);
				vec3 viewReflectDir=reflect(viewIncidentDir,viewNormal);
			#endif

			float maxReflectRayLen=maxDistance/dot(-viewIncidentDir,viewNormal);
			// dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html
			// if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)
			// maxDistance/maxReflectRayLen=cos(theta)
			// maxDistance/maxReflectRayLen==dot(a,b)
			// maxReflectRayLen==maxDistance/dot(a,b)

			vec3 d1viewPosition=viewPosition+viewReflectDir*maxReflectRayLen;
			#ifdef PERSPECTIVE_CAMERA
				if(d1viewPosition.z>-cameraNear){
					//https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx
					float t=(-cameraNear-viewPosition.z)/viewReflectDir.z;
					d1viewPosition=viewPosition+viewReflectDir*t;
				}
			#endif
			d1=viewPositionToXY(d1viewPosition);

			float totalLen=length(d1-d0);
			float xLen=d1.x-d0.x;
			float yLen=d1.y-d0.y;
			float totalStep=max(abs(xLen),abs(yLen));
			float xSpan=xLen/totalStep;
			float ySpan=yLen/totalStep;
			for(float i=0.;i<float(MAX_STEP);i++){
				if(i>=totalStep) break;
				vec2 xy=vec2(d0.x+i*xSpan,d0.y+i*ySpan);
				if(xy.x<0.||xy.x>resolution.x||xy.y<0.||xy.y>resolution.y) break;
				float s=length(xy-d0)/totalLen;
				vec2 uv=xy/resolution;

				float d = getDepth(uv);
				float vZ = getViewZ( d );
				if(-vZ>=cameraFar) continue;
				float cW = cameraProjectionMatrix[2][3] * vZ+cameraProjectionMatrix[3][3];
				vec3 vP=getViewPosition( uv, d, cW );

				#ifdef PERSPECTIVE_CAMERA
					// https://www.comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf
					float recipVPZ=1./viewPosition.z;
					float viewReflectRayZ=1./(recipVPZ+s*(1./d1viewPosition.z-recipVPZ));
				#else
					float viewReflectRayZ=viewPosition.z+s*(d1viewPosition.z-viewPosition.z);
				#endif

				// if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.
				// https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164
				if(viewReflectRayZ<=vZ){

					bool hit;
					#ifdef INFINITE_THICK
						hit=true;
					#else
						float away=pointToLineDistance(vP,viewPosition,d1viewPosition);

						float minThickness;
						vec2 xyNeighbor=xy;
						xyNeighbor.x+=1.;
						vec2 uvNeighbor=xyNeighbor/resolution;
						vec3 vPNeighbor=getViewPosition(uvNeighbor,d,cW);
						minThickness=vPNeighbor.x-vP.x;
						minThickness*=3.;
						float tk=max(minThickness,thickness);

						hit=away<=tk;
					#endif

					if(hit){
						vec3 vN=getViewNormal( uv );
						if(dot(viewReflectDir,vN)>=0.) continue;
						float distance=pointPlaneDistance(vP,viewPosition,viewNormal);
						if(distance>maxDistance) break;
						float op=opacity;
						#ifdef DISTANCE_ATTENUATION
							float ratio=1.-(distance/maxDistance);
							float attenuation=ratio*ratio;
							op=opacity*attenuation;
						#endif
						#ifdef FRESNEL
							float fresnelCoe=(dot(viewIncidentDir,viewReflectDir)+1.)/2.;
							op*=fresnelCoe;
						#endif
						vec4 reflectColor=texture2D(tDiffuse,uv);
						gl_FragColor.xyz=reflectColor.xyz;
						gl_FragColor.a=op;
						break;
					}
				}
			}
		}
	`}, t = {
			defines: { PERSPECTIVE_CAMERA: 1 }, uniforms: { tDepth: { value: null }, cameraNear: { value: null }, cameraFar: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `

		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 uv ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, uv ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, uv ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			float d = 1.0 - depth;
			// d=(d-.999)*1000.;
			gl_FragColor = vec4( vec3( d ), 1.0 );

		}

	`}, i = {
			uniforms: { tDiffuse: { value: null }, resolution: { value: new THREE.Vector2 }, opacity: { value: .5 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}

	`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec2 resolution;
		varying vec2 vUv;
		void main() {
			//reverse engineering from PhotoShop blur filter, then change coefficient

			vec2 texelSize = ( 1.0 / resolution );

			vec4 c=texture2D(tDiffuse,vUv);

			vec2 offset;

			offset=(vec2(-1,0))*texelSize;
			vec4 cl=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(1,0))*texelSize;
			vec4 cr=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,-1))*texelSize;
			vec4 cb=texture2D(tDiffuse,vUv+offset);

			offset=(vec2(0,1))*texelSize;
			vec4 ct=texture2D(tDiffuse,vUv+offset);

			// float coeCenter=.5;
			// float coeSide=.125;
			float coeCenter=.2;
			float coeSide=.2;
			float a=c.a*coeCenter+cl.a*coeSide+cr.a*coeSide+cb.a*coeSide+ct.a*coeSide;
			vec3 rgb=(c.rgb*c.a*coeCenter+cl.rgb*cl.a*coeSide+cr.rgb*cr.a*coeSide+cb.rgb*cb.a*coeSide+ct.rgb*ct.a*coeSide)/a;
			gl_FragColor=vec4(rgb,a);

		}
	`}; THREE.SSRBlurShader = i, THREE.SSRDepthShader = t, THREE.SSRShader = e
	}(), function () { const e = THREE.ShaderChunk.meshphong_frag.slice(0, THREE.ShaderChunk.meshphong_frag.indexOf("void main() {")), t = THREE.ShaderChunk.meshphong_frag.slice(THREE.ShaderChunk.meshphong_frag.indexOf("void main() {")); var i, r = { uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib.phong.uniforms, { thicknessMap: { value: null }, thicknessColor: { value: new THREE.Color(16777215) }, thicknessDistortion: { value: .1 }, thicknessAmbient: { value: 0 }, thicknessAttenuation: { value: .1 }, thicknessPower: { value: 2 }, thicknessScale: { value: 10 } }]), vertexShader: ["#define USE_UV", THREE.ShaderChunk.meshphong_vert].join("\n"), fragmentShader: ["#define USE_UV", "#define SUBSURFACE", e, "uniform sampler2D thicknessMap;", "uniform float thicknessPower;", "uniform float thicknessScale;", "uniform float thicknessDistortion;", "uniform float thicknessAmbient;", "uniform float thicknessAttenuation;", "uniform vec3 thicknessColor;", "void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {", "\tvec3 thickness = thicknessColor * texture2D(thicknessMap, uv).r;", "\tvec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));", "\tfloat scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;", "\tvec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;", "\treflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;", "}", t.replace("#include <lights_fragment_begin>", (r = THREE.ShaderChunk.lights_fragment_begin, i = ["RE_Direct( directLight, geometry, material, reflectedLight );", "#if defined( SUBSURFACE ) && defined( USE_UV )", " RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);", "#endif"].join("\n"), r.split("RE_Direct( directLight, geometry, material, reflectedLight );").join(i)))].join("\n") }; THREE.SubsurfaceScatteringShader = r }(), THREE.TechnicolorShader = {
		uniforms: { tDiffuse: { value: null } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		varying vec2 vUv;

		void main() {

			vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );
			vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);

			gl_FragColor = newTex;

		}`}, THREE.ToneMapShader = {
		uniforms: { tDiffuse: { value: null }, averageLuminance: { value: 1 }, luminanceMap: { value: null }, maxLuminance: { value: 16 }, minLuminance: { value: .01 }, middleGrey: { value: .6 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#include <common>

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		uniform float middleGrey;
		uniform float minLuminance;
		uniform float maxLuminance;
		#ifdef ADAPTED_LUMINANCE
			uniform sampler2D luminanceMap;
		#else
			uniform float averageLuminance;
		#endif

		vec3 ToneMap( vec3 vColor ) {
			#ifdef ADAPTED_LUMINANCE
				// Get the calculated average luminance
				float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;
			#else
				float fLumAvg = averageLuminance;
			#endif

			// Calculate the luminance of the current pixel
			float fLumPixel = linearToRelativeLuminance( vColor );

			// Apply the modified operator (Eq. 4)
			float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );

			float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);
			return fLumCompressed * vColor;
		}

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );

		}`}, function () {
		var e = {
			uniforms: { uDirLightPos: { value: new THREE.Vector3 }, uDirLightColor: { value: new THREE.Color(15658734) }, uAmbientLightColor: { value: new THREE.Color(328965) }, uBaseColor: { value: new THREE.Color(16777215) } }, vertexShader: `

		varying vec3 vNormal;
		varying vec3 vRefract;

		void main() {

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			vec3 worldNormal = normalize ( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );

			vNormal = normalize( normalMatrix * normal );

			vec3 I = worldPosition.xyz - cameraPosition;
			vRefract = refract( normalize( I ), worldNormal, 1.02 );

			gl_Position = projectionMatrix * mvPosition;

		}`, fragmentShader: `

		uniform vec3 uBaseColor;

		uniform vec3 uDirLightPos;
		uniform vec3 uDirLightColor;

		uniform vec3 uAmbientLightColor;

		varying vec3 vNormal;

		varying vec3 vRefract;

		void main() {

			float directionalLightWeighting = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);
			vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;

			float intensity = smoothstep( - 0.5, 1.0, pow( length(lightWeighting), 20.0 ) );
			intensity += length(lightWeighting) * 0.2;

			float cameraWeighting = dot( normalize( vNormal ), vRefract );
			intensity += pow( 1.0 - length( cameraWeighting ), 6.0 );
			intensity = intensity * 0.2 + 0.3;

			if ( intensity < 0.50 ) {

				gl_FragColor = vec4( 2.0 * intensity * uBaseColor, 1.0 );

			} else {

				gl_FragColor = vec4( 1.0 - 2.0 * ( 1.0 - intensity ) * ( 1.0 - uBaseColor ), 1.0 );

		}

		}`}, t = {
			uniforms: { uDirLightPos: { value: new THREE.Vector3 }, uDirLightColor: { value: new THREE.Color(15658734) }, uAmbientLightColor: { value: new THREE.Color(328965) }, uBaseColor: { value: new THREE.Color(15658734) }, uLineColor1: { value: new THREE.Color(8421504) }, uLineColor2: { value: new THREE.Color(0) }, uLineColor3: { value: new THREE.Color(0) }, uLineColor4: { value: new THREE.Color(0) } }, vertexShader: `

		varying vec3 vNormal;

		void main() {

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			vNormal = normalize( normalMatrix * normal );

		}`, fragmentShader: `

		uniform vec3 uBaseColor;
		uniform vec3 uLineColor1;
		uniform vec3 uLineColor2;
		uniform vec3 uLineColor3;
		uniform vec3 uLineColor4;

		uniform vec3 uDirLightPos;
		uniform vec3 uDirLightColor;

		uniform vec3 uAmbientLightColor;

		varying vec3 vNormal;

		void main() {

			float camera = max( dot( normalize( vNormal ), vec3( 0.0, 0.0, 1.0 ) ), 0.4);
			float light = max( dot( normalize( vNormal ), uDirLightPos ), 0.0);

			gl_FragColor = vec4( uBaseColor, 1.0 );

			if ( length(uAmbientLightColor + uDirLightColor * light) < 1.00 ) {

				gl_FragColor *= vec4( uLineColor1, 1.0 );

			}

			if ( length(uAmbientLightColor + uDirLightColor * camera) < 0.50 ) {

				gl_FragColor *= vec4( uLineColor2, 1.0 );

			}

		}`}, i = {
			uniforms: { uDirLightPos: { value: new THREE.Vector3 }, uDirLightColor: { value: new THREE.Color(15658734) }, uAmbientLightColor: { value: new THREE.Color(328965) }, uBaseColor: { value: new THREE.Color(16777215) }, uLineColor1: { value: new THREE.Color(0) }, uLineColor2: { value: new THREE.Color(0) }, uLineColor3: { value: new THREE.Color(0) }, uLineColor4: { value: new THREE.Color(0) } }, vertexShader: `

		varying vec3 vNormal;

		void main() {

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			vNormal = normalize( normalMatrix * normal );

		}`, fragmentShader: `

		uniform vec3 uBaseColor;
		uniform vec3 uLineColor1;
		uniform vec3 uLineColor2;
		uniform vec3 uLineColor3;
		uniform vec3 uLineColor4;

		uniform vec3 uDirLightPos;
		uniform vec3 uDirLightColor;

		uniform vec3 uAmbientLightColor;

		varying vec3 vNormal;

		void main() {

			float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);
			vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;

			gl_FragColor = vec4( uBaseColor, 1.0 );

			if ( length(lightWeighting) < 1.00 ) {

				if ( mod(gl_FragCoord.x + gl_FragCoord.y, 10.0) == 0.0) {

					gl_FragColor = vec4( uLineColor1, 1.0 );

				}

			}

			if ( length(lightWeighting) < 0.75 ) {

				if (mod(gl_FragCoord.x - gl_FragCoord.y, 10.0) == 0.0) {

					gl_FragColor = vec4( uLineColor2, 1.0 );

				}

			}

			if ( length(lightWeighting) < 0.50 ) {

				if (mod(gl_FragCoord.x + gl_FragCoord.y - 5.0, 10.0) == 0.0) {

					gl_FragColor = vec4( uLineColor3, 1.0 );

				}

			}

			if ( length(lightWeighting) < 0.3465 ) {

				if (mod(gl_FragCoord.x - gl_FragCoord.y - 5.0, 10.0) == 0.0) {

					gl_FragColor = vec4( uLineColor4, 1.0 );

			}

			}

		}`}, r = {
			uniforms: { uDirLightPos: { value: new THREE.Vector3 }, uDirLightColor: { value: new THREE.Color(15658734) }, uAmbientLightColor: { value: new THREE.Color(328965) }, uBaseColor: { value: new THREE.Color(16777215) }, uLineColor1: { value: new THREE.Color(0) } }, vertexShader: `

		varying vec3 vNormal;

		void main() {

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			vNormal = normalize( normalMatrix * normal );

		}`, fragmentShader: `

		uniform vec3 uBaseColor;
		uniform vec3 uLineColor1;
		uniform vec3 uLineColor2;
		uniform vec3 uLineColor3;
		uniform vec3 uLineColor4;

		uniform vec3 uDirLightPos;
		uniform vec3 uDirLightColor;

		uniform vec3 uAmbientLightColor;

		varying vec3 vNormal;

		void main() {

		float directionalLightWeighting = max( dot( normalize(vNormal), uDirLightPos ), 0.0);
		vec3 lightWeighting = uAmbientLightColor + uDirLightColor * directionalLightWeighting;

		gl_FragColor = vec4( uBaseColor, 1.0 );

		if ( length(lightWeighting) < 1.00 ) {

				if ( ( mod(gl_FragCoord.x, 4.001) + mod(gl_FragCoord.y, 4.0) ) > 6.00 ) {

					gl_FragColor = vec4( uLineColor1, 1.0 );

				}

			}

			if ( length(lightWeighting) < 0.50 ) {

				if ( ( mod(gl_FragCoord.x + 2.0, 4.001) + mod(gl_FragCoord.y + 2.0, 4.0) ) > 6.00 ) {

					gl_FragColor = vec4( uLineColor1, 1.0 );

				}

			}

		}`}; THREE.ToonShader1 = e, THREE.ToonShader2 = t, THREE.ToonShaderDotted = r, THREE.ToonShaderHatching = i
	}(), function () {
		var e = {
			uniforms: { texture: { value: null }, delta: { value: new THREE.Vector2(1, 1) } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		#include <common>

		#define ITERATIONS 10.0

		uniform sampler2D texture;
		uniform vec2 delta;

		varying vec2 vUv;

		void main() {

			vec4 color = vec4( 0.0 );

			float total = 0.0;

		// randomize the lookup values to hide the fixed number of samples

			float offset = rand( vUv );

			for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {

				float percent = ( t + offset - 0.5 ) / ITERATIONS;
				float weight = 1.0 - abs( percent );

				color += texture2D( texture, vUv + delta * percent ) * weight;
				total += weight;

			}

			gl_FragColor = color / total;

		}`}; THREE.TriangleBlurShader = e
	}(), THREE.UnpackDepthRGBAShader = {
		uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		#include <packing>

		void main() {

			float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );
			gl_FragColor = vec4( vec3( depth ), opacity );

		}`}, THREE.VerticalBlurShader = {
		uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`}, THREE.VerticalTiltShiftShader = {
		uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 }, r: { value: .35 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float v;
		uniform float r;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			float vv = v * abs( r - vUv.y );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;

			gl_FragColor = sum;

		}`}, THREE.VignetteShader = {
		uniforms: { tDiffuse: { value: null }, offset: { value: 1 }, darkness: { value: 1 } }, vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform float offset;
		uniform float darkness;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			// Eskil's vignette

			vec4 texel = texture2D( tDiffuse, vUv );
			vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );
			gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );

		}`}, function () {
		var e = {
			uniforms: { u_size: { value: new THREE.Vector3(1, 1, 1) }, u_renderstyle: { value: 0 }, u_renderthreshold: { value: .5 }, u_clim: { value: new THREE.Vector2(1, 1) }, u_data: { value: null }, u_cmdata: { value: null } }, vertexShader: `

		varying vec4 v_nearpos;
		varying vec4 v_farpos;
		varying vec3 v_position;

		void main() {
				// Prepare transforms to map to "camera view". See also:
				// https://threejs.org/docs/#api/renderers/webgl/WebGLProgram
				mat4 viewtransformf = modelViewMatrix;
				mat4 viewtransformi = inverse(modelViewMatrix);

				// Project local vertex coordinate to camera position. Then do a step
				// backward (in cam coords) to the near clipping plane, and project back. Do
				// the same for the far clipping plane. This gives us all the information we
				// need to calculate the ray and truncate it to the viewing cone.
				vec4 position4 = vec4(position, 1.0);
				vec4 pos_in_cam = viewtransformf * position4;

				// Intersection of ray and near clipping plane (z = -1 in clip coords)
				pos_in_cam.z = -pos_in_cam.w;
				v_nearpos = viewtransformi * pos_in_cam;

				// Intersection of ray and far clipping plane (z = +1 in clip coords)
				pos_in_cam.z = pos_in_cam.w;
				v_farpos = viewtransformi * pos_in_cam;

				// Set varyings and output pos
				v_position = position;
				gl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;
		}`, fragmentShader: `

				precision highp float;
				precision mediump sampler3D;

				uniform vec3 u_size;
				uniform int u_renderstyle;
				uniform float u_renderthreshold;
				uniform vec2 u_clim;

				uniform sampler3D u_data;
				uniform sampler2D u_cmdata;

				varying vec3 v_position;
				varying vec4 v_nearpos;
				varying vec4 v_farpos;

				// The maximum distance through our rendering volume is sqrt(3).
				const int MAX_STEPS = 887;	// 887 for 512^3, 1774 for 1024^3
				const int REFINEMENT_STEPS = 4;
				const float relative_step_size = 1.0;
				const vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);
				const vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);
				const vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);
				const float shininess = 40.0;

				void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);
				void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);

				float sample1(vec3 texcoords);
				vec4 apply_colormap(float val);
				vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);


				void main() {
						// Normalize clipping plane info
						vec3 farpos = v_farpos.xyz / v_farpos.w;
						vec3 nearpos = v_nearpos.xyz / v_nearpos.w;

						// Calculate unit vector pointing in the view direction through this fragment.
						vec3 view_ray = normalize(nearpos.xyz - farpos.xyz);

						// Compute the (negative) distance to the front surface or near clipping plane.
						// v_position is the back face of the cuboid, so the initial distance calculated in the dot
						// product below is the distance from near clip plane to the back of the cuboid
						float distance = dot(nearpos - v_position, view_ray);
						distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,
																				(u_size.x - 0.5 - v_position.x) / view_ray.x));
						distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,
																				(u_size.y - 0.5 - v_position.y) / view_ray.y));
						distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,
																				(u_size.z - 0.5 - v_position.z) / view_ray.z));

						// Now we have the starting position on the front surface
						vec3 front = v_position + view_ray * distance;

						// Decide how many steps to take
						int nsteps = int(-distance / relative_step_size + 0.5);
						if ( nsteps < 1 )
								discard;

						// Get starting location and step vector in texture coordinates
						vec3 step = ((v_position - front) / u_size) / float(nsteps);
						vec3 start_loc = front / u_size;

						// For testing: show the number of steps. This helps to establish
						// whether the rays are correctly oriented
						//'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);
						//'return;

						if (u_renderstyle == 0)
								cast_mip(start_loc, step, nsteps, view_ray);
						else if (u_renderstyle == 1)
								cast_iso(start_loc, step, nsteps, view_ray);

						if (gl_FragColor.a < 0.05)
								discard;
				}


				float sample1(vec3 texcoords) {
						/* Sample float value from a 3D texture. Assumes intensity data. */
						return texture(u_data, texcoords.xyz).r;
				}


				vec4 apply_colormap(float val) {
						val = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);
						return texture2D(u_cmdata, vec2(val, 0.5));
				}


				void cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {

						float max_val = -1e6;
						int max_i = 100;
						vec3 loc = start_loc;

						// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with
						// non-constant expression. So we use a hard-coded max, and an additional condition
						// inside the loop.
						for (int iter=0; iter<MAX_STEPS; iter++) {
								if (iter >= nsteps)
										break;
								// Sample from the 3D texture
								float val = sample1(loc);
								// Apply MIP operation
								if (val > max_val) {
										max_val = val;
										max_i = iter;
								}
								// Advance location deeper into the volume
								loc += step;
						}

						// Refine location, gives crispier images
						vec3 iloc = start_loc + step * (float(max_i) - 0.5);
						vec3 istep = step / float(REFINEMENT_STEPS);
						for (int i=0; i<REFINEMENT_STEPS; i++) {
								max_val = max(max_val, sample1(iloc));
								iloc += istep;
						}

						// Resolve final color
						gl_FragColor = apply_colormap(max_val);
				}


				void cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {

						gl_FragColor = vec4(0.0);	// init transparent
						vec4 color3 = vec4(0.0);	// final color
						vec3 dstep = 1.5 / u_size;	// step to sample derivative
						vec3 loc = start_loc;

						float low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);

						// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with
						// non-constant expression. So we use a hard-coded max, and an additional condition
						// inside the loop.
						for (int iter=0; iter<MAX_STEPS; iter++) {
								if (iter >= nsteps)
										break;

								// Sample from the 3D texture
								float val = sample1(loc);

								if (val > low_threshold) {
										// Take the last interval in smaller steps
										vec3 iloc = loc - 0.5 * step;
										vec3 istep = step / float(REFINEMENT_STEPS);
										for (int i=0; i<REFINEMENT_STEPS; i++) {
												val = sample1(iloc);
												if (val > u_renderthreshold) {
														gl_FragColor = add_lighting(val, iloc, dstep, view_ray);
														return;
												}
												iloc += istep;
										}
								}

								// Advance location deeper into the volume
								loc += step;
						}
				}


				vec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)
				{
					// Calculate color by incorporating lighting

						// View direction
						vec3 V = normalize(view_ray);

						// calculate normal vector from gradient
						vec3 N;
						float val1, val2;
						val1 = sample1(loc + vec3(-step[0], 0.0, 0.0));
						val2 = sample1(loc + vec3(+step[0], 0.0, 0.0));
						N[0] = val1 - val2;
						val = max(max(val1, val2), val);
						val1 = sample1(loc + vec3(0.0, -step[1], 0.0));
						val2 = sample1(loc + vec3(0.0, +step[1], 0.0));
						N[1] = val1 - val2;
						val = max(max(val1, val2), val);
						val1 = sample1(loc + vec3(0.0, 0.0, -step[2]));
						val2 = sample1(loc + vec3(0.0, 0.0, +step[2]));
						N[2] = val1 - val2;
						val = max(max(val1, val2), val);

						float gm = length(N); // gradient magnitude
						N = normalize(N);

						// Flip normal so it points towards viewer
						float Nselect = float(dot(N, V) > 0.0);
						N = (2.0 * Nselect - 1.0) * N;	// ==	Nselect * N - (1.0-Nselect)*N;

						// Init colors
						vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);
						vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);
						vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);

						// note: could allow multiple lights
						for (int i=0; i<1; i++)
						{
								 // Get light direction (make sure to prevent zero devision)
								vec3 L = normalize(view_ray);	//lightDirs[i];
								float lightEnabled = float( length(L) > 0.0 );
								L = normalize(L + (1.0 - lightEnabled));

								// Calculate lighting properties
								float lambertTerm = clamp(dot(N, L), 0.0, 1.0);
								vec3 H = normalize(L+V); // Halfway vector
								float specularTerm = pow(max(dot(H, N), 0.0), shininess);

								// Calculate mask
								float mask1 = lightEnabled;

								// Calculate colors
								ambient_color +=	mask1 * ambient_color;	// * gl_LightSource[i].ambient;
								diffuse_color +=	mask1 * lambertTerm;
								specular_color += mask1 * specularTerm * specular_color;
						}

						// Calculate final color by componing different components
						vec4 final_color;
						vec4 color = apply_colormap(val);
						final_color = color * (ambient_color + diffuse_color) + specular_color;
						final_color.a = color.a;
						return final_color;
				}`}; THREE.VolumeRenderShader1 = e
	}(), THREE.WaterRefractionShader = {
		uniforms: { color: { value: null }, time: { value: 0 }, tDiffuse: { value: null }, tDudv: { value: null }, textureMatrix: { value: null } }, vertexShader: `

		uniform mat4 textureMatrix;

		varying vec2 vUv;
		varying vec4 vUvRefraction;

		void main() {

			vUv = uv;

			vUvRefraction = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`, fragmentShader: `

		uniform vec3 color;
		uniform float time;
		uniform sampler2D tDiffuse;
		uniform sampler2D tDudv;

		varying vec2 vUv;
		varying vec4 vUvRefraction;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );

		}

		void main() {

		 float waveStrength = 0.5;
		 float waveSpeed = 0.03;

			// simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)

			vec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;
			distortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );
			vec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;

			// new uv coords

		 vec4 uv = vec4( vUvRefraction );
		 uv.xy += distortion;

			vec4 base = texture2DProj( tDiffuse, uv );

			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

		}`}, function (i) { var r = {}; function n(e) { if (r[e]) return r[e].exports; var t = r[e] = { i: e, l: !1, exports: {} }; return i[e].call(t.exports, t, t.exports, n), t.l = !0, t.exports } return n.m = i, n.c = r, n.d = function (e, t, i) { n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i }) }, n.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, n.t = function (t, e) { if (1 & e && (t = n(t)), 8 & e) return t; if (4 & e && "object" == typeof t && t && t.__esModule) return t; var i = Object.create(null); if (n.r(i), Object.defineProperty(i, "default", { enumerable: !0, value: t }), 2 & e && "string" != typeof t) for (var r in t) n.d(i, r, function (e) { return t[e] }.bind(null, r)); return i }, n.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return n.d(t, "a", t), t }, n.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, n.p = "", n(n.s = 10) }([function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); class r { } (t.default = r).Init = "Init", r.Ready = "Ready", r.Tick = "Tick", r.Resize = "Resize", r.Dispose = "Dispose", r.OffscreenOrbitControls_values = "OffscreenOrbitControls_values", r.GUIHelperUI_values = "GUIHelperUI_values" }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.LayersType = t.DefaultNotity = void 0; class r { } (t.DefaultNotity = r).OnScenechanged = "OnScenechanged", r.OnSemaphorefinish = "OnSemaphorefinish", (t = t.LayersType || (t.LayersType = {}))[t.default = 0] = "default", t[t.bloom = 1] = "bloom" }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }); class r extends i(9).EventEmitter { } t.default = r }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = { debug: { axesHelper: { enable: !1 }, gridHelper: { enable: !1, size: 50 }, lightHelper: { enable: !1 } }, camera: { minDistance: 0, maxDistance: 100, enableDamping: !1, enableZoom: !0, enablePan: !1, enableRotate: !1, origin: { x: 0, y: 0, z: 100 }, position: { x: 0, y: 15035449993752064e-31, z: 24.55475326309648 }, rotation: { x: -6123233995736766e-32, y: 0, z: 0 } }, env: { globalscalar: 1, clearcolor: 0 }, fog: { enable: !1, color: "#f0f0f0f0", density: .005, near: 20, far: 120 }, light: { ambientLight: { intensity: .4, color: "#ffffff" }, directionalLight: { intensity: 13.5, color: "#ffffff", distance: 10, elevation: 34, azimuth: -115, useshadow: !1, mapSize: 4096 }, hemisphereLight: { intensity: 0, color: "#ffffff" } }, effect: { exposure: 1, lut: { enabled: !0, intensity: .5, file: "AriColour_4k_Cine_AriGold.cube" }, bloom: { enable: !0, threshold: .269, strength: 1.01, radius: .337 }, outline: { enable: !0, visibleEdgeColor: "#ff00ff", edgeStrength: 6, edgeGlow: 1, edgeThickness: 2, pulsePeriod: 1 } }, DES: { defaultUser: "liutianshun", defaultKey: "zsqy123456" }, earth: { type: 2, radius: 5, animation: { enable: !0, time: 2e3 }, glow: { c: 1.7, p: 2.3, color: 65797 }, color: { nationaloutline: 16711680, provincialoutline: 9013641, wave: 16777215, lightpillar: 65280, flydot: 16777215, fly: 33501, track: 1644825, satellite: 16777215 } } } }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = class { constructor() { this.arr = [] } add(e) { this.indexOf(e) < 0 && this.arr.push(e) } remove(e) { 0 <= (e = this.indexOf(e)) && delete this.arr[e] } indexOf(e) { return this.arr.indexOf(e) } size() { return Object.keys(this.arr).length } clear() { delete this.arr, this.arr = [] } toArray() { for (var e = new Array, t = 0; t < this.arr.length; t++)this.arr[t] && e.push(this.arr[t]); return e } } }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = class { constructor(e = 10) { this.elements = new Array(e), this._size = 0 } push(e) { var t = this.elements.length; this._size >= t && (t = new Array(t), this.elements = this.elements.concat(t)), this.elements[this._size++] = e } pop() { return this.elements[--this._size] } peek() { return this.elements[this._size - 1] } size() { return this._size } empty() { return 0 == this._size } clear(e = 10) { delete this.elements[0], this.elements = new Array(e), this._size = 0 } } }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = class { constructor(e) { this.elements = new Array, this._size = e } enqueue(e) { return null != e && (null == this._size || isNaN(this._size) || this.elements.length == this._size && this.dequeue(), this.elements.unshift(e), !0) } dequeue() { return this.elements.pop() } size() { return this.elements.length } empty() { return 0 == this.size() } clear() { delete this.elements, this.elements = new Array } } }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = class { constructor() { this.items = {}, this.has = this.has.bind(this), this.set = this.set.bind(this), this.delete = this.delete.bind(this) } has(e) { return this.items.hasOwnProperty(e) } set(e, t) { this.items[e] = t } delete(e) { return this.has(e) && delete this.items[e], !1 } get(e) { return this.has(e) ? this.items[e] : void 0 } values() { let e = []; for (var t in this.items) this.has(t) && e.push(this.items[t]); return e } clear() { this.items = {} } } }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = class { SetSketch(e) { this.sketch = e } GetSketch() { return this.sketch } } }, function (e, t, i) { "use strict"; i.r(t), i.d(t, "EventEmitter", function () { return r }); class r { constructor() { this.callbacks = {}, this.callbacks.base = {} } on(e, t) { const i = this; return void 0 === e || "" === e ? (console.warn("wrong names"), !1) : void 0 === t ? (console.warn("wrong callback"), !1) : (this.resolveNames(e).forEach(function (e) { e = i.resolveName(e), i.callbacks[e.namespace] instanceof Object || (i.callbacks[e.namespace] = {}), i.callbacks[e.namespace][e.value] instanceof Array || (i.callbacks[e.namespace][e.value] = []), i.callbacks[e.namespace][e.value].push(t) }), this) } off(e) { const i = this; return void 0 === e || "" === e ? (console.warn("wrong name"), !1) : (this.resolveNames(e).forEach(function (e) { var t = i.resolveName(e); if ("base" !== t.namespace && "" === t.value) delete i.callbacks[t.namespace]; else if ("base" === t.namespace) for (const e in i.callbacks) i.callbacks[e] instanceof Object && i.callbacks[e][t.value] instanceof Array && (delete i.callbacks[e][t.value], 0 === Object.keys(i.callbacks[e]).length && delete i.callbacks[e]); else i.callbacks[t.namespace] instanceof Object && i.callbacks[t.namespace][t.value] instanceof Array && (delete i.callbacks[t.namespace][t.value], 0 === Object.keys(i.callbacks[t.namespace]).length && delete i.callbacks[t.namespace]) }), this) } trigger(e, t = null) { if (void 0 === e || "" === e) return console.warn("wrong name"), !1; const i = this; let r = null, n = null; const a = t instanceof Array ? t : []; var o = this.resolveNames(e); if ("base" === (o = this.resolveName(o[0])).namespace) for (const e in i.callbacks) i.callbacks[e] instanceof Object && i.callbacks[e][o.value] instanceof Array && i.callbacks[e][o.value].forEach(function (e) { n = e.apply(i, a), void 0 === r && (r = n) }); else if (this.callbacks[o.namespace] instanceof Object) { if ("" === o.value) return console.warn("wrong name"), this; i.callbacks[o.namespace][o.value].forEach(function (e) { n = e.apply(i, a), void 0 === r && (r = n) }) } return r } resolveNames(e) { let t = e; return t = (t = (t = t.replace(/[^a-zA-Z0-9 ,/.]/g, "")).replace(/[,/]+/g, " ")).split(" ") } resolveName(e) { const t = {}, i = e.split("."); return t.original = e, t.value = i[0], t.namespace = "base", 1 < i.length && "" !== i[1] && (t.namespace = i[1]), t } } }, function (e, t, i) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.Library = void 0; const o = r(i(3)), s = r(i(0)), n = r(i(11)); t.Library = class { static World() { return new n.default } static Initialize(i, a) { var r; { let e, t = document.getElementById(i.elementId); if (t && ((e = document.createElement("canvas")).style.width = "100vw", e.style.height = "100vh", e.style.position = "absolute", e.style.top = "0", e.style.left = "0", t.appendChild(e)), !e) return; e.oncontextmenu = function (e) { 2 == e.button && e.preventDefault() }, r = { container: t, offscreen: e.transferControlToOffscreen() } } { let n = r.container, e = r.offscreen; a.onerror = e => console.trace(e), a.postMessage({ id: s.default.Init, canvas: e, width: n.clientWidth, height: n.clientHeight, pixelRatio: window.devicePixelRatio, key: i.key, debug: i.debug }, [e]), a.onmessage = r => { if (r.data.id == s.default.Ready) { if (i.debug) { let t = (new THREE.ObjectLoader).parse(r.data.camera), e = JSON.parse(r.data.extraData), i = new THREE.OrbitControls(t, n); i.target = new THREE.Vector3(e.lookAt.x, e.lookAt.y, e.lookAt.z), i.maxDistance = o.default.camera.maxDistance, i.minDistance = o.default.camera.minDistance, i.enableDamping = o.default.camera.enableDamping, i.dampingFactor = .25, i.enableZoom = o.default.camera.enableZoom, i.minZoom = .5, i.maxZoom = 2, i.enablePan = o.default.camera.enablePan, i.keyPanSpeed = 1e3, i.enableRotate = o.default.camera.enableRotate, i.rotateSpeed = 1, i.autoRotate = !1, i.autoRotateSpeed = .2, i.addEventListener("change", () => { var e = { id: "OffscreenOrbitControls_values", position: t.position, rotation: JSON.stringify(t.rotation), quaternion: JSON.stringify(t.quaternion), target: i.target }; a.postMessage(e) }) } } else r.data.id, s.default.Tick }, window.addEventListener("resize", e => { var t = { id: s.default.Resize, width: n.clientWidth, height: n.clientHeight }; a.postMessage(t) }) } } } }, function (e, t, i) { "use strict"; var r = this && this.__createBinding || (Object.create ? function (e, t, i, r) { void 0 === r && (r = i), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[i] } }) } : function (e, t, i, r) { e[r = void 0 === r ? i : r] = t[i] }), n = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: !0, value: t }) } : function (e, t) { e.default = t }), a = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (null != e) for (var i in e) "default" !== i && Object.prototype.hasOwnProperty.call(e, i) && r(t, e, i); return n(t, e), t }, o = this && this.__awaiter || function (e, o, s, l) { return new (s = s || Promise)(function (i, t) { function r(e) { try { a(l.next(e)) } catch (e) { t(e) } } function n(e) { try { a(l.throw(e)) } catch (e) { t(e) } } function a(e) { var t; e.done ? i(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) { e(t) })).then(r, n) } a((l = l.apply(e, o || [])).next()) }) }, s = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const l = s(i(12)), c = a(i(19)), h = i(1), u = s(i(0)), d = s(i(20)), p = s(i(22)); class f extends l.default { constructor() { super(), this.debug = !0, this.bAssetsReady = !1, this.bReady = !1, this.bCheckedSemaphore = !1, this.center = new THREE.Vector3(0, 0, 0), this.Run = this.Run.bind(this) } Setup(e, t) { return o(this, void 0, void 0, function* () { this.canvas = e.canvas, this.width = e.width, this.height = e.height, this.pixelRatio = e.pixelRatio, this.debug = e.debug, this.callback = t, this.debug && this.SetRender(this.width, this.height, this.pixelRatio), this.SetCamera(this.width, this.height), this.debug && (this.SetDebug()), this.assets.InitAsync(c.list, () => { this.bAssetsReady = !0, this.sprite.Init(), this.effect.Init(this.scene, this.renderer, this.camera), this.Init() }), this.on(h.DefaultNotity.OnSemaphorefinish, () => { this.GetEntities().forEach(e => { e.object && (e.object.visible = !0) }), this.GetEntities().forEach(e => { e.Ready() }), this.bReady = !0 }), this.Run() }) } Ready() { this.callback && (this.callback(), delete this.callback) } Init() { this.SetEntity(new p.default), this.SetEntity(new d.default), this.debug } Run() { if (this.trigger("tick", []), this.bReady && this.bAssetsReady) { TWEEN.update(); for (const e of this.entities.values()) e.Update(this.clock.getDelta(), this.clock.getElapsedTime()); this.mixers.forEach(e => { var t = e.t.getDelta(); e.m && e.m.update(t) }), this.sender && this.sender(u.default.Tick, {}) } else !this.bAssetsReady || this.assets.bCheckedSemaphore || 0 < this.assets.semaphoreAmount || (this.bCheckedSemaphore = !0, this.trigger(h.DefaultNotity.OnSemaphorefinish)); this.Render(), requestAnimationFrame(this.Run.bind(this)) } Resize(e) { this.width = e.width, this.height = e.height, this.camera.aspect = this.width / this.height, this.camera.updateProjectionMatrix(), this.renderer.setSize(this.width, this.height, !1), this.trigger("resize") } Dispose() { let e = this.canvas.getContext("2d"), t = ((e = null == (e = null == (e = null == e ? this.canvas.getContext("webgl") : e) ? this.canvas.getContext("webgl2") : e) ? this.canvas.getContext("experimental-webgl") : e) && (e.clearColor(0, 0, 0, 1), e.clear(e.COLOR_BUFFER_BIT), console.log("%cCanvas Release", "color:red")), this.scene.clear(), this.renderer.dispose(), this.renderer.forceContextLoss(), this.renderer.domElement.getContext("webgl")); if (null != t) { let e = t.getExtension("WEBGL_lose_context"); e && e.loseContext() } } SetDebug() { let t = this.params.debug.gridHelper.size / 2, i = [], r = null, e = null; { let e = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), t, 16711680); e.position.set(0, 0, 0), e.renderOrder = 1, e.layers.set(h.LayersType.default), i.push(e), (e = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), t, 255)).position.set(0, 0, 0), e.renderOrder = 1, e.layers.set(h.LayersType.default), i.push(e), (e = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), t, 65280)).position.set(0, 0, 0), e.renderOrder = 1, e.layers.set(h.LayersType.default), i.push(e), (r = new THREE.AxesHelper(t)).renderOrder = 1 } var n, a; (e = new THREE.GridHelper(2 * t, 2 * t, 8421504, 8421504)).position.set(0, .05, 0), e.renderOrder = 1, e.layers.set(h.LayersType.default), a = this.scene, this.params.debug.axesHelper.enable ? (i.forEach(e => { a.add(e) }), a.add(r)) : (i.forEach(e => { a.remove(e) }), a.remove(r)), n = this.scene, this.params.debug.gridHelper.enable ? n.add(e) : n.remove(e) } OnCameraValue(e) { this.camera.position.x = e.position.x, this.camera.position.y = e.position.y, this.camera.position.z = e.position.z, e = JSON.parse(e.quaternion), this.camera.quaternion._x = e._x, this.camera.quaternion._y = e._y, this.camera.quaternion._z = e._z, this.camera.quaternion._w = e._w } OnGUIValue(e) { this.trigger(u.default.GUIHelperUI_values, [e]) } } t.default = f }, function (e, t, i) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const n = i(9), a = r(i(3)), o = i(1), s = r(i(13)), l = r(i(14)), c = r(i(16)); class h extends n.EventEmitter { constructor() { super(), this.mixers = [], this.entities = new Map, this.params = a.default, this.clock = new THREE.Clock, this.scene = new THREE.Scene, this.assets = new c.default(this), this.effect = new l.default(this), this.sprite = new s.default(this) } GetEntities() { return this.entities } GetEntityByName(e) { return this.entities.get(e) || null } SetEntity(e) { e.SetSketch(this), e.Init(), this.entities.set(e.name, e) } DestroyEntities() { for (const e of this.entities.values()) e.Destroy() } SetRender(e, t, i) { this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: !0, alpha: !0, depth: !0, precision: "highp", premultipliedAlpha: !1, stencil: !1, preserveDrawingBuffer: !0 }), this.renderer.setSize(e, t, !1), this.renderer.setPixelRatio(i), this.renderer.sortObjects = !1, this.renderer.autoClear = !1, this.renderer.outputEncoding = THREE.sRGBEncoding, this.renderer.setClearColor(this.params.env.clearcolor, 1), this.scene.background = new THREE.Color("#000f0f"), this.renderer.toneMapping = THREE.LinearToneMapping, this.renderer.toneMappingExposure = this.params.effect.exposure, THREE.ShaderChunk.tonemapping_pars_fragment = THREE.ShaderChunk.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", "#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\n        float toneMappingWhitePoint = 1.0;\n        vec3 CustomToneMapping( vec3 color ) {\n          color *= toneMappingExposure;\n          return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n        }"), this.renderer.shadowMap.enabled = this.params.light.useshadow, this.renderer.shadowMap.type = THREE.PCFSoftShadowMap, this.renderer.shadowMap.needsUpdate = !0, this.pmremGenerator = new THREE.PMREMGenerator(this.renderer), this.pmremGenerator.compileEquirectangularShader() } SetCamera(e, t) { this.camera = new THREE.PerspectiveCamera, this.camera.name = "CAMERA", this.camera.fov = 45, this.camera.aspect = e / t, this.camera.near = .1, this.camera.far = 1200, this.camera.position.set(this.params.camera.origin.x, this.params.camera.origin.y, this.params.camera.origin.z), this.camera.rotation.set(this.params.camera.rotation.x, this.params.camera.rotation.y, this.params.camera.rotation.z), this.camera.updateProjectionMatrix(), this.scene.add(this.camera) } Render() { this.camera.layers.disable(o.LayersType.default), this.camera.layers.enable(o.LayersType.bloom), this.effect && this.effect.bloomComposer && (this.effect.bloomComposer.renderToScreen = !1, this.effect.bloomComposer.render()), this.camera.layers.enable(o.LayersType.default), this.camera.layers.disable(o.LayersType.bloom), this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.effect.finalComposer && this.effect.finalComposer.render(this.clock.elapsedTime) } } t.default = h }, function (e, t, i) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); class n extends (r = r(i(2))).default { constructor(e) { super(), this.world = e } Init() { } static S2P(e) { let t = new THREE.MeshPhongMaterial; return t.color = e.color, t.map = e.map, t.specular = new THREE.Color("#ffffff"), t.reflectivity = 1, t.transparent = e.transparent, t.opacity = e.opacity, t.envMap = e.envMap, t } static S2L(e) { let t = new THREE.MeshLambertMaterial; return t.color = e.color, t.map = e.map, t.transparent = e.transparent, t.opacity = e.opacity, t.envMap = e.envMap, t } Release() { } } t.default = n }, function (e, t, i) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const n = r(i(2)), a = r(i(15)); class o extends n.default { constructor(t) { super(), (this.world = t).on("SetGUIValue", e => { switch (e.key) { case "effect.bloom.threshold": t.params.effect.bloom.threshold = e.value, this.bloomPass && (this.bloomPass.threshold = t.params.effect.bloom.threshold); break; case "effect.bloom.strength": t.params.effect.bloom.strength = e.value, this.bloomPass && (this.bloomPass.strength = t.params.effect.bloom.strength); break; case "effect.bloom.radius": t.params.effect.bloom.radius = e.value, this.bloomPass && (this.bloomPass.radius = t.params.effect.bloom.radius); break; case "effect.outline.visibleEdgeColor": t.params.effect.outline.visibleEdgeColor = e.value, this.outlinePass && (this.outlinePass.visibleEdgeColor.set(e.value), this.outlinePass.hiddenEdgeColor.set(e.value)); break; case "effect.outline.edgeStrength": t.params.effect.outline.edgeStrength = e.value, this.outlinePass && (this.outlinePass.edgeStrength = e.value); break; case "effect.outline.edgeGlow": t.params.effect.outline.edgeGlow = e.value, this.outlinePass && (this.outlinePass.edgeGlow = e.value); break; case "effect.outline.edgeThickness": t.params.effect.outline.edgeThickness = e.value, this.outlinePass && (this.outlinePass.edgeThickness = e.value); break; case "effect.outline.pulsePeriod": t.params.effect.outline.pulsePeriod = e.value, this.outlinePass && (this.outlinePass.pulsePeriod = e.value); break; case "effect.outline.edgeThickness": t.params.effect.outline.edgeThickness = e.value, this.outlinePass && (this.outlinePass.edgeThickness = e.value); break; case "effect.outline.pulsePeriod": t.params.effect.outline.pulsePeriod = e.value, this.outlinePass && (this.outlinePass.pulsePeriod = e.value); break; case "effect.lut.intensity": t.params.effect.lut.intensity = e.value, this.lutPass && (this.lutPass.intensity = e.value); break; default: console.log(e.key), console.log(e.value) } }) } Init(e, t, i) { this.renderPass = new THREE.RenderPass(e, i); { this.bloomComposer = new THREE.EffectComposer(t), this.bloomComposer.renderToScreen = !1, this.bloomComposer.addPass(this.renderPass); let e = new THREE.UnrealBloomPass(new THREE.Vector2(this.world.width, this.world.height), 1.5, .4, .85); e.threshold = this.world.params.effect.bloom.threshold, e.strength = this.world.params.effect.bloom.strength, e.radius = this.world.params.effect.bloom.radius, this.bloomPass = e, this.bloomComposer.renderTarget2.texture.encoding = THREE.sRGBEncoding, this.bloomComposer.renderTarget2.texture.wrapS = THREE.ClampToEdgeWrapping, this.bloomComposer.renderTarget2.texture.wrapT = THREE.ClampToEdgeWrapping, this.world.params.effect.bloom.enable && this.bloomComposer.addPass(e) } var r = new a.default(this.bloomComposer.renderTarget2.texture); this.finalPass = new THREE.ShaderPass(r.shaderMaterial, "baseTexture"), this.finalPass.needsSwap = !0, this.finalComposer = new THREE.EffectComposer(t), this.finalComposer.renderToScreen = !0, this.finalComposer.setSize(this.world.width, this.world.height), this.finalComposer.addPass(this.renderPass), this.finalComposer.addPass(this.finalPass), this.Outline(e, i, this.world.width, this.world.height), this.Lut(), this.OnSize = this.OnSize.bind(this), this.world.on("resize", () => { this.OnSize() }) } OnSize() { this.outlinePass && this.outlinePass.setSize(this.world.width, this.world.height), this.bloomPass && this.bloomPass.setSize(this.world.width, this.world.height), this.finalComposer && this.finalComposer.setSize(this.world.width, this.world.height) } Outline(e, t, i, r) { let n = new THREE.OutlinePass(new THREE.Vector2(i, r), e, t); n.edgeStrength = this.world.params.effect.outline.edgeStrength, n.edgeGlow = this.world.params.effect.outline.edgeGlow, n.edgeThickness = this.world.params.effect.outline.edgeThickness, n.pulsePeriod = this.world.params.effect.outline.pulsePeriod, n.usePatternTexture = !1, n.visibleEdgeColor.set(this.world.params.effect.outline.visibleEdgeColor), n.hiddenEdgeColor.set(this.world.params.effect.outline.visibleEdgeColor), n.selectedObjects = [], n.renderToScreen = !1, this.outlinePass = n, this.world.params.effect.outline.enable && this.finalComposer.addPass(n) } Lut() { var e = this.world.assets.Assets.get(this.world.params.effect.lut.file); this.lutPass = new THREE.LUTPass({ lut: void 0, intensity: 0 }), (this.lutPass.lut = e) || (this.world.params.effect.lut.enabled = !1), this.lutPass.enabled = this.world.params.effect.lut.enabled, this.lutPass.intensity = this.world.params.effect.lut.intensity, this.world.params.effect.lut.enabled && (this.finalComposer.addPass(this.finalPass), this.finalComposer.addPass(this.lutPass)) } } t.default = o }, function (e, t, i) { "use strict"; Object.defineProperty(t, "__esModule", { value: !0 }), t.default = class { constructor(e) { this.shaderMaterial = new THREE.ShaderMaterial({ uniforms: { baseTexture: { value: null }, bloomTexture: { value: e } }, vertexShader: "\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }\n                ", fragmentShader: "\n                uniform sampler2D baseTexture;\n                uniform sampler2D bloomTexture;\n                varying vec2 vUv;\n                void main() {\n                    gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );\n                }\n            " }) } } }, function (e, t, i) { "use strict"; var r = this && this.__awaiter || function (e, o, s, l) { return new (s = s || Promise)(function (i, t) { function r(e) { try { a(l.next(e)) } catch (e) { t(e) } } function n(e) { try { a(l.throw(e)) } catch (e) { t(e) } } function a(e) { var t; e.done ? i(e.value) : ((t = e.value) instanceof s ? t : new s(function (e) { e(t) })).then(r, n) } a((l = l.apply(e, o || [])).next()) }) }, n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const a = n(i(2)), o = i(17), s = i(18); class l extends a.default { constructor(e) { super(), this.semaphoreAmount = 0, this.bCheckedSemaphore = !1, this.asyncAssetsAmount = 0, this.world = e, this.assets = new o.Dictionary } get Assets() { return this.assets } InitAsync(e, i) { return r(this, void 0, void 0, function* () {  this.asyncAssetsAmount = e.length, e.forEach(t => r(this, void 0, void 0, function* () { var e; "skybox" == t.group ? (e = yield this.AsyncLoadTexture(t.path, t.name), this.assets.set(t.group + t.name, e), this.asyncAssetsAmount--) : "lut" == t.group ? (e = yield this.AsyncLoadCube(t.path, t.name), this.assets.set(t.name, e), this.asyncAssetsAmount--) : "texture" == t.group ? (e = yield this.AsyncLoadTexture(t.path, t.name), this.assets.set(t.name, e), this.asyncAssetsAmount--) : "geoJson" == t.group && (e = yield this.AsyncLoadFile(t.path, t.name), this.assets.set(t.name, e), this.asyncAssetsAmount--), this.asyncAssetsAmount <= 0 && i() })) }) } SingleLoadGlb(e, t, i) { this.semaphoreAmount++; const r = new THREE.GLTFLoader; r.setPath(e), r.load(t, e => { e.scene.traverse(e => { e instanceof THREE.Mesh && (e.castShadow = this.world.params.light.directionalLight.useshadow, e.receiveShadow = this.world.params.light.directionalLight.useshadow, e.material.isMeshStandardMaterial) }), e.scene.visible = !1, this.semaphoreAmount--, i(e) }, e => { }, e => { console.error(e) }) } AsyncLoadTexture(t, i) { return r(this, void 0, void 0, function* () { let e = yield s.OffscreenTextureLoader(t + i); return e.mapping = THREE.UVMapping, e.encoding = THREE.sRGBEncoding, e.wrapS = THREE.ClampToEdgeWrapping, e.wrapT = THREE.ClampToEdgeWrapping, e }) } AsyncLoadCube(t, i) { return r(this, void 0, void 0, function* () { const e = new THREE.LUTCubeLoader; return (yield e.loadAsync(t + i)).texture }) } AsyncLoadFile(t, i) { return r(this, void 0, void 0, function* () { let e = new THREE.FileLoader; return yield e.loadAsync(t + i) }) } } t.default = l }, function (e, t, i) { "use strict"; i.r(t); var r = i(4), n = i.n(r), r = (i.d(t, "ArraySet", function () { return n.a }), i(5)), a = i.n(r), r = (i.d(t, "Stack", function () { return a.a }), i(6)), o = i.n(r), r = (i.d(t, "Queue", function () { return o.a }), i(7)), s = i.n(r); i.d(t, "Dictionary", function () { return s.a }) }, function (e, t, i) { "use strict"; i.r(t), i.d(t, "OffscreenTextureLoader", function () { return r }), i.d(t, "OffscreenTextureLoaderSync", function () { return a }); let n = { imageOrientation: "flipY" }; const r = async (e, t = n) => { let i = new THREE.ImageBitmapLoader; return i.setOptions(t), t = await new Promise(t => { i.load(e, function (e) { t(e) }) }), new THREE.CanvasTexture(t) }, a = async (e, t, i = n) => { let r = new THREE.ImageBitmapLoader; r.setOptions(i), r.load(e, function (e) { e = new CanvasTexture(e), t(e) }) } }, function (e, t) { e.exports = { list: [{ group: "lut", path: "./assets/common/cube/", name: "AriColour_4k_Cine_AriGold.cube" }, { group: "texture", path: "./assets/common/env/", name: "surrounding.jpg" }, { group: "texture", path: "./assets/common/skybox/", name: "env.jpg" }, { group: "texture", path: "./assets/common/textures/", name: "earth.png" }, { group: "texture", path: "./assets/common/textures/", name: "satellite.png" }, { group: "texture", path: "./assets/common/textures/", name: "earth_aperture.png" }, { group: "texture", path: "./assets/common/textures/", name: "halo.png" }, { group: "texture", path: "./assets/common/textures/", name: "lighting.jpg" }, { group: "texture", path: "./assets/common/textures/", name: "gradient.png" }, { group: "geoJson", path: "./assets/geoJson/", name: "china.json" }, { group: "geoJson", path: "./assets/geoJson/", name: "china-outline.json" }, { group: "texture", path: "./assets/common/textures/", name: "point1.png" }, { group: "texture", path: "./assets/common/textures/", name: "point2.png" }, { group: "texture", path: "./assets/common/textures/", name: "point3.png" }, { group: "texture", path: "./assets/common/textures/", name: "annulus.png" }, { group: "texture", path: "./assets/common/textures/", name: "lightcolumn.png" }] } }, function (e, t, i) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const s = i(21), n = r(i(8)), a = i(1), o = r(i(0)); class l extends n.default { constructor() { super(), this.name = "MyEarth", this.initFlag = !1, this.waveMeshArr = [], this.map = new THREE.Object3D, this.groupHalos = [], this.groupDots = new THREE.Group, this.groupLines = new THREE.Group, this.aGroup = new THREE.Group, this.nationalMaterials = [], this.wavematerials = [] } Init() { let t = this.GetSketch(); this.object = new THREE.Group, t.scene.add(this.object), this.provinceMaterial = new THREE.LineBasicMaterial({ color: new THREE.Color(t.params.earth.color.provincialoutline) }), this.flydotMateria = new THREE.MeshPhongMaterial({ color: t.params.earth.color.flydot }), t.on(o.default.GUIHelperUI_values, e => { switch (e.key) { case "earth.glow.c": this.globematerial1 && (this.globematerial1.uniforms.c.value = e.value); break; case "earth.glow.p": this.globematerial1 && (this.globematerial1.uniforms.p.value = e.value); break; case "earth.glow.color": this.globematerial1 && (this.globematerial1.uniforms.color.value = new THREE.Color(e.value)); break; case "earth.type": t.params.earth.type = e.value, 1 == t.params.earth.type ? this.earthMesh.material = this.globematerial1 : this.earthMesh.material = this.globematerial2; break; case "earth.animation.enable": t.params.earth.animation.enable = e.value; break; case "earth.color.wave": t.params.earth.color.wave = e.value, this.wavematerials.forEach(e => { e.color = new THREE.Color(t.params.earth.color.wave) }); break; case "earth.color.nationaloutline": t.params.earth.color.nationaloutline = e.value, this.nationalMaterials.forEach(e => { e.uniforms.color.value = new THREE.Color(t.params.earth.color.nationaloutline) }); break; case "earth.color.provincialoutline": t.params.earth.color.provincialoutline = e.value, this.provinceMaterial.color = new THREE.Color(t.params.earth.color.provincialoutline); break; case "earth.color.flydot": t.params.earth.color.flydot = e.value, this.flydotMateria.color = new THREE.Color(t.params.earth.color.flydot); break; case "earth.color.fly": t.params.earth.color.fly = e.value, t.trigger("setflycolor", []); break; case "earth.color.track": t.params.earth.color.track = e.value, this.trackmaterial && (this.trackmaterial.emissive = new THREE.Color(t.params.earth.color.track)); break; case "earth.color.lightpillar": t.params.earth.color.lightpillar = e.value, this.lightpillarmaterial && (this.lightpillarmaterial.color = new THREE.Color(t.params.earth.color.lightpillar)); break; case "earth.color.satellite": t.params.earth.color.satellite = e.value, this.satellitematerial && (this.satellitematerial.color = new THREE.Color(t.params.earth.color.satellite)) } }) } initTween(e) { let t = this.GetSketch(), i = new THREE.Vector3(t.params.camera.origin.x, t.params.camera.origin.y, t.params.camera.origin.z), r = new THREE.Vector3(t.params.camera.position.x, t.params.camera.position.y, t.params.camera.position.z); (e = new TWEEN.Tween(i).to(r, e).easing(TWEEN.Easing.Quadratic.InOut)).onUpdate(() => { t.camera.position.set(i.x, i.y, i.z) }), e.onComplete(() => { this.initFlag = !0, this.initSatellite(), this.initGeoJson(), this.initPOI(), this.initRandomDot(), t.Ready() }), e.delay(100), e.start() } initEarth() { let r = this.GetSketch(), e = r.assets.Assets.get("earth.png"); e.wrapS = e.wrapT = THREE.RepeatWrapping; var t = { viewVector: { type: "v3", value: new THREE.Vector3(0, 0, 1) }, c: { type: "f", value: r.params.earth.glow.c }, p: { type: "f", value: r.params.earth.glow.p }, u_diffuse: { type: "t", value: e }, color: { type: "c", value: new THREE.Color(r.params.earth.glow.color) } }, t = (this.globematerial1 = new THREE.ShaderMaterial({ uniforms: t, vertexShader: "\t\n            uniform vec3 viewVector;\n            uniform float c;\n            uniform float p;\n            varying vec2 vUv;\n            varying float intensity;\n        \n            void main() {\n                 vec3 v_normal = normalize(normalMatrix * normal);\n                vec3 v_view = normalize(normalMatrix * viewVector);\n                intensity = pow(c - dot(v_normal, v_view), p);\n                 vUv = uv;\n                  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n            }", fragmentShader: "\n            uniform sampler2D u_diffuse;\n            uniform vec3 color;\n            varying float intensity;\n            varying vec2 vUv;\n            void main() {\n                vec3 glow = color * intensity;\n                  gl_FragColor = vec4(glow, 1.0)+ texture2D(u_diffuse, vUv);\n            }\n            ", side: THREE.DoubleSide, blending: THREE.AdditiveBlending }), new THREE.Mesh(new THREE.SphereGeometry(.999 * r.params.earth.radius, 100, 100), new THREE.MeshBasicMaterial({ color: 0 }))), t = (this.object.add(t), this.globematerial2 = new THREE.MeshLambertMaterial({ map: e }), new THREE.SphereGeometry(r.params.earth.radius, 100, 100)); this.earthMesh = new THREE.Mesh(t, void 0); { let e = new THREE.SphereGeometry(1.01 * r.params.earth.radius, 100, 100), t = r.assets.Assets.get("lighting.jpg"), i = new THREE.Mesh(e, new THREE.MeshLambertMaterial({ emissive: new THREE.Color("0xfffff"), emissiveMap: t })); i.layers.set(a.LayersType.bloom), this.object.add(i) } this.object.rotation.set(.5, 2.9, .1), this.object.add(this.earthMesh), 1 == r.params.earth.type ? this.earthMesh.material = this.globematerial1 : this.earthMesh.material = this.globematerial2 } initSatellite() { let n = this.GetSketch(), e = t => { let i = new THREE.Group; n.scene.add(i), this.groupHalos.push(i); { var r = new THREE.PlaneGeometry(14, 14); this.trackmaterial = new THREE.MeshLambertMaterial({ map: n.assets.Assets.get("halo.png"), transparent: !0, side: THREE.DoubleSide, depthWrite: !1, emissive: new THREE.Color(n.params.earth.color.track) }); let e = new THREE.Mesh(r, this.trackmaterial); e.layers.set(a.LayersType.bloom), i.rotation.set(t.x, t.y, t.z), i.add(e) } r = [new THREE.Vector3(-7, 0, 0), new THREE.Vector3(7, 0, 0)], t = (new THREE.BufferGeometry).setFromPoints(r), this.satellitematerial = new THREE.PointsMaterial({ map: n.assets.Assets.get("satellite.png"), transparent: !0, side: THREE.DoubleSide, size: .5, depthWrite: !1, color: new THREE.Color(n.params.earth.color.satellite) }), (r = new THREE.Points(t, this.satellitematerial)).layers.set(a.LayersType.bloom), i.add(r) }; e({ x: 1.9, y: .5, z: 1 }), e({ x: 1.9, y: -.5, z: 1 }) } initEarthSprite() { let e = this.GetSketch(); var t = new THREE.SpriteMaterial({ map: e.assets.Assets.get("earth_aperture.png"), transparent: !0, opacity: .9, depthWrite: !1 }); (t = new THREE.Sprite(t)).scale.set(3 * e.params.earth.radius, 3 * e.params.earth.radius, 1), this.object.add(t) } initStarrySky() { let e = this.GetSketch(); const t = [], i = [], r = new THREE.BufferGeometry; for (var n = 0; n < 1e4; n++) { var a = new THREE.Vector3; a.x = 2 * Math.random() - 1, a.y = 2 * Math.random() - 1, a.z = 2 * Math.random() - 1, t.push(a.x, a.y, a.z), (a = new THREE.Color).setHSL(.2 * Math.random() + .5, .55, .25 * Math.random() + .55), i.push(a.r, a.g, a.b) } r.setAttribute("position", new THREE.Float32BufferAttribute(t, 3)), r.setAttribute("color", new THREE.Float32BufferAttribute(i, 3)); var o = new THREE.PointsMaterial({ map: e.assets.Assets.get("gradient.png"), size: 1, transparent: !0, opacity: 1, vertexColors: !0, blending: THREE.AdditiveBlending, sizeAttenuation: !0 }); this.stars = new THREE.Points(r, o), this.stars.scale.set(300, 300, 300), e.scene.add(this.stars) } initGeoJson() { let o = this.GetSketch(); JSON.parse(o.assets.Assets.get("china.json")).features.forEach(e => { let a = new THREE.Object3D; e.geometry.coordinates.forEach(e => { e.forEach(t => { const i = [], e = new THREE.BufferGeometry; for (let e = 0; e < t.length; e++) { var r = s.lglt2xyz(t[e][0], t[e][1], o.params.earth.radius); i.push(r.x, r.y, r.z) } e.setAttribute("position", new THREE.Float32BufferAttribute(i, 3)); var n = new THREE.Line(e, this.provinceMaterial); a.add(n) }) }), this.map.add(a) }), this.object.add(this.map), JSON.parse(o.assets.Assets.get("china-outline.json")).features.forEach(e => { const a = new THREE.Object3D; e.geometry.coordinates.forEach(e => { e.forEach(t => { if (200 < t.length) { var i = []; for (let e = 0; e < t.length; e++) { var r = s.lglt2xyz(t[e][0], t[e][1], o.params.earth.radius); i.push(r) } var e = new THREE.CatmullRomCurve3(i, !1), n = new THREE.Color(o.params.earth.color.nationaloutline), e = this.iniLine(e, { speed: .4, color: new THREE.Vector3(n.r, n.g, n.b), number: 3, length: .2, size: 3 }, 5e3); a.add(e) } }) }), this.map.add(a) }), this.object.add(this.map) } iniLine(e, t, i) { var r = e.getPoints(i), e = (new THREE.BufferGeometry).setFromPoints(r), n = r.length; let a = new Float32Array(n); for (let e = 0; e < r.length; e += 1)a[e] = e / n; return i = this.initLineMaterial(t), this.nationalMaterials.push(i), new THREE.Points(e, i) } initLineMaterial(e) { return e = { u_time: { type: "f", value: 0 }, number: { type: "f", value: e && Number(e.number) || 1 }, speed: { type: "f", value: e && Number(e.speed) || 1 }, length: { type: "f", value: e && Number(e.length) || .5 }, size: { type: "f", value: e && Number(e.size) || 3 }, color: { type: "v3", value: e && e.color || new THREE.Vector3(0, 1, 1) } }, new THREE.ShaderMaterial({ uniforms: e, vertexShader: "\n            varying vec2 vUv;\n            attribute float percent;\n            uniform float u_time;\n            uniform float number;\n            uniform float speed;\n            uniform float length;\n            varying float opacity;\n            uniform float size;\n            void main()\n            {\n                vUv = uv;\n                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n                float l = clamp(1.0-length,0.0,1.0);\n                gl_PointSize = clamp(fract(percent*number + l - u_time*number*speed)-l ,0.0,1.) * size * (1./length);\n                opacity = gl_PointSize/size;\n                gl_Position = projectionMatrix * mvPosition;\n            }\n            ", fragmentShader: "\n            #ifdef GL_ES\n            precision mediump float;\n            #endif\n            varying float opacity;\n            uniform vec3 color;\n            void main(){\n                if(opacity <=0.2){\n                    discard;\n                }\n                gl_FragColor = vec4(color,1.0);\n            }\n            ", transparent: !0 }) } initAirRoute() { let a = this.GetSketch(); var i = []; this.groupDots.children.forEach(e => { if (this.groupDots.children[0].position.x == e.position.x) return !0; e = s.addLines(this.groupDots.children[0].position, e.position, (r, n) => { let e = () => { for (var e = [], t = new THREE.Color(a.params.earth.color.fly), i = 0; i < r; i++)e.push(t.r, t.g, t.b); n.setColors(e) }; e(), a.on("setflycolor", () => { e() }) }), this.groupLines.add(e.lineMesh), i.push(e.curve.getPoints(100)) }), this.object.add(this.groupLines); for (let e = 0; e < i.length; e++) { const a = new THREE.SphereGeometry(.03, .03, .03), i = new THREE.Mesh(a, this.flydotMateria); this.aGroup.add(i) } var r = 0; let e = () => { this.aGroup.children.forEach((e, t) => { t = i[t][r], e.position.set(t.x, t.y, t.z) }), 100 < ++r && (r = 0), setTimeout(e, 20) }; this.object.add(this.aGroup), e() } initPOI() { let i = this.GetSketch(); var r = i.assets.Assets.get("point3.png");[{ lng: 114.41, lat: 30.58 }].forEach(e => { var e = s.lglt2xyz(e.lng, e.lat, i.params.earth.radius), t = this.CreateLightPillar(e), e = (this.groupDots.add(t), this.CreateLightWaveMesh(e, r, i.params.earth.radius, i.params.earth.color.lightpillar)); t.add(e) }), this.object.add(this.groupDots) } initRandomDot() { let i = this.GetSketch();[{ x: -1.7049594735603837, y: 3.208354470512221, z: -3.4350509144786985 }, { x: -2.1965610576118175, y: 2.1955955192304506, z: -3.9184792759587768 }, { x: -2.2290975556080355, y: 2.6054406912933263, z: -3.639066211507457 }, { x: .5738958419746141, y: -.44114968930852216, z: 4.9473255920938985 }, { x: -.9326350073394328, y: 2.8399222968004114, z: -4.00812091773949 }, { x: 3.469198597393574, y: 1.2295167303380952, z: -3.3842206934036057 }, { x: -2.4019084876611916, y: -2.190220428765315, z: 3.7991801866087123 }, { x: -2.49363689878109, y: -4.099696049856375, z: 1.4050862307450966 }, { x: -2.3729307780326305, y: 2.840227787960863, z: 3.3618901878497454 }, { x: -2.0636200279017873, y: .7444294629976027, z: -4.493027615657812 }, { x: .47725894517680106, y: 2.4327372143508037, z: -4.34212085796347 }, { x: -2.4777001955161246, y: -1.2092952460724242, z: 4.171163716394502 }, { x: -.03915748918627658, y: -.008362945319338826, z: 4.999839672648135 }, { x: 1.5223738738260317, y: -1.032865814102439, z: -4.649254348640267 }, { x: -.26640112020426315, y: -4.314854187280748, z: 2.5121830716848077 }, { x: -4.031470206741836, y: -2.606648761952297, z: -1.3973654511134501 }, { x: .8544382232162094, y: 1.5274953155132989, z: 4.683662390031124 }, { x: 3.0409624989238546, y: 1.76433738825175, z: -3.555230043268055 }, { x: -4.721251023266457, y: 1.2354922989397954, z: -1.0878177947459262 }, { x: 2.1518961827021106, y: 3.891904027152385, z: -2.285262755638206 }, { x: .8501960736517479, y: -2.851729208821255, z: -4.018060123480341 }, { x: 2.5631840141785176, y: 4.263234820997851, z: -.5048926326370041 }, { x: -.4580143454812531, y: -2.6523265200067385, z: 4.213714144386437 }].map(e => { var t = this.CreatePointMesh(e, .5 < Math.random() ? i.assets.Assets.get("point1.png") : i.assets.Assets.get("point2.png"), i.params.earth.radius), t = (this.groupDots.add(t), this.CreateWaveMesh(e, i.assets.Assets.get("annulus.png"), i.params.earth.radius)); this.groupDots.add(t), this.waveMeshArr.push(t) }) } CreateLightPillar(e) { let t = this.GetSketch(); var i = t.assets.Assets.get("lightcolumn.png"), r = .1 * t.params.earth.radius, r = ((n = new THREE.PlaneBufferGeometry(.05 * t.params.earth.radius, r)).rotateX(Math.PI / 2), n.translate(0, 0, r / 2), this.lightpillarmaterial = new THREE.MeshBasicMaterial({ map: i, color: t.params.earth.color.lightpillar, transparent: !0, side: THREE.DoubleSide, depthWrite: !1 }), new THREE.Mesh(n, this.lightpillarmaterial)), n = ((i = new THREE.Group).add(r, r.clone().rotateZ(Math.PI / 2)), i.position.set(e.x, e.y, e.z), new THREE.Vector3(e.x, e.y, e.z).normalize()), r = new THREE.Vector3(0, 0, 1); return i.quaternion.setFromUnitVectors(r, n), i } CreateLightWaveMesh(e, t, i, r) { var n = new THREE.PlaneBufferGeometry(1, 1), r = new THREE.MeshBasicMaterial({ color: r, map: t, transparent: !0, depthWrite: !1 }); return (t = new THREE.Mesh(n, r)).scale.set(n = .05 * i, n, n), t } CreatePointMesh(e, t, i) { var t = new THREE.MeshBasicMaterial({ map: t, transparent: !0, depthWrite: !1 }), r = new THREE.PlaneBufferGeometry(1, 1), r = new THREE.Mesh(r, t), t = .04 * i, i = (r.scale.set(t, t, t), r.position.set(e.x, e.y, e.z), new THREE.Vector3(e.x, e.y, e.z).normalize()), t = new THREE.Vector3(0, 0, 1); return r.quaternion.setFromUnitVectors(t, i), r } CreateWaveMesh(e, t, i) { var r = this.GetSketch(), n = new THREE.PlaneBufferGeometry(1, 1), r = new THREE.MeshBasicMaterial({ color: r.params.earth.color.wave, map: t, transparent: !0, opacity: 1, depthWrite: !1 }); this.wavematerials.push(r); (t = new THREE.Mesh(n, r)).size = n = .055 * i, t.scale.set(n, n, n), t._s = +Math.random() + 1, t.position.set(e.x, e.y, e.z), r = new THREE.Vector3(e.x, e.y, e.z).normalize(), i = new THREE.Vector3(0, 0, 1); return t.quaternion.setFromUnitVectors(i, r), t } Ready() { var e = this.GetSketch(); this.initEarth(), this.initEarthSprite(), this.initStarrySky(), this.initTween(e.params.earth.animation.time) } Update() { var e = this.GetSketch(); this.initFlag && e.params.earth.animation.enable && (this.object && (this.object.rotation.y = this.object.rotation.y + .001), this.groupHalos.forEach(e => { e.rotation.z = e.rotation.z + .01 }), this.nationalMaterials.forEach(e => { e.uniforms.u_time.value += .007 }), this.stars && (this.stars.rotation.y += 1e-4), this.waveMeshArr.length && this.waveMeshArr.forEach(e => { e._s += .007, e.scale.set(e.size * e._s, e.size * e._s, e.size * e._s), e._s <= 1.5 ? e.material.opacity = 2 * (e._s - 1) : 1.5 < e._s && e._s <= 2 ? e.material.opacity = 1 - 2 * (e._s - 1.5) : e._s = 1 })) } Destroy() { } } t.default = l }, function (e, h, t) { "use strict"; Object.defineProperty(h, "__esModule", { value: !0 }), h.addLines = h.getPos = h.getLenVcetor = h.getVCenter = h.lglt2xyz = h.lon2xyz = void 0, h.lon2xyz = (e, t, i) => (t = t * Math.PI / 180, i = i * Math.PI / 180, t = -t, { x: e * Math.cos(i) * Math.cos(t), y: e * Math.sin(i), z: e * Math.cos(i) * Math.sin(t) }), h.lglt2xyz = (e, t, i) => (e = (90 + e) * (Math.PI / 180), t = (90 - t) * (Math.PI / 180), (new THREE.Vector3).setFromSpherical(new THREE.Spherical(i, t, e))), h.getVCenter = (e, t) => e.add(t).divideScalar(2), h.getLenVcetor = (e, t, i) => { var r = e.distanceTo(t); return e.lerp(t, i / r) }, h.getPos = (e, t, i) => ({ x: e * Math.sin(t) * Math.cos(i), y: e * Math.sin(t) * Math.sin(i), z: e * Math.cos(t) }), h.addLines = (e, t, i) => { for (var r = .4 * (n = 1.8 * e.angleTo(t) / Math.PI / .1), n = n * n * 12, a = new THREE.Vector3(0, 0, 0), n = (o = new THREE.Ray(a, h.getVCenter(e.clone(), t.clone()))).at(n / o.at(1, new THREE.Vector3(0, 0, 0)).distanceTo(a), new THREE.Vector3(0, 0, 0)), o = h.getLenVcetor(e.clone(), n, r), a = h.getLenVcetor(t.clone(), n, r), s = (n = new THREE.CubicBezierCurve3(e, o, a, t)).getSpacedPoints(50), r = new THREE.LineGeometry, l = [], c = 0; c < s.length; c++)l.push(s[c].x, s[c].y, s[c].z); return r.setPositions(l), i(s.length, r), e = new THREE.LineMaterial({ linewidth: 6e-4, vertexColors: !0, dashed: !1 }), { curve: n, lineMesh: new THREE.Line2(r, e) } } }, function (e, t, i) { "use strict"; var r = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: !0 }); const n = r(i(8)), a = r(i(0)), o = i(1); class s extends n.default { constructor() { super(...arguments), this.name = "MySky", this.textures = [], this.cubetextures = [], this.materials = [] } Init() { let r = this.GetSketch(); this.SetLight(r), r.on(a.default.GUIHelperUI_values, e => { switch (e.key) { case "light.ambientLight.intensity": this.ambientLight.intensity = e.value; break; case "light.ambientLight.color": this.ambientLight.color = new THREE.Color(e.value); break; case "light.hemisphereLight.intensity": this.hemisphereLight.intensity = e.value; break; case "light.hemisphereLight.color": this.hemisphereLight.color = new THREE.Color(e.value); break; case "light.directionalLight.intensity": this.directionalLight.intensity = e.value; break; case "light.directionalLight.color": this.directionalLight.color = new THREE.Color(e.value); break; case "light.directionalLight.distance": r.params.light.directionalLight.distance = e.value; var t = THREE.MathUtils.degToRad(90 - r.params.light.directionalLight.elevation), i = THREE.MathUtils.degToRad(r.params.light.directionalLight.azimuth); this.sun.setFromSphericalCoords(1, t, -i).multiplyScalar(r.params.light.directionalLight.distance), this.directionalLight.position.copy(this.sun), this.directionalLight.target.position.set(0, 0, 0); break; case "light.directionalLight.elevation": r.params.light.directionalLight.elevation = e.value, t = THREE.MathUtils.degToRad(90 - r.params.light.directionalLight.elevation), i = THREE.MathUtils.degToRad(r.params.light.directionalLight.azimuth), this.sun.setFromSphericalCoords(1, t, -i).multiplyScalar(r.params.light.directionalLight.distance), this.directionalLight.position.copy(this.sun), this.directionalLight.target.position.set(0, 0, 0); break; case "light.directionalLight.azimuth": r.params.light.directionalLight.azimuth = e.value, t = THREE.MathUtils.degToRad(90 - r.params.light.directionalLight.elevation), i = THREE.MathUtils.degToRad(r.params.light.directionalLight.azimuth), this.sun.setFromSphericalCoords(1, t, -i).multiplyScalar(r.params.light.directionalLight.distance), this.directionalLight.position.copy(this.sun), this.directionalLight.target.position.set(0, 0, 0) } }) } SetLight(i) { this.ambientLight = new THREE.AmbientLight(this.GetSketch().params.light.ambientLight, this.GetSketch().params.light.ambientLight.intensity), this.hemisphereLight = new THREE.HemisphereLight(this.GetSketch().params.light.hemisphereLight.color, this.GetSketch().params.light.hemisphereLight.color, this.GetSketch().params.light.hemisphereLight.intensity), this.hemisphereLight.position.set(0, 10, 0), this.sun = new THREE.Vector3(this.GetSketch().params.light.directionalLight.distance, this.GetSketch().params.light.directionalLight.distance, this.GetSketch().params.light.directionalLight.distance); var e = THREE.MathUtils.degToRad(90 - this.GetSketch().params.light.directionalLight.elevation), t = THREE.MathUtils.degToRad(this.GetSketch().params.light.directionalLight.azimuth); if (this.sun.setFromSphericalCoords(1, e, -t).multiplyScalar(this.GetSketch().params.light.directionalLight.distance), this.directionalLight = new THREE.DirectionalLight(this.GetSketch().params.light.directionalLight.color, this.GetSketch().params.light.directionalLight.intensity), this.directionalLight.position.copy(this.sun).normalize().multiplyScalar(10), this.directionalLight.target.position.set(0, 0, 0), this.directionalLight.castShadow = this.GetSketch().params.light.directionalLight.useshadow, this.directionalLight.shadow.camera.near = 20, this.directionalLight.shadow.camera.far = 200, this.directionalLight.shadow.camera.left = -50, this.directionalLight.shadow.camera.right = 50, this.directionalLight.shadow.camera.top = 50, this.directionalLight.shadow.camera.bottom = -50, this.directionalLight.shadow.bias = -.001, this.directionalLight.shadow.mapSize = new THREE.Vector2(this.GetSketch().params.light.directionalLight.mapSize, this.GetSketch().params.light.directionalLight.mapSize), i.debug && i.params.debug.lightHelper.enable) { let e = new THREE.HemisphereLightHelper(this.hemisphereLight, 1, 16773135), t = (e.name = "hemisphereHelper", i.scene.add(e), new THREE.DirectionalLightHelper(this.directionalLight, 5, 16773135)); t.name = "directionalHelper", i.scene.add(t) } this.ambientLight.layers.set(o.LayersType.default), this.hemisphereLight.layers.set(o.LayersType.default), this.directionalLight.layers.set(o.LayersType.default) } Ready() { let t = this.GetSketch(); t.scene.background = new THREE.Color("#000000"); { let e = this.GetSketch().scene; var i = new THREE.BoxBufferGeometry(1024, 1024, 1024, 16, 12), r = t.assets.Assets.get("env.jpg").clone(); this.skymaterial = new THREE.MeshBasicMaterial({ color: 16777215, side: THREE.BackSide, map: r }), this.skymaterial.map && (this.skymaterial.map.flipY = !1), this.sky = new THREE.Mesh(i, this.skymaterial), this.sky.layers.set(o.LayersType.default), this.sky.name = "sky1", this.sky.scale.x = -1, this.GetSketch().scene.add(this.sky), t.params.fog.enable && ((r = new THREE.Fog(t.params.fog.color, t.params.fog.density)).near = t.params.fog.near, r.far = t.params.fog.far, e.fog = r), e.add(this.directionalLight), e.add(this.hemisphereLight), e.add(this.ambientLight) } } Update() { } Destroy() { this.cubetextures.forEach(e => { e.dispose() }), this.cubetextures = [], this.textures.forEach(e => { e.dispose() }), this.textures = [], this.materials.forEach(e => { e.dispose() }), this.materials = [] } } t.default = s }])); let ctx = self; { let i = EARTH.Library.World(); const xOb = (e, t) => { t = CryptoJS.enc.Utf8.parse(t); return CryptoJS.DES.decrypt({ ciphertext: CryptoJS.enc.Hex.parse(e) }, t, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.Pkcs7 }).toString(CryptoJS.enc.Utf8) }, yOb = e => { var e = xOb(e, i.params.DES.defaultKey), e = JSON.parse(e), t = (new Date).getTime(); return null != e.user || null != e.email || null != e.registerdate || null != e.expirationdate ? (t = Math.ceil((e.expirationdate - t) / 1e3 / 60 / 60 / 24),  i.Authorized = !0) : i.Authorized = !1 }; i.sender = (e, t) => { i.Authorized && ctx.postMessage({ id: e, data: t }) }; let t = e => { switch (e.id) { case "Init": yOb(e.key), null != i && i.Authorized && i.Setup(e, () => { var e = { id: "Ready", camera: i.camera.toJSON(), extraData: JSON.stringify({ lookAt: i.center }) }; ctx.postMessage(e) }); break; case "Dispose": null != i && i.Authorized && i.Dispose(); break; case "Resize": null != i && i.Authorized && i.Resize(e); break; case "OffscreenOrbitControls_values": null != i && i.Authorized && i.OnCameraValue(e); break; case "GUIHelperUI_values": null != i && i.Authorized && i.OnGUIValue(e) } }; ctx.addEventListener("message", e => { t(e.data) }) }